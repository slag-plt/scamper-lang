<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Scamper Web Runner</title>
  </head>
  <body>
    <div>
      Scamper 1.3.3
      <button onclick="runFromClipboard()">Run from clipboard</button>
    </div>
    <hr>
    <div id="output" class="scamper-output output-prog" style="white-space: pre; font-family: monospace;"></div>
  </body>
  <script>
  "use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // node_modules/jazz-midi/index.js
  var require_jazz_midi = __commonJS({
    "node_modules/jazz-midi/index.js"(exports, module) {
      var path3 = "./bin/";
      var v = process.versions.node.split(".");
      if (v[0] <= 10)
        path3 += "10_15/";
      else if (v[0] <= 11)
        path3 += "11_15/";
      if (process.platform == "win32" && process.arch == "ia32")
        path3 += "win32/jazz";
      else if (process.platform == "win32" && process.arch == "x64")
        path3 += "win64/jazz";
      else if (process.platform == "darwin" && process.arch == "x64")
        path3 += "macos64/jazz";
      else if (process.platform == "linux" && process.arch == "x64")
        path3 += "linux64/jazz";
      else if (process.platform == "linux" && process.arch == "arm")
        path3 += "linuxa7/jazz";
      module.exports = __require(path3);
      module.exports.package = __require(__dirname + "/package.json");
    }
  });

  // dist/web/jzz/jzz-combined.cjs
  var require_jzz_combined = __commonJS({
    "dist/web/jzz/jzz-combined.cjs"(exports, module) {
      "use strict";
      var JZZ3 = function(global3, factory) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define("JZZ", [], factory);
        } else {
          if (!global3)
            global3 = window;
          if (global3.JZZ && global3.JZZ.MIDI)
            return;
          global3.JZZ = factory();
        }
      }(exports, function() {
        var _scope = typeof window === "undefined" ? global : window;
        var _version = "1.5.2";
        var i, j, k, m, n;
        var _time = Date.now || function() {
          return new Date().getTime();
        };
        var _startTime = _time();
        var _now = typeof performance != "undefined" && performance.now ? function() {
          return performance.now();
        } : function() {
          return _time() - _startTime;
        };
        var _schedule = function(f) {
          setTimeout(f, 0);
        };
        function _nop() {
        }
        function _func(f) {
          return typeof f == "function";
        }
        function _R() {
          this._orig = this;
          this._ready = false;
          this._queue = [];
          this._log = [];
        }
        _R.prototype._exec = function() {
          while (this._ready && this._queue.length) {
            var x = this._queue.shift();
            x[0].apply(this, x[1]);
          }
        };
        _R.prototype._push = function(func, arg) {
          this._queue.push([func, arg]);
          _R.prototype._exec.apply(this);
        };
        _R.prototype._slip = function(func, arg) {
          this._queue.unshift([func, arg]);
        };
        _R.prototype._pause = function() {
          this._ready = false;
        };
        _R.prototype._resume = function() {
          this._ready = true;
          _R.prototype._exec.apply(this);
        };
        _R.prototype._break = function(err) {
          this._orig._bad = true;
          this._orig._log.push(err || "Unknown JZZ error");
        };
        _R.prototype._repair = function() {
          this._orig._bad = false;
        };
        _R.prototype._crash = function(err) {
          this._break(err);
          this._resume();
        };
        _R.prototype._err = function() {
          return this._log[this._log.length - 1];
        };
        _R.prototype.log = function() {
          return _clone(this._log);
        };
        _R.prototype._dup = function() {
          var F = function() {
          };
          F.prototype = this._orig;
          var ret = new F();
          ret._ready = false;
          ret._queue = [];
          return ret;
        };
        _R.prototype._image = function() {
          return this._dup();
        };
        _R.prototype._thenable = function() {
          if (this.then)
            return this;
          var self = this;
          var F = function() {
          };
          F.prototype = self;
          var ret = new F();
          ret.then = function(good, bad) {
            self._push(_then, [good, bad]);
            return this;
          };
          return ret;
        };
        function _then(good, bad) {
          if (this._bad) {
            if (_func(bad))
              bad.apply(this, [new Error(this._err())]);
          } else {
            if (_func(good))
              good.apply(this, [this]);
          }
        }
        function _wait(obj, delay) {
          if (this._bad)
            obj._crash(this._err());
          else
            setTimeout(function() {
              obj._resume();
            }, delay);
        }
        _R.prototype.wait = function(delay) {
          if (!delay)
            return this;
          var ret = this._image();
          this._push(_wait, [ret, delay]);
          return ret._thenable();
        };
        function _kick(obj) {
          if (this._bad)
            obj._break(this._err());
          obj._resume();
        }
        function _rechain(self, obj, name2) {
          self[name2] = function() {
            var arg = arguments;
            var ret = obj._image();
            this._push(_kick, [ret]);
            return ret[name2].apply(ret, arg);
          };
        }
        function _and(q) {
          if (!this._bad) {
            if (_func(q))
              q.apply(this);
            else
              console.log(q);
          }
        }
        _R.prototype.and = function(func) {
          this._push(_and, [func]);
          return this._thenable();
        };
        function _or(q) {
          if (this._bad) {
            if (_func(q))
              q.apply(this);
            else
              console.log(q);
          }
        }
        _R.prototype.or = function(func) {
          this._push(_or, [func]);
          return this._thenable();
        };
        _R.prototype._info = {};
        _R.prototype.info = function() {
          var info = _clone(this._orig._info);
          if (typeof info.engine == "undefined")
            info.engine = "none";
          if (typeof info.sysex == "undefined")
            info.sysex = true;
          return info;
        };
        _R.prototype.name = function() {
          return this.info().name;
        };
        function _close(obj) {
          if (this._bad)
            obj._crash(this._err());
          else {
            this._break("Closed");
            obj._resume();
          }
        }
        _R.prototype.close = function() {
          var ret = new _R();
          if (this._close)
            this._push(this._close, []);
          this._push(_close, [ret]);
          return ret._thenable();
        };
        function _tryAny(arr) {
          if (!arr.length) {
            this._break();
            return;
          }
          var func = arr.shift();
          if (arr.length) {
            var self = this;
            this._slip(_or, [function() {
              _tryAny.apply(self, [arr]);
            }]);
          }
          try {
            this._repair();
            func.apply(this);
          } catch (err) {
            this._break(err.toString());
          }
        }
        function _push(arr, obj) {
          for (var i2 = 0; i2 < arr.length; i2++)
            if (arr[i2] === obj)
              return;
          arr.push(obj);
        }
        function _pop(arr, obj) {
          for (var i2 = 0; i2 < arr.length; i2++)
            if (arr[i2] === obj) {
              arr.splice(i2, 1);
              return;
            }
        }
        function _J() {
          _R.apply(this);
        }
        _J.prototype = new _R();
        function _for(x, f) {
          for (var k2 in x)
            if (x.hasOwnProperty(k2))
              f.call(this, k2);
        }
        function _clone(obj, key, val) {
          if (typeof key == "undefined")
            return _clone(obj, [], []);
          if (obj instanceof Object) {
            for (var i2 = 0; i2 < key.length; i2++)
              if (key[i2] === obj)
                return val[i2];
            var ret;
            if (obj instanceof Array)
              ret = [];
            else
              ret = {};
            key.push(obj);
            val.push(ret);
            _for(obj, function(k2) {
              ret[k2] = _clone(obj[k2], key, val);
            });
            return ret;
          }
          return obj;
        }
        _J.prototype._info = { name: "JZZ.js", ver: _version, version: _version, inputs: [], outputs: [] };
        var _outs = [];
        var _ins = [];
        var _outsW = [];
        var _insW = [];
        function _postRefresh() {
          _jzz._info.engine = _engine._type;
          _jzz._info.version = _engine._version;
          _jzz._info.sysex = _engine._sysex;
          _jzz._info.inputs = [];
          _jzz._info.outputs = [];
          _outs = [];
          _ins = [];
          _engine._allOuts = {};
          _engine._allIns = {};
          var i2, x;
          for (i2 = 0; i2 < _engine._outs.length; i2++) {
            x = _engine._outs[i2];
            x.engine = _engine;
            _engine._allOuts[x.name] = x;
            _jzz._info.outputs.push({
              id: x.name,
              name: x.name,
              manufacturer: x.manufacturer,
              version: x.version,
              engine: _engine._type
            });
            _outs.push(x);
          }
          for (i2 = 0; i2 < _virtual._outs.length; i2++) {
            x = _virtual._outs[i2];
            _jzz._info.outputs.push({
              id: x.name,
              name: x.name,
              manufacturer: x.manufacturer,
              version: x.version,
              engine: x.type
            });
            _outs.push(x);
          }
          for (i2 = 0; i2 < _engine._ins.length; i2++) {
            x = _engine._ins[i2];
            x.engine = _engine;
            _engine._allIns[x.name] = x;
            _jzz._info.inputs.push({
              id: x.name,
              name: x.name,
              manufacturer: x.manufacturer,
              version: x.version,
              engine: _engine._type
            });
            _ins.push(x);
          }
          for (i2 = 0; i2 < _virtual._ins.length; i2++) {
            x = _virtual._ins[i2];
            _jzz._info.inputs.push({
              id: x.name,
              name: x.name,
              manufacturer: x.manufacturer,
              version: x.version,
              engine: x.type
            });
            _ins.push(x);
          }
          if (_jzz._watcher && _jzz._watcher._handles.length) {
            var diff = _diff(_insW, _outsW, _jzz._info.inputs, _jzz._info.outputs);
            if (diff) {
              for (j = 0; j < diff.inputs.removed.length; j++) {
                x = _engine._inMap[diff.inputs.removed[j].name];
                if (x)
                  x._closeAll();
              }
              for (j = 0; j < diff.outputs.removed.length; j++) {
                x = _engine._outMap[diff.outputs.removed[j].name];
                if (x)
                  x._closeAll();
              }
              _fireW(diff);
            }
          }
          _insW = _jzz._info.inputs;
          _outsW = _jzz._info.outputs;
        }
        function _refresh() {
          if (!this._bad)
            _engine._refresh(this);
        }
        _J.prototype.refresh = function() {
          this._push(_refresh, []);
          return this._thenable();
        };
        function _filterList(q, arr) {
          var i2, n2;
          if (_func(q))
            q = q(arr);
          if (!(q instanceof Array))
            q = [q];
          var before = [];
          var after = [];
          var etc = arr.slice();
          var a = before;
          for (i2 = 0; i2 < q.length; i2++) {
            if (typeof q[i2] == "undefined")
              a = after;
            else if (q[i2] instanceof RegExp)
              for (n2 = 0; n2 < etc.length; n2++) {
                if (q[i2].test(etc[n2].name)) {
                  a.push(etc[n2]);
                  etc.splice(n2, 1);
                  n2--;
                }
              }
            else {
              for (n2 = 0; n2 < etc.length; n2++)
                if (q[i2] + "" === n2 + "" || q[i2] === etc[n2].name || q[i2] instanceof Object && q[i2].name === etc[n2].name) {
                  a.push(etc[n2]);
                  etc.splice(n2, 1);
                  n2--;
                }
            }
          }
          return a == before ? before : before.concat(etc).concat(after);
        }
        function _notFound(port, q) {
          var msg2;
          if (q instanceof RegExp)
            msg2 = "Port matching " + q + " not found";
          else if (q instanceof Object || typeof q == "undefined")
            msg2 = "Port not found";
          else
            msg2 = 'Port "' + q + '" not found';
          port._crash(msg2);
        }
        function _openMidiOut(port, arg) {
          if (this._bad)
            port._crash(this._err());
          else {
            var arr = _filterList(arg, _outs);
            if (!arr.length) {
              _notFound(port, arg);
              return;
            }
            var pack = function(x) {
              return function() {
                x.engine._openOut(this, x.name);
              };
            };
            for (var i2 = 0; i2 < arr.length; i2++)
              arr[i2] = pack(arr[i2]);
            port._slip(_tryAny, [arr]);
            port._resume();
          }
        }
        _J.prototype.openMidiOut = function(arg) {
          var port = new _M();
          this._push(_refresh, []);
          this._push(_openMidiOut, [port, arg]);
          return port._thenable();
        };
        _J.prototype._openMidiOutNR = function(arg) {
          var port = new _M();
          this._push(_openMidiOut, [port, arg]);
          return port._thenable();
        };
        function _openMidiIn(port, arg) {
          if (this._bad)
            port._crash(this._err());
          else {
            var arr = _filterList(arg, _ins);
            if (!arr.length) {
              _notFound(port, arg);
              return;
            }
            var pack = function(x) {
              return function() {
                x.engine._openIn(this, x.name);
              };
            };
            for (var i2 = 0; i2 < arr.length; i2++)
              arr[i2] = pack(arr[i2]);
            port._slip(_tryAny, [arr]);
            port._resume();
          }
        }
        _J.prototype.openMidiIn = function(arg) {
          var port = new _M();
          this._push(_refresh, []);
          this._push(_openMidiIn, [port, arg]);
          return port._thenable();
        };
        _J.prototype._openMidiInNR = function(arg) {
          var port = new _M();
          this._push(_openMidiIn, [port, arg]);
          return port._thenable();
        };
        function _onChange(watcher, arg) {
          if (this._bad)
            watcher._crash();
          else {
            watcher._slip(_connectW, [arg]);
            watcher._resume();
          }
        }
        _J.prototype.onChange = function(arg) {
          if (!this._orig._watcher)
            this._orig._watcher = new _W();
          var watcher = this._orig._watcher._image();
          this._push(_onChange, [watcher, arg]);
          return watcher._thenable();
        };
        _J.prototype._close = function() {
          _engine._close();
        };
        function _M() {
          _R.apply(this);
          this._handles = [];
          this._outs = [];
        }
        _M.prototype = new _R();
        _M.prototype._filter = function(msg2) {
          if (this._orig._mpe) {
            var out;
            var outs = 0;
            if (this._handles && this._handles.length) {
              outs = this._handles.length;
              out = this._handles[0];
            }
            if (this._outs && this._outs.length) {
              outs = this._outs.length;
              out = this._outs[0];
            }
            if (outs == 1 && !out._mpe) {
              msg2 = this._orig._mpe.filter(msg2);
            }
          }
          return msg2;
        };
        _M.prototype._receive = function(msg2) {
          this._emit(this._filter(msg2));
        };
        function _receive(msg2) {
          if (!this._bad)
            this._receive(msg2);
        }
        _M.prototype.send = function() {
          this._push(_receive, [MIDI2.apply(null, arguments)]);
          return this._thenable();
        };
        _M.prototype.note = function(c, n2, v, t) {
          this.noteOn(c, n2, v);
          if (typeof this._ch == "undefined" && typeof this._master == "undefined") {
            if (t > 0)
              this.wait(t).noteOff(c, n2);
          } else {
            if (v > 0)
              this.wait(v).noteOff(c);
          }
          return this._thenable();
        };
        _M.prototype._emit = function(msg2) {
          var i2;
          for (i2 = 0; i2 < this._handles.length; i2++)
            this._handles[i2].apply(this, [MIDI2(msg2)._stamp(this)]);
          for (i2 = 0; i2 < this._outs.length; i2++) {
            var m2 = MIDI2(msg2);
            if (!m2._stamped(this._outs[i2]))
              this._outs[i2].send(m2._stamp(this));
          }
        };
        function _emit(msg2) {
          this._emit(msg2);
        }
        _M.prototype.emit = function(msg2) {
          this._push(_emit, [msg2]);
          return this._thenable();
        };
        function _connect(arg) {
          if (_func(arg))
            _push(this._orig._handles, arg);
          else
            _push(this._orig._outs, arg);
        }
        function _disconnect(arg) {
          if (typeof arg == "undefined") {
            this._orig._handles = [];
            this._orig._outs = [];
          } else if (_func(arg))
            _pop(this._orig._handles, arg);
          else
            _pop(this._orig._outs, arg);
        }
        _M.prototype.connect = function(arg) {
          this._push(_connect, [arg]);
          return this._thenable();
        };
        _M.prototype.disconnect = function(arg) {
          this._push(_disconnect, [arg]);
          return this._thenable();
        };
        _M.prototype.connected = function() {
          return this._orig._handles.length + this._orig._outs.length;
        };
        _M.prototype._image = function() {
          var dup = this._dup();
          dup._ch = this._ch;
          dup._sxid = this._sxid;
          dup._master = this._master;
          dup._band = this._band;
          return dup;
        };
        _M.prototype._ch = void 0;
        _M.prototype._sxid = 127;
        _M.prototype._master = void 0;
        _M.prototype._band = void 0;
        _M.prototype.sxId = function(id) {
          if (typeof id == "undefined")
            id = _M.prototype._sxid;
          if (id == this._sxid)
            return this._thenable();
          id = _7b(id);
          var img = this._image();
          img._sxid = id;
          this._push(_kick, [img]);
          return img._thenable();
        };
        _M.prototype.ch = function(c) {
          if (c == this._ch || typeof c == "undefined" && typeof this._ch == "undefined")
            return this._thenable();
          var img = this._image();
          if (typeof c != "undefined")
            c = _ch(c);
          img._ch = c;
          img._master = void 0;
          img._band = void 0;
          this._push(_kick, [img]);
          return img._thenable();
        };
        function _mpe(m2, n2) {
          if (!this._orig._mpe)
            this._orig._mpe = new MPE();
          this._orig._mpe.setup(m2, n2);
        }
        _M.prototype.mpe = function(m2, n2) {
          if (m2 == this._master && n2 == this._band || typeof m2 == "undefined" && typeof this._master == "undefined")
            return this._thenable();
          if (typeof m2 != "undefined")
            MPE.validate(m2, n2);
          if (!n2)
            return this.ch(m2);
          var img = this._image();
          img._ch = void 0;
          img._master = m2;
          img._band = n2;
          this._push(_mpe, [m2, n2]);
          this._push(_kick, [img]);
          return img._thenable();
        };
        function _validateChannel(c) {
          if (c != parseInt(c) || c < 0 || c > 15)
            throw RangeError("Bad channel value (must not be less than 0 or more than 15): " + c);
        }
        function _W() {
          _R.apply(this);
          this._handles = [];
          _rechain(this, _jzz, "refresh");
          _rechain(this, _jzz, "openMidiOut");
          _rechain(this, _jzz, "openMidiIn");
          _rechain(this, _jzz, "onChange");
          _rechain(this, _jzz, "close");
        }
        _W.prototype = new _R();
        function _connectW(arg) {
          if (_func(arg)) {
            if (!this._orig._handles.length)
              _engine._watch();
            _push(this._orig._handles, arg);
          }
        }
        function _disconnectW(arg) {
          if (typeof arg == "undefined")
            this._orig._handles = [];
          else
            _pop(this._orig._handles, arg);
          if (!this._orig._handles.length)
            _engine._unwatch();
        }
        _W.prototype.connect = function(arg) {
          this._push(_connectW, [arg]);
          return this._thenable();
        };
        _W.prototype.disconnect = function(arg) {
          this._push(_disconnectW, [arg]);
          return this._thenable();
        };
        function _changed(x0, y0, x1, y1) {
          var i2;
          if (x0.length != x1.length || y0.length != y1.length)
            return true;
          for (i2 = 0; i2 < x0.length; i2++)
            if (x0[i2].name != x1[i2].name)
              return true;
          for (i2 = 0; i2 < y0.length; i2++)
            if (y0[i2].name != y1[i2].name)
              return true;
          return false;
        }
        function _diff(x0, y0, x1, y1) {
          if (!_changed(x0, y0, x1, y1))
            return;
          var ax = [];
          var ay = [];
          var rx = [];
          var ry = [];
          var i2;
          var h = {};
          for (i2 = 0; i2 < x0.length; i2++)
            h[x0[i2].name] = true;
          for (i2 = 0; i2 < x1.length; i2++)
            if (!h[x1[i2].name])
              ax.push(x1[i2]);
          h = {};
          for (i2 = 0; i2 < x1.length; i2++)
            h[x1[i2].name] = true;
          for (i2 = 0; i2 < x0.length; i2++)
            if (!h[x0[i2].name])
              rx.push(x0[i2]);
          h = {};
          for (i2 = 0; i2 < y0.length; i2++)
            h[y0[i2].name] = true;
          for (i2 = 0; i2 < y1.length; i2++)
            if (!h[y1[i2].name])
              ay.push(y1[i2]);
          h = {};
          for (i2 = 0; i2 < y1.length; i2++)
            h[y1[i2].name] = true;
          for (i2 = 0; i2 < y0.length; i2++)
            if (!h[y0[i2].name])
              ry.push(y0[i2]);
          return { inputs: { added: ax, removed: rx }, outputs: { added: ay, removed: ry } };
        }
        function _fireW(arg) {
          for (i = 0; i < _jzz._watcher._handles.length; i++)
            _jzz._watcher._handles[i].apply(_jzz, [arg]);
        }
        var _jzz;
        var _engine = { _outs: [], _ins: [] };
        var _virtual = { _outs: [], _ins: [] };
        function _tryNODE() {
          if (typeof module != "undefined" && module.exports) {
            _initNode(require_jazz_midi());
            return;
          }
          this._break();
        }
        function _tryJazzPlugin() {
          var div2 = document.createElement("div");
          div2.style.visibility = "hidden";
          document.body.appendChild(div2);
          var obj = document.createElement("object");
          obj.style.visibility = "hidden";
          obj.style.width = "0px";
          obj.style.height = "0px";
          obj.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90";
          obj.type = "audio/x-jazz";
          document.body.appendChild(obj);
          if (obj.isJazz) {
            _initJazzPlugin(obj);
            return;
          }
          this._break();
        }
        var _navigator;
        var _requestMIDIAccess;
        function _findMidiAccess() {
          if (typeof navigator !== "undefined" && navigator.requestMIDIAccess) {
            _navigator = navigator;
            _requestMIDIAccess = navigator.requestMIDIAccess;
            try {
              if (_requestMIDIAccess.toString().indexOf("JZZ(") != -1)
                _requestMIDIAccess = void 0;
            } catch (err) {
            }
          }
        }
        function _tryWebMIDI() {
          _findMidiAccess();
          if (_requestMIDIAccess) {
            var self = this;
            var onGood = function(midi) {
              _initWebMIDI(midi);
              self._resume();
            };
            var onBad = function(msg2) {
              self._crash(msg2);
            };
            var opt = {};
            _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);
            this._pause();
            return;
          }
          this._break();
        }
        function _tryWebMIDIsysex() {
          _findMidiAccess();
          if (_requestMIDIAccess) {
            var self = this;
            var onGood = function(midi) {
              _initWebMIDI(midi, true);
              self._resume();
            };
            var onBad = function(msg2) {
              self._crash(msg2);
            };
            var opt = { sysex: true };
            _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);
            this._pause();
            return;
          }
          this._break();
        }
        function _tryCRX() {
          var self = this;
          var inst;
          var msg2;
          function eventHandle() {
            inst = true;
            if (!msg2)
              msg2 = document.getElementById("jazz-midi-msg");
            if (!msg2)
              return;
            var a = [];
            try {
              a = JSON.parse(msg2.innerText);
            } catch (err) {
            }
            msg2.innerText = "";
            document.removeEventListener("jazz-midi-msg", eventHandle);
            if (a[0] === "version") {
              _initCRX(msg2, a[2]);
              self._resume();
            } else {
              self._crash();
            }
          }
          this._pause();
          document.addEventListener("jazz-midi-msg", eventHandle);
          try {
            document.dispatchEvent(new Event("jazz-midi"));
          } catch (err) {
          }
          _schedule(function() {
            if (!inst)
              self._crash();
          });
        }
        function _zeroBreak() {
          this._pause();
          var self = this;
          _schedule(function() {
            self._crash();
          });
        }
        function _filterEngines(opt) {
          var ret = [];
          var arr = _filterEngineNames(opt);
          for (var i2 = 0; i2 < arr.length; i2++) {
            if (arr[i2] == "webmidi") {
              if (opt && opt.sysex === true)
                ret.push(_tryWebMIDIsysex);
              if (!opt || opt.sysex !== true || opt.degrade === true)
                ret.push(_tryWebMIDI);
            } else if (arr[i2] == "node") {
              ret.push(_tryNODE);
              ret.push(_zeroBreak);
            } else if (arr[i2] == "extension")
              ret.push(_tryCRX);
            else if (arr[i2] == "plugin")
              ret.push(_tryJazzPlugin);
          }
          ret.push(_initNONE);
          return ret;
        }
        function _filterEngineNames(opt) {
          var web = ["node", "extension", "plugin", "webmidi"];
          if (!opt || !opt.engine)
            return web;
          var arr = opt.engine instanceof Array ? opt.engine : [opt.engine];
          var dup = {};
          var none;
          var etc;
          var head = [];
          var tail = [];
          var i2;
          for (i2 = 0; i2 < arr.length; i2++) {
            var name2 = arr[i2].toString().toLowerCase();
            if (dup[name2])
              continue;
            dup[name2] = true;
            if (name2 === "none")
              none = true;
            if (name2 === "etc" || typeof name2 == "undefined")
              etc = true;
            if (etc)
              tail.push(name2);
            else
              head.push(name2);
            _pop(web, name2);
          }
          if (etc || head.length || tail.length)
            none = false;
          return none ? [] : head.concat(etc ? web : tail);
        }
        function _initJZZ(opt) {
          _jzz = new _J();
          _jzz._options = opt;
          _jzz._push(_tryAny, [_filterEngines(opt)]);
          _jzz.refresh();
          _jzz._resume();
        }
        function _initNONE() {
          _engine._type = "none";
          _engine._version = _version;
          _engine._sysex = true;
          _engine._outs = [];
          _engine._ins = [];
          _engine._refresh = function() {
            _postRefresh();
          };
          _engine._watch = _nop;
          _engine._unwatch = _nop;
          _engine._close = _nop;
        }
        function _initEngineJP() {
          _engine._inArr = [];
          _engine._outArr = [];
          _engine._inMap = {};
          _engine._outMap = {};
          _engine._outsW = [];
          _engine._insW = [];
          _engine._version = _engine._main.version;
          _engine._sysex = true;
          var watcher;
          function _closeAll() {
            for (var i2 = 0; i2 < this.clients.length; i2++)
              this._close(this.clients[i2]);
          }
          _engine._refresh = function() {
            _engine._outs = [];
            _engine._ins = [];
            var i2, x;
            for (i2 = 0; (x = _engine._main.MidiOutInfo(i2)).length; i2++) {
              _engine._outs.push({ type: _engine._type, name: x[0], manufacturer: x[1], version: x[2] });
            }
            for (i2 = 0; (x = _engine._main.MidiInInfo(i2)).length; i2++) {
              _engine._ins.push({ type: _engine._type, name: x[0], manufacturer: x[1], version: x[2] });
            }
            _postRefresh();
          };
          _engine._openOut = function(port, name2) {
            var impl = _engine._outMap[name2];
            if (!impl) {
              if (_engine._pool.length <= _engine._outArr.length)
                _engine._pool.push(_engine._newPlugin());
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allOuts[name2].manufacturer,
                  version: _engine._allOuts[name2].version,
                  type: "MIDI-out",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _close: function(port2) {
                  _engine._closeOut(port2);
                },
                _closeAll,
                _receive: function(a) {
                  if (a.length)
                    this.plugin.MidiOutRaw(a.slice());
                }
              };
              var plugin = _engine._pool[_engine._outArr.length];
              impl.plugin = plugin;
              _engine._outArr.push(impl);
              _engine._outMap[name2] = impl;
            }
            if (!impl.open) {
              var s = impl.plugin.MidiOutOpen(name2);
              if (s !== name2) {
                if (s)
                  impl.plugin.MidiOutClose();
                port._break();
                return;
              }
              impl.open = true;
            }
            port._orig._impl = impl;
            _push(impl.clients, port._orig);
            port._info = impl.info;
            port._receive = function(arg) {
              impl._receive(arg);
            };
            port._close = function() {
              impl._close(this);
            };
          };
          _engine._openIn = function(port, name2) {
            var impl = _engine._inMap[name2];
            if (!impl) {
              if (_engine._pool.length <= _engine._inArr.length)
                _engine._pool.push(_engine._newPlugin());
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allIns[name2].manufacturer,
                  version: _engine._allIns[name2].version,
                  type: "MIDI-in",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _close: function(port2) {
                  _engine._closeIn(port2);
                },
                _closeAll,
                handle: function(t, a) {
                  for (var i2 = 0; i2 < this.clients.length; i2++) {
                    var msg2 = MIDI2(a);
                    this.clients[i2]._emit(msg2);
                  }
                }
              };
              var makeHandle = function(x) {
                return function(t, a) {
                  x.handle(t, a);
                };
              };
              impl.onmidi = makeHandle(impl);
              var plugin = _engine._pool[_engine._inArr.length];
              impl.plugin = plugin;
              _engine._inArr.push(impl);
              _engine._inMap[name2] = impl;
            }
            if (!impl.open) {
              var s = impl.plugin.MidiInOpen(name2, impl.onmidi);
              if (s !== name2) {
                if (s)
                  impl.plugin.MidiInClose();
                port._break();
                return;
              }
              impl.open = true;
            }
            port._orig._impl = impl;
            _push(impl.clients, port._orig);
            port._info = impl.info;
            port._close = function() {
              impl._close(this);
            };
          };
          _engine._closeOut = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length && impl.open) {
              impl.open = false;
              impl.plugin.MidiOutClose();
            }
          };
          _engine._closeIn = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length && impl.open) {
              impl.open = false;
              impl.plugin.MidiInClose();
            }
          };
          _engine._close = function() {
            for (var i2 = 0; i2 < _engine._inArr.length; i2++)
              if (_engine._inArr[i2].open)
                _engine._inArr[i2].plugin.MidiInClose();
            _engine._unwatch();
          };
          _engine._watch = function() {
            if (!watcher)
              watcher = setInterval(function() {
                _engine._refresh();
              }, 250);
          };
          _engine._unwatch = function() {
            if (watcher)
              clearInterval(watcher);
            watcher = void 0;
          };
        }
        function _initNode(obj) {
          _engine._type = "node";
          _engine._main = obj;
          _engine._pool = [];
          _engine._newPlugin = function() {
            return new obj.MIDI();
          };
          _initEngineJP();
        }
        function _initJazzPlugin(obj) {
          _engine._type = "plugin";
          _engine._main = obj;
          _engine._pool = [obj];
          _engine._newPlugin = function() {
            var plg = document.createElement("object");
            plg.style.visibility = "hidden";
            plg.style.width = "0px";
            obj.style.height = "0px";
            plg.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90";
            plg.type = "audio/x-jazz";
            document.body.appendChild(plg);
            return plg.isJazz ? plg : void 0;
          };
          _initEngineJP();
        }
        function _initWebMIDI(access, sysex) {
          _engine._type = "webmidi";
          _engine._version = 43;
          _engine._sysex = !!sysex;
          _engine._access = access;
          _engine._inMap = {};
          _engine._outMap = {};
          _engine._outsW = [];
          _engine._insW = [];
          var watcher;
          function _closeAll() {
            for (var i2 = 0; i2 < this.clients.length; i2++)
              this._close(this.clients[i2]);
          }
          _engine._refresh = function() {
            _engine._outs = [];
            _engine._ins = [];
            _engine._access.outputs.forEach(function(port) {
              _engine._outs.push({ type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version });
            });
            _engine._access.inputs.forEach(function(port) {
              _engine._ins.push({ type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version });
            });
            _postRefresh();
          };
          _engine._openOut = function(port, name2) {
            var impl = _engine._outMap[name2];
            if (!impl) {
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allOuts[name2].manufacturer,
                  version: _engine._allOuts[name2].version,
                  type: "MIDI-out",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _close: function(port2) {
                  _engine._closeOut(port2);
                },
                _closeAll,
                _receive: function(a) {
                  if (impl.dev && a.length)
                    this.dev.send(a.slice());
                }
              };
            }
            var found;
            _engine._access.outputs.forEach(function(dev) {
              if (dev.name === name2)
                found = dev;
            });
            if (found) {
              impl.dev = found;
              _engine._outMap[name2] = impl;
              port._orig._impl = impl;
              _push(impl.clients, port._orig);
              port._info = impl.info;
              port._receive = function(arg) {
                impl._receive(arg);
              };
              port._close = function() {
                impl._close(this);
              };
              if (impl.dev.open) {
                port._pause();
                impl.dev.open().then(function() {
                  port._resume();
                }, function() {
                  port._crash();
                });
              }
            } else
              port._break();
          };
          _engine._openIn = function(port, name2) {
            var impl = _engine._inMap[name2];
            if (!impl) {
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allIns[name2].manufacturer,
                  version: _engine._allIns[name2].version,
                  type: "MIDI-in",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _close: function(port2) {
                  _engine._closeIn(port2);
                },
                _closeAll,
                handle: function(evt) {
                  for (var i2 = 0; i2 < this.clients.length; i2++) {
                    var msg2 = MIDI2([].slice.call(evt.data));
                    this.clients[i2]._emit(msg2);
                  }
                }
              };
            }
            var found;
            _engine._access.inputs.forEach(function(dev) {
              if (dev.name === name2)
                found = dev;
            });
            if (found) {
              impl.dev = found;
              var makeHandle = function(x) {
                return function(evt) {
                  x.handle(evt);
                };
              };
              impl.dev.onmidimessage = makeHandle(impl);
              _engine._inMap[name2] = impl;
              port._orig._impl = impl;
              _push(impl.clients, port._orig);
              port._info = impl.info;
              port._close = function() {
                impl._close(this);
              };
              if (impl.dev.open) {
                port._pause();
                impl.dev.open().then(function() {
                  port._resume();
                }, function() {
                  port._crash();
                });
              }
            } else
              port._break();
          };
          _engine._closeOut = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length) {
              if (impl.dev && impl.dev.close)
                impl.dev.close();
              impl.dev = void 0;
            }
          };
          _engine._closeIn = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length) {
              if (impl.dev) {
                impl.dev.onmidimessage = null;
                if (impl.dev.close)
                  impl.dev.close();
              }
              impl.dev = void 0;
            }
          };
          _engine._close = function() {
            _engine._unwatch();
          };
          _engine._watch = function() {
            _engine._access.onstatechange = function() {
              watcher = true;
              _schedule(function() {
                if (watcher) {
                  _engine._refresh();
                  watcher = false;
                }
              });
            };
          };
          _engine._unwatch = function() {
            _engine._access.onstatechange = void 0;
          };
        }
        function _initCRX(msg2, ver) {
          _engine._type = "extension";
          _engine._version = ver;
          _engine._sysex = true;
          _engine._pool = [];
          _engine._outs = [];
          _engine._ins = [];
          _engine._inArr = [];
          _engine._outArr = [];
          _engine._inMap = {};
          _engine._outMap = {};
          _engine._outsW = [];
          _engine._insW = [];
          _engine.refreshClients = [];
          _engine._msg = msg2;
          _engine._newPlugin = function() {
            var plugin = { id: _engine._pool.length };
            _engine._pool.push(plugin);
            if (!plugin.id)
              plugin.ready = true;
            else
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["new"] }));
          };
          _engine._newPlugin();
          _engine._refresh = function(client) {
            _engine.refreshClients.push(client);
            client._pause();
            _schedule(function() {
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["refresh"] }));
            });
          };
          function _closeAll() {
            for (var i2 = 0; i2 < this.clients.length; i2++)
              this._close(this.clients[i2]);
          }
          _engine._openOut = function(port, name2) {
            var impl = _engine._outMap[name2];
            if (!impl) {
              if (_engine._pool.length <= _engine._outArr.length)
                _engine._newPlugin();
              var plugin = _engine._pool[_engine._outArr.length];
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allOuts[name2].manufacturer,
                  version: _engine._allOuts[name2].version,
                  type: "MIDI-out",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _start: function() {
                  document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["openout", plugin.id, name2] }));
                },
                _close: function(port2) {
                  _engine._closeOut(port2);
                },
                _closeAll,
                _receive: function(a) {
                  if (a.length) {
                    var v = a.slice();
                    v.splice(0, 0, "play", plugin.id);
                    document.dispatchEvent(new CustomEvent("jazz-midi", { detail: v }));
                  }
                }
              };
              impl.plugin = plugin;
              plugin.output = impl;
              _engine._outArr.push(impl);
              _engine._outMap[name2] = impl;
            }
            port._orig._impl = impl;
            _push(impl.clients, port._orig);
            port._info = impl.info;
            port._receive = function(arg) {
              impl._receive(arg);
            };
            port._close = function() {
              impl._close(this);
            };
            if (!impl.open) {
              port._pause();
              if (impl.plugin.ready)
                impl._start();
            }
          };
          _engine._openIn = function(port, name2) {
            var impl = _engine._inMap[name2];
            if (!impl) {
              if (_engine._pool.length <= _engine._inArr.length)
                _engine._newPlugin();
              var plugin = _engine._pool[_engine._inArr.length];
              impl = {
                name: name2,
                clients: [],
                info: {
                  name: name2,
                  manufacturer: _engine._allIns[name2].manufacturer,
                  version: _engine._allIns[name2].version,
                  type: "MIDI-in",
                  sysex: _engine._sysex,
                  engine: _engine._type
                },
                _start: function() {
                  document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["openin", plugin.id, name2] }));
                },
                _close: function(port2) {
                  _engine._closeIn(port2);
                },
                _closeAll
              };
              impl.plugin = plugin;
              plugin.input = impl;
              _engine._inArr.push(impl);
              _engine._inMap[name2] = impl;
            }
            port._orig._impl = impl;
            _push(impl.clients, port._orig);
            port._info = impl.info;
            port._close = function() {
              impl._close(this);
            };
            if (!impl.open) {
              port._pause();
              if (impl.plugin.ready)
                impl._start();
            }
          };
          _engine._closeOut = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length && impl.open) {
              impl.open = false;
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["closeout", impl.plugin.id] }));
            }
          };
          _engine._closeIn = function(port) {
            var impl = port._impl;
            _pop(impl.clients, port._orig);
            if (!impl.clients.length && impl.open) {
              impl.open = false;
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["closein", impl.plugin.id] }));
            }
          };
          _engine._close = function() {
            _engine._unwatch();
          };
          var watcher;
          _engine._watch = function() {
            _engine._insW = _engine._ins;
            _engine._outsW = _engine._outs;
            watcher = setInterval(function() {
              document.dispatchEvent(new CustomEvent("jazz-midi", { detail: ["refresh"] }));
            }, 250);
          };
          _engine._unwatch = function() {
            clearInterval(watcher);
            watcher = void 0;
          };
          document.addEventListener("jazz-midi-msg", function() {
            var v = _engine._msg.innerText.split("\n");
            var impl, i2, j2;
            _engine._msg.innerText = "";
            for (i2 = 0; i2 < v.length; i2++) {
              var a = [];
              try {
                a = JSON.parse(v[i2]);
              } catch (err) {
              }
              if (!a.length)
                continue;
              if (a[0] === "refresh") {
                if (a[1].ins) {
                  for (j2 = 0; j2 < a[1].ins.length; j2++)
                    a[1].ins[j2].type = _engine._type;
                  _engine._ins = a[1].ins;
                }
                if (a[1].outs) {
                  for (j2 = 0; j2 < a[1].outs.length; j2++)
                    a[1].outs[j2].type = _engine._type;
                  _engine._outs = a[1].outs;
                }
                _postRefresh();
                for (j2 = 0; j2 < _engine.refreshClients.length; j2++)
                  _engine.refreshClients[j2]._resume();
                _engine.refreshClients = [];
              } else if (a[0] === "version") {
                var plugin = _engine._pool[a[1]];
                if (plugin) {
                  plugin.ready = true;
                  if (plugin.input)
                    plugin.input._start();
                  if (plugin.output)
                    plugin.output._start();
                }
              } else if (a[0] === "openout") {
                impl = _engine._pool[a[1]].output;
                if (impl) {
                  if (a[2] == impl.name) {
                    impl.open = true;
                    if (impl.clients)
                      for (j2 = 0; j2 < impl.clients.length; j2++)
                        impl.clients[j2]._resume();
                  } else if (impl.clients)
                    for (j2 = 0; j2 < impl.clients.length; j2++)
                      impl.clients[j2]._crash();
                }
              } else if (a[0] === "openin") {
                impl = _engine._pool[a[1]].input;
                if (impl) {
                  if (a[2] == impl.name) {
                    impl.open = true;
                    if (impl.clients)
                      for (j2 = 0; j2 < impl.clients.length; j2++)
                        impl.clients[j2]._resume();
                  } else if (impl.clients)
                    for (j2 = 0; j2 < impl.clients.length; j2++)
                      impl.clients[j2]._crash();
                }
              } else if (a[0] === "midi") {
                impl = _engine._pool[a[1]].input;
                if (impl && impl.clients) {
                  for (j2 = 0; j2 < impl.clients.length; j2++) {
                    var msg3 = MIDI2(a.slice(3));
                    impl.clients[j2]._emit(msg3);
                  }
                }
              }
            }
          });
        }
        var JZZ4 = function(opt) {
          if (!_jzz)
            _initJZZ(opt);
          return _jzz._thenable();
        };
        JZZ4.JZZ = JZZ4;
        JZZ4.version = _version;
        JZZ4.info = function() {
          return _J.prototype.info();
        };
        function Widget(arg) {
          var self = new _M();
          if (arg instanceof Object)
            _for(arg, function(k2) {
              self[k2] = arg[k2];
            });
          self._resume();
          return self;
        }
        JZZ4.Widget = Widget;
        _J.prototype.Widget = JZZ4.Widget;
        JZZ4.addMidiIn = function(name2, widget) {
          var info = _clone(widget._info || {});
          info.name = name2;
          info.type = info.type || "javascript";
          info.manufacturer = info.manufacturer || "virtual";
          info.version = info.version || "0.0";
          var engine = {
            _info: function() {
              return info;
            },
            _openIn: function(port) {
              port._pause();
              port._info = _clone(info);
              port._close = function() {
                widget.disconnect(port);
              };
              widget.connect(port);
              port._resume();
            }
          };
          return JZZ4.lib.registerMidiIn(name2, engine);
        };
        JZZ4.addMidiOut = function(name2, widget) {
          var info = _clone(widget._info || {});
          info.name = name2;
          info.type = info.type || "javascript";
          info.manufacturer = info.manufacturer || "virtual";
          info.version = info.version || "0.0";
          var engine = {
            _info: function() {
              return info;
            },
            _openOut: function(port) {
              port._pause();
              port._info = _clone(info);
              port._close = function() {
                port.disconnect();
              };
              _connect.apply(port, [widget]);
              port._resume();
            }
          };
          return JZZ4.lib.registerMidiOut(name2, engine);
        };
        function SMPTE() {
          var self = this instanceof SMPTE ? this : self = new SMPTE();
          SMPTE.prototype.reset.apply(self, arguments);
          return self;
        }
        SMPTE.prototype.reset = function(arg) {
          if (arg instanceof SMPTE) {
            this.setType(arg.getType());
            this.setHour(arg.getHour());
            this.setMinute(arg.getMinute());
            this.setSecond(arg.getSecond());
            this.setFrame(arg.getFrame());
            this.setQuarter(arg.getQuarter());
            return this;
          }
          var arr = arg instanceof Array ? arg : arguments;
          this.setType(arr[0]);
          this.setHour(arr[1]);
          this.setMinute(arr[2]);
          this.setSecond(arr[3]);
          this.setFrame(arr[4]);
          this.setQuarter(arr[5]);
          return this;
        };
        function _fixDropFrame() {
          if (this.type == 29.97 && !this.second && this.frame < 2 && this.minute % 10)
            this.frame = 2;
        }
        SMPTE.prototype.isFullFrame = function() {
          return this.quarter == 0 || this.quarter == 4;
        };
        SMPTE.prototype.getType = function() {
          return this.type;
        };
        SMPTE.prototype.getHour = function() {
          return this.hour;
        };
        SMPTE.prototype.getMinute = function() {
          return this.minute;
        };
        SMPTE.prototype.getSecond = function() {
          return this.second;
        };
        SMPTE.prototype.getFrame = function() {
          return this.frame;
        };
        SMPTE.prototype.getQuarter = function() {
          return this.quarter;
        };
        SMPTE.prototype.setType = function(x) {
          if (typeof x == "undefined" || x == 24)
            this.type = 24;
          else if (x == 25)
            this.type = 25;
          else if (x == 29.97) {
            this.type = 29.97;
            _fixDropFrame.apply(this);
          } else if (x == 30)
            this.type = 30;
          else
            throw RangeError("Bad SMPTE frame rate: " + x);
          if (this.frame >= this.type)
            this.frame = this.type - 1;
          return this;
        };
        SMPTE.prototype.setHour = function(x) {
          if (typeof x == "undefined")
            x = 0;
          if (x != parseInt(x) || x < 0 || x >= 24)
            throw RangeError("Bad SMPTE hours value: " + x);
          this.hour = x;
          return this;
        };
        SMPTE.prototype.setMinute = function(x) {
          if (typeof x == "undefined")
            x = 0;
          if (x != parseInt(x) || x < 0 || x >= 60)
            throw RangeError("Bad SMPTE minutes value: " + x);
          this.minute = x;
          _fixDropFrame.apply(this);
          return this;
        };
        SMPTE.prototype.setSecond = function(x) {
          if (typeof x == "undefined")
            x = 0;
          if (x != parseInt(x) || x < 0 || x >= 60)
            throw RangeError("Bad SMPTE seconds value: " + x);
          this.second = x;
          _fixDropFrame.apply(this);
          return this;
        };
        SMPTE.prototype.setFrame = function(x) {
          if (typeof x == "undefined")
            x = 0;
          if (x != parseInt(x) || x < 0 || x >= this.type)
            throw RangeError("Bad SMPTE frame number: " + x);
          this.frame = x;
          _fixDropFrame.apply(this);
          return this;
        };
        SMPTE.prototype.setQuarter = function(x) {
          if (typeof x == "undefined")
            x = 0;
          if (x != parseInt(x) || x < 0 || x >= 8)
            throw RangeError("Bad SMPTE quarter frame: " + x);
          this.quarter = x;
          return this;
        };
        SMPTE.prototype.incrFrame = function() {
          this.frame++;
          if (this.frame >= this.type) {
            this.frame = 0;
            this.second++;
            if (this.second >= 60) {
              this.second = 0;
              this.minute++;
              if (this.minute >= 60) {
                this.minute = 0;
                this.hour = this.hour >= 23 ? 0 : this.hour + 1;
              }
            }
          }
          _fixDropFrame.apply(this);
          return this;
        };
        SMPTE.prototype.decrFrame = function() {
          if (!this.second && this.frame == 2 && this.type == 29.97 && this.minute % 10)
            this.frame = 0;
          this.frame--;
          if (this.frame < 0) {
            this.frame = this.type == 29.97 ? 29 : this.type - 1;
            this.second--;
            if (this.second < 0) {
              this.second = 59;
              this.minute--;
              if (this.minute < 0) {
                this.minute = 59;
                this.hour = this.hour ? this.hour - 1 : 23;
              }
            }
          }
          return this;
        };
        SMPTE.prototype.incrQF = function() {
          this.backwards = false;
          this.quarter = this.quarter + 1 & 7;
          if (this.quarter == 0 || this.quarter == 4)
            this.incrFrame();
          return this;
        };
        SMPTE.prototype.decrQF = function() {
          this.backwards = true;
          this.quarter = this.quarter + 7 & 7;
          if (this.quarter == 3 || this.quarter == 7)
            this.decrFrame();
          return this;
        };
        function _825(a) {
          return [[24, 25, 29.97, 30][a[7] >> 1 & 3], (a[7] & 1) << 4 | a[6], a[5] << 4 | a[4], a[3] << 4 | a[2], a[1] << 4 | a[0]];
        }
        SMPTE.prototype.read = function(m2) {
          if (!(m2 instanceof MIDI2))
            m2 = MIDI2.apply(null, arguments);
          if (m2[0] == 240 && m2[1] == 127 && m2[3] == 1 && m2[4] == 1 && m2[9] == 247) {
            this.type = [24, 25, 29.97, 30][m2[5] >> 5 & 3];
            this.hour = m2[5] & 31;
            this.minute = m2[6];
            this.second = m2[7];
            this.frame = m2[8];
            this.quarter = 0;
            this._ = void 0;
            this._b = void 0;
            this._f = void 0;
            return true;
          }
          if (m2[0] == 241 && typeof m2[1] != "undefined") {
            var q = m2[1] >> 4;
            var n2 = m2[1] & 15;
            if (q == 0) {
              if (this._ == 7) {
                if (this._f == 7) {
                  this.reset(_825(this._a));
                  this.incrFrame();
                }
                this.incrFrame();
              }
            } else if (q == 3) {
              if (this._ == 4) {
                this.decrFrame();
              }
            } else if (q == 4) {
              if (this._ == 3) {
                this.incrFrame();
              }
            } else if (q == 7) {
              if (this._ === 0) {
                if (this._b === 0) {
                  this.reset(_825(this._a));
                  this.decrFrame();
                }
                this.decrFrame();
              }
            }
            if (!this._a)
              this._a = [];
            this._a[q] = n2;
            this._f = this._f === q - 1 || q == 0 ? q : void 0;
            this._b = this._b === q + 1 || q == 7 ? q : void 0;
            this._ = q;
            this.quarter = q;
            return true;
          }
          return false;
        };
        function _mtc(t) {
          if (!t.backwards && t.quarter >= 4)
            t.decrFrame();
          else if (t.backwards && t.quarter < 4)
            t.incrFrame();
          var ret;
          switch (t.quarter >> 1) {
            case 0:
              ret = t.frame;
              break;
            case 1:
              ret = t.second;
              break;
            case 2:
              ret = t.minute;
              break;
            default:
              ret = t.hour;
          }
          if (t.quarter & 1)
            ret >>= 4;
          else
            ret &= 15;
          if (t.quarter == 7) {
            if (t.type == 25)
              ret |= 2;
            else if (t.type == 29.97)
              ret |= 4;
            else if (t.type == 30)
              ret |= 6;
          }
          if (!t.backwards && t.quarter >= 4)
            t.incrFrame();
          else if (t.backwards && t.quarter < 4)
            t.decrFrame();
          return ret | t.quarter << 4;
        }
        function _hrtype(t) {
          if (t.type == 25)
            return t.hour | 32;
          if (t.type == 29.97)
            return t.hour | 64;
          if (t.type == 30)
            return t.hour | 96;
          return t.hour;
        }
        function _dec(x) {
          return x < 10 ? "0" + x : x;
        }
        function _smptetxt(x) {
          var arr = [];
          for (var i2 = 0; i2 < x.length; i2++)
            arr[i2] = _dec(i2 ? x[i2] : x[i2] & 31);
          return arr.join(":");
        }
        SMPTE.prototype.toString = function() {
          return _smptetxt([this.hour, this.minute, this.second, this.frame]);
        };
        JZZ4.SMPTE = SMPTE;
        _J.prototype.SMPTE = SMPTE;
        function MIDI2(arg) {
          var self = this instanceof MIDI2 ? this : self = new MIDI2();
          var i2;
          if (arg instanceof MIDI2) {
            self._from = arg._from.slice();
            _for(arg, function(i3) {
              if (i3 != "_from")
                self[i3] = arg[i3];
            });
            return self;
          } else
            self._from = [];
          if (typeof arg == "undefined")
            return self;
          var arr = arg instanceof Array ? arg : arguments;
          for (i2 = 0; i2 < arr.length; i2++) {
            n = arr[i2];
            if (i2 == 1) {
              if (self[0] >= 128 && self[0] <= 175)
                n = MIDI2.noteValue(n);
              if (self[0] >= 192 && self[0] <= 207)
                n = MIDI2.programValue(n);
            }
            if (n != parseInt(n) || n < 0 || n > 255)
              _throw(arr[i2]);
            self.push(n);
          }
          return self;
        }
        MIDI2.prototype = [];
        MIDI2.prototype.constructor = MIDI2;
        var _noteNum = {};
        MIDI2.noteValue = function(x) {
          return typeof x == "undefined" ? void 0 : _noteNum[x.toString().toLowerCase()];
        };
        MIDI2.programValue = function(x) {
          return x;
        };
        MIDI2.octaveValue = function(x) {
          var n2 = _noteNum[x.toString().toLowerCase()];
          if (typeof n2 == "undefined")
            n2 = _noteNum[x.toString().toLowerCase() + "1"];
          return typeof n2 == "undefined" ? void 0 : n2 % 12;
        };
        MIDI2.freq = function(n2, a) {
          if (typeof a == "undefined")
            a = 440;
          _float(a);
          if (n2 != parseFloat(n2))
            n2 = _7bn(n2);
          return a * Math.pow(2, (n2 - 69) / 12);
        };
        function _float(x) {
          if (x != parseFloat(x))
            throw TypeError("Not a number: " + x);
        }
        MIDI2.shift = function(f, f0) {
          if (typeof f0 == "undefined")
            f0 = 440;
          _float(f);
          _float(f0);
          return Math.log2(f / f0) * 12;
        };
        MIDI2.midi = function(f, f0) {
          if (f != parseFloat(f))
            return _7bn(f);
          return MIDI2.shift(f, f0) + 69;
        };
        MIDI2.to7b = function(x) {
          _float(x);
          return x <= 0 ? 0 : x >= 1 ? 127 : Math.floor(x * 128);
        };
        MIDI2.to14b = function(x) {
          _float(x);
          return x <= 0 ? 0 : x >= 1 ? 16383 : Math.floor(x * 16384);
        };
        MIDI2.to21b = function(x) {
          if (typeof x == "undefined")
            return 2097151;
          _float(x);
          if (x <= 0)
            return 0;
          x = (Math.floor(x) << 14) + MIDI2.to14b(x - Math.floor(x));
          return x < 2097151 ? x : 2097150;
        };
        function _MIDI() {
        }
        _MIDI.prototype = MIDI2;
        MIDI2._sxid = 127;
        MIDI2.sxId = function(id) {
          if (typeof id == "undefined")
            id = MIDI2._sxid;
          if (id == this._sxid)
            return this;
          id = _7b(id);
          var ret = new _MIDI();
          ret._ch = this._ch;
          ret._sxid = id;
          return ret;
        };
        MIDI2.ch = function(c) {
          if (c == this._ch || typeof c == "undefined" && typeof this._ch == "undefined")
            return this;
          var ret = new _MIDI();
          if (typeof c != "undefined")
            c = _ch(c);
          ret._ch = c;
          ret._sxid = this._sxid;
          return ret;
        };
        var _noteMap = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11, h: 11 };
        _for(_noteMap, function(k2) {
          for (n = 0; n < 12; n++) {
            m = _noteMap[k2] + n * 12;
            if (m > 127)
              break;
            _noteNum[k2 + n] = m;
            _noteNum[k2 + "\u266E" + n] = m;
            if (m > 0) {
              _noteNum[k2 + "b" + n] = m - 1;
              _noteNum[k2 + "\u266D" + n] = m - 1;
              _noteNum[k2 + "bb" + n] = m - 2;
              _noteNum[k2 + "\u266D\u266D" + n] = m - 2;
              _noteNum[k2 + "\u{1D12B}" + n] = m - 2;
            }
            if (m < 127) {
              _noteNum[k2 + "#" + n] = m + 1;
              _noteNum[k2 + "\u266F" + n] = m + 1;
              _noteNum[k2 + "##" + n] = m + 2;
              _noteNum[k2 + "\u266F\u266F" + n] = m + 2;
              _noteNum[k2 + "\u{1D12A}" + n] = m + 2;
            }
          }
        });
        for (n = 0; n < 128; n++)
          _noteNum[n] = n;
        function _throw(x) {
          throw RangeError("Bad MIDI value: " + x);
        }
        function _bad(x) {
          throw TypeError("Invalid value: " + x);
        }
        function _oor(x) {
          throw RangeError("Out of range: " + x);
        }
        function _ch(c) {
          _validateChannel(c);
          return parseInt(c);
        }
        function _7b(n2, m2) {
          if (n2 != parseInt(n2) || n2 < 0 || n2 > 127)
            _throw(typeof m2 == "undefined" ? n2 : m2);
          return parseInt(n2);
        }
        function _8b(n2) {
          if (n2 != parseInt(n2) || n2 < 0 || n2 > 255)
            _throw(n2);
          return parseInt(n2);
        }
        function _14b(n2) {
          if (n2 != parseInt(n2) || n2 < 0 || n2 > 16383)
            _throw(n2);
          return parseInt(n2);
        }
        function _16b(n2) {
          if (n2 != parseInt(n2) || n2 < 0 || n2 > 65535)
            throw RangeError("Expected a 16-bit value: " + n2);
          return parseInt(n2);
        }
        function _21b(n2) {
          if (n2 != parseInt(n2) || n2 < 0 || n2 > 2097151)
            _throw(n2);
          return parseInt(n2);
        }
        function _7bn(n2) {
          return _7b(MIDI2.noteValue(n2), n2);
        }
        function _lsb(n2) {
          return _14b(n2) & 127;
        }
        function _msb(n2) {
          return _14b(n2) >> 7;
        }
        function _8bs(s) {
          s = "" + s;
          for (var i2 = 0; i2 < s.length; i2++)
            if (s.charCodeAt(i2) > 255)
              _throw(s[i2]);
          return s;
        }
        function _to777(n2) {
          return [n2 >> 14, n2 >> 7 & 127, n2 & 127];
        }
        function _01(x, y) {
          if (x != parseFloat(x))
            _bad(typeof y == "undefined" ? x : y);
          if (x < 0 || x > 1)
            _oor(typeof y == "undefined" ? x : y);
          return parseFloat(x);
        }
        function _rt(b) {
          return typeof b != "undefined" && !b ? 126 : 127;
        }
        function _ntu(x) {
          var k2, m2;
          var kkk = [];
          var vvv = {};
          _for(x, function(k3) {
            m2 = _21b(x[k3]);
            k3 = _7bn(k3);
            if (k3 in vvv)
              throw RangeError("Duplicate MIDI value: " + k3);
            kkk.push(k3);
            vvv[k3] = m2;
          });
          kkk.sort();
          var out = [kkk.length];
          for (k2 = 0; k2 < kkk.length; k2++)
            out = out.concat([kkk[k2]], _to777(vvv[kkk[k2]]));
          return out;
        }
        function _f2ntu(x) {
          var out = {};
          _for(x, function(k2) {
            out[k2] = MIDI2.to21b(x[k2] == parseFloat(x[k2]) ? x[k2] : _7bn(x[k2]));
          });
          return out;
        }
        function _hz2ntu(x) {
          var out = {};
          _for(x, function(k2) {
            out[k2] = MIDI2.to21b(MIDI2.midi(x[k2]));
          });
          return out;
        }
        function _12x7(a) {
          var out = [];
          if (!(a instanceof Array) || a.length != 12)
            throw TypeError("Expected an array of size 12");
          for (var i2 = 0; i2 < 12; i2++)
            out.push(_7b(a[i2]));
          return out;
        }
        function _12x14(a) {
          var out = [];
          if (!(a instanceof Array) || a.length != 12)
            throw TypeError("Expected an array of size 12");
          for (var i2 = 0; i2 < 12; i2++) {
            out.push(_msb(a[i2]));
            out.push(_lsb(a[i2]));
          }
          return out;
        }
        var _helperMPE = {
          noteOff: function(c, n2, v) {
            if (typeof v == "undefined")
              v = 64;
            return [128 + _ch(c), _7bn(n2), _7b(v)];
          },
          noteOn: function(c, n2, v) {
            if (typeof v == "undefined")
              v = 127;
            return [144 + _ch(c), _7bn(n2), _7b(v)];
          },
          aftertouch: function(c, n2, v) {
            return [160 + _ch(c), _7bn(n2), _7b(v)];
          }
        };
        var _helperCH = {
          control: function(c, n2, v) {
            return [176 + _ch(c), _7b(n2), _7b(v)];
          },
          program: function(c, n2) {
            return [192 + _ch(c), _7b(MIDI2.programValue(n2), n2)];
          },
          pressure: function(c, n2) {
            return [208 + _ch(c), _7b(n2)];
          },
          pitchBend: function(c, n2, l) {
            return typeof l == "undefined" ? [224 + _ch(c), _lsb(n2), _msb(n2)] : [224 + _ch(c), _7b(l), _7b(n2)];
          },
          pitchBendF: function(c, x) {
            return _helperCH.pitchBend(c, MIDI2.to14b((x + 1) / 2));
          },
          bankMSB: function(c, n2) {
            return [176 + _ch(c), 0, _7b(n2)];
          },
          bankLSB: function(c, n2) {
            return [176 + _ch(c), 32, _7b(n2)];
          },
          modMSB: function(c, n2) {
            return [176 + _ch(c), 1, _7b(n2)];
          },
          modLSB: function(c, n2) {
            return [176 + _ch(c), 33, _7b(n2)];
          },
          breathMSB: function(c, n2) {
            return [176 + _ch(c), 2, _7b(n2)];
          },
          breathLSB: function(c, n2) {
            return [176 + _ch(c), 34, _7b(n2)];
          },
          footMSB: function(c, n2) {
            return [176 + _ch(c), 4, _7b(n2)];
          },
          footLSB: function(c, n2) {
            return [176 + _ch(c), 36, _7b(n2)];
          },
          portamentoMSB: function(c, n2) {
            return [176 + _ch(c), 5, _7b(n2)];
          },
          portamentoLSB: function(c, n2) {
            return [176 + _ch(c), 37, _7b(n2)];
          },
          dataMSB: function(c, n2) {
            return [176 + _ch(c), 6, _7b(n2)];
          },
          dataLSB: function(c, n2) {
            return [176 + _ch(c), 38, _7b(n2)];
          },
          volumeMSB: function(c, n2) {
            return [176 + _ch(c), 7, _7b(n2)];
          },
          volumeLSB: function(c, n2) {
            return [176 + _ch(c), 39, _7b(n2)];
          },
          balanceMSB: function(c, n2) {
            return [176 + _ch(c), 8, _7b(n2)];
          },
          balanceLSB: function(c, n2) {
            return [176 + _ch(c), 40, _7b(n2)];
          },
          panMSB: function(c, n2) {
            return [176 + _ch(c), 10, _7b(n2)];
          },
          panLSB: function(c, n2) {
            return [176 + _ch(c), 42, _7b(n2)];
          },
          expressionMSB: function(c, n2) {
            return [176 + _ch(c), 11, _7b(n2)];
          },
          expressionLSB: function(c, n2) {
            return [176 + _ch(c), 43, _7b(n2)];
          },
          damper: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 64, b ? 127 : 0];
          },
          portamento: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 65, b ? 127 : 0];
          },
          sostenuto: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 66, b ? 127 : 0];
          },
          soft: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 67, b ? 127 : 0];
          },
          legato: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 68, b ? 127 : 0];
          },
          hold2: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 69, b ? 127 : 0];
          },
          soundVariation: function(c, n2) {
            return [176 + _ch(c), 70, _7bn(n2)];
          },
          filterResonance: function(c, n2) {
            return [176 + _ch(c), 71, _7bn(n2)];
          },
          releaseTime: function(c, n2) {
            return [176 + _ch(c), 72, _7bn(n2)];
          },
          attackTime: function(c, n2) {
            return [176 + _ch(c), 73, _7bn(n2)];
          },
          brightness: function(c, n2) {
            return [176 + _ch(c), 74, _7bn(n2)];
          },
          decayTime: function(c, n2) {
            return [176 + _ch(c), 75, _7bn(n2)];
          },
          vibratoRate: function(c, n2) {
            return [176 + _ch(c), 76, _7bn(n2)];
          },
          vibratoDepth: function(c, n2) {
            return [176 + _ch(c), 77, _7bn(n2)];
          },
          vibratoDelay: function(c, n2) {
            return [176 + _ch(c), 78, _7bn(n2)];
          },
          ptc: function(c, n2) {
            return [176 + _ch(c), 84, _7bn(n2)];
          },
          dataIncr: function(c) {
            return [176 + _ch(c), 96, 0];
          },
          dataDecr: function(c) {
            return [176 + _ch(c), 97, 0];
          },
          nrpnLSB: function(c, n2) {
            return [176 + _ch(c), 98, _7b(n2)];
          },
          nrpnMSB: function(c, n2) {
            return [176 + _ch(c), 99, _7b(n2)];
          },
          rpnLSB: function(c, n2) {
            return [176 + _ch(c), 100, _7b(n2)];
          },
          rpnMSB: function(c, n2) {
            return [176 + _ch(c), 101, _7b(n2)];
          },
          allSoundOff: function(c) {
            return [176 + _ch(c), 120, 0];
          },
          resetAllControllers: function(c) {
            return [176 + _ch(c), 121, 0];
          },
          localControl: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), 122, b ? 127 : 0];
          },
          allNotesOff: function(c) {
            return [176 + _ch(c), 123, 0];
          },
          omni: function(c, b) {
            if (typeof b == "undefined")
              b = true;
            return [176 + _ch(c), b ? 125 : 124, 0];
          },
          mono: function(c, n2) {
            if (typeof n2 == "undefined")
              n2 = 1;
            return [176 + _ch(c), 126, _7b(n2)];
          },
          poly: function(c) {
            return [176 + _ch(c), 127, 0];
          }
        };
        function _splitMasterTuning(a, b, c, d) {
          if (typeof b != "undefined")
            return [_7b(a), _7b(b), _7b(c), _7b(d)];
          if (a != parseInt(a) || a < 0 || n > 65535)
            _bad(a);
          a = parseInt(a);
          return [a >> 12 & 15, a >> 8 & 15, a >> 4 & 15, a & 15];
        }
        function _gsxg12b(x) {
          _float(x);
          return Math.round(x * 1e3 + 1024);
        }
        var _helperNC = {
          mtc: function(t) {
            return [241, _mtc(t)];
          },
          songPosition: function(n2, l) {
            return typeof l == "undefined" ? [242, _lsb(n2), _msb(n2)] : [242, _7b(l), _7b(n2)];
          },
          songSelect: function(n2) {
            return [243, _7b(n2)];
          },
          tune: function() {
            return [246];
          },
          clock: function() {
            return [248];
          },
          start: function() {
            return [250];
          },
          continue: function() {
            return [251];
          },
          stop: function() {
            return [252];
          },
          active: function() {
            return [254];
          },
          sxIdRequest: function() {
            return [240, 126, this._sxid, 6, 1, 247];
          },
          sxTuningDumpRequest: function(n2, k2) {
            return typeof k2 == "undefined" ? [240, 126, this._sxid, 8, 0, _7b(n2), 247] : [240, 126, this._sxid, 8, 3, _7b(n2), _7b(k2), 247];
          },
          sxFullFrame: function(t) {
            return [240, 127, this._sxid, 1, 1, _hrtype(t), t.getMinute(), t.getSecond(), t.getFrame(), 247];
          },
          sxMasterVolume: function(n2, l) {
            return typeof l == "undefined" ? [240, 127, this._sxid, 4, 1, _lsb(n2), _msb(n2), 247] : [240, 127, this._sxid, 4, 1, _7b(l), _7b(n2), 247];
          },
          sxMasterVolumeF: function(x) {
            return _helperNC.sxMasterVolume.call(this, MIDI2.to14b(_01(x)));
          },
          sxMasterFineTuning: function(n2, l) {
            return typeof l == "undefined" ? [240, 127, this._sxid, 4, 3, _lsb(n2), _msb(n2), 247] : [240, 127, this._sxid, 4, 3, _7b(l), _7b(n2), 247];
          },
          sxMasterFineTuningF: function(x) {
            return _helperNC.sxMasterFineTuning.call(this, MIDI2.to14b(_01((x % 1 + 1) / 2, x)));
          },
          sxMasterCoarseTuning: function(n2) {
            return [240, 127, this._sxid, 4, 4, 0, _7b(n2), 247];
          },
          sxMasterCoarseTuningF: function(x) {
            return _helperNC.sxMasterCoarseTuning.call(this, 64 + (x - x % 1));
          },
          sxNoteTuning: function(a, b, c, d) {
            return b == parseInt(b) ? [240, _rt(d), this._sxid, 8, 7, _7b(a), _7b(b)].concat(_ntu(c), [247]) : [240, 127, this._sxid, 8, 2, _7b(a)].concat(_ntu(b), [247]);
          },
          sxNoteTuningF: function(a, b, c, d) {
            return b == parseInt(b) ? _helperNC.sxNoteTuning.call(this, a, b, _f2ntu(c), d) : _helperNC.sxNoteTuning.call(this, a, _f2ntu(b));
          },
          sxNoteTuningHZ: function(a, b, c, d) {
            return b == parseInt(b) ? _helperNC.sxNoteTuning.call(this, a, b, _hz2ntu(c), d) : _helperNC.sxNoteTuning.call(this, a, _hz2ntu(b));
          },
          sxScaleTuning1: function(a, b, c) {
            return a == parseInt(a) ? [240, _rt(c), this._sxid, 8, 8].concat(_to777(_16b(a)), _12x7(b), [247]) : _helperNC.sxScaleTuning1.call(this, 65535, a, b);
          },
          sxScaleTuning1F: function(a, b, c) {
            if (a != parseInt(a))
              return _helperNC.sxScaleTuning1F.call(this, 65535, a, b);
            var v = [];
            for (var i2 = 0; i2 < b.length; i2++) {
              if (b[i2] < -0.64 || b[i2] > 0.63)
                throw RangeError("Out of range: " + b[i2]);
              v.push(Math.floor(b[i2] * 100 + 64));
            }
            return _helperNC.sxScaleTuning1.call(this, a, v, c);
          },
          sxScaleTuning2: function(a, b, c) {
            return a == parseInt(a) ? [240, _rt(c), this._sxid, 8, 9].concat(_to777(_16b(a)), _12x14(b), [247]) : _helperNC.sxScaleTuning2.call(this, 65535, a, b);
          },
          sxScaleTuning2F: function(a, b, c) {
            if (a != parseInt(a))
              return _helperNC.sxScaleTuning2F.call(this, 65535, a, b);
            var v = [];
            for (var i2 = 0; i2 < b.length; i2++) {
              var x = (b[i2] + 1) / 2;
              if (x < -1 || x > 1)
                throw RangeError("Out of range: " + b[i2]);
              v.push(MIDI2.to14b((b[i2] + 1) / 2));
            }
            return _helperNC.sxScaleTuning2.call(this, a, v, c);
          },
          sxGM: function(gm) {
            if (typeof gm == "undefined")
              gm = 1;
            return [240, 126, this._sxid, 9, gm ? gm == 2 ? 3 : 1 : 2, 247];
          },
          sxGS: function(arg) {
            var arr = typeof arg == "undefined" ? [64, 0, 127, 0] : arg instanceof Array ? arg : arguments;
            var c = 0;
            var a = [240, 65, this._sxid, 66, 18];
            for (var i2 = 0; i2 < arr.length; i2++) {
              var x = _7b(arr[i2]);
              a.push(x);
              c += x;
            }
            c %= 128;
            a.push(c ? 128 - c : 0);
            a.push(247);
            return a;
          },
          sxXG: function(arg) {
            var arr = typeof arg == "undefined" ? [0, 0, 126, 0] : arg instanceof Array ? arg : arguments;
            var sxid = this._sxid == 127 ? 0 : this._sxid;
            if (sxid > 15)
              _throw("Bad Yamaha device number: " + sxid);
            var a = [240, 67, 16 + sxid, 76];
            for (var i2 = 0; i2 < arr.length; i2++)
              a.push(_7b(arr[i2]));
            a.push(247);
            return a;
          },
          sxMidiSoft: function(n2, s) {
            var a = [240, 0, 32, 36, 0, _7b(n2 || 0)];
            s = typeof s == "undefined" ? "" : "" + s;
            for (var i2 = 0; i2 < s.length; i2++)
              a.push(_7b(s.charCodeAt(i2)));
            a.push(247);
            return a;
          },
          gsMasterVolume: function(n2) {
            return _helperNC.sxGS.call(this, [64, 0, 4, _7b(n2)]);
          },
          gsMasterVolumeF: function(x) {
            return _helperNC.gsMasterVolume.call(this, MIDI2.to7b(_01(x)));
          },
          gsMasterFineTuning: function(a, b, c, d) {
            a = _splitMasterTuning(a, b, c, d);
            return _helperNC.sxGS.call(this, [64, 0, 0, a[0], a[1], a[2], a[3]]);
          },
          gsMasterFineTuningF: function(x) {
            return _helperNC.gsMasterFineTuning.call(this, _gsxg12b(x % 1));
          },
          gsMasterCoarseTuning: function(n2) {
            return _helperNC.sxGS.call(this, [64, 0, 5, _7b(n2)]);
          },
          gsMasterCoarseTuningF: function(x) {
            return _helperNC.gsMasterCoarseTuning.call(this, 64 + (x - x % 1));
          },
          gsOctaveTuning: function(c, n2, x) {
            return _helperNC.sxGS.call(this, [64, 16 + [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15][_ch(c)], 64 + MIDI2.octaveValue(n2), _7b(x)]);
          },
          gsOctaveTuningF: function(c, n2, x) {
            if (x < -0.64 || x > 0.63)
              throw RangeError("Out of range: " + x);
            return _helperNC.gsOctaveTuning.call(this, c, n2, Math.floor(x * 100 + 64));
          },
          xgMasterVolume: function(n2) {
            return _helperNC.sxXG.call(this, [0, 0, 4, _7b(n2)]);
          },
          xgMasterVolumeF: function(x) {
            return _helperNC.xgMasterVolume.call(this, MIDI2.to7b(_01(x)));
          },
          xgMasterFineTuning: function(a, b, c, d) {
            a = _splitMasterTuning(a, b, c, d);
            return _helperNC.sxXG.call(this, [0, 0, 0, a[0], a[1], a[2], a[3]]);
          },
          xgMasterFineTuningF: function(x) {
            return _helperNC.xgMasterFineTuning.call(this, _gsxg12b(x % 1));
          },
          xgMasterCoarseTuning: function(n2) {
            return _helperNC.sxXG.call(this, [0, 0, 6, _7b(n2)]);
          },
          xgMasterCoarseTuningF: function(x) {
            return _helperNC.xgMasterCoarseTuning.call(this, 64 + (x - x % 1));
          },
          xgOctaveTuning: function(c, n2, x) {
            return _helperNC.sxXG.call(this, [8, _ch(c), 65 + MIDI2.octaveValue(n2), _7b(x)]);
          },
          xgOctaveTuningF: function(c, n2, x) {
            if (x < -0.64 || x > 0.63)
              throw RangeError("Out of range: " + x);
            return _helperNC.xgOctaveTuning.call(this, c, n2, Math.floor(x * 100 + 64));
          },
          reset: function() {
            return [255];
          }
        };
        _helperNC.sxScaleTuning = _helperNC.sxScaleTuning2;
        _helperNC.sxScaleTuningF = _helperNC.sxScaleTuning2F;
        _helperNC.sxMasterTranspose = _helperNC.sxMasterCoarseTuning;
        _helperNC.sxMasterTransposeF = _helperNC.sxMasterCoarseTuningF;
        _helperNC.gsMasterTranspose = _helperNC.gsMasterCoarseTuning;
        _helperNC.gsMasterTransposeF = _helperNC.gsMasterCoarseTuningF;
        _helperNC.xgMasterTranspose = _helperNC.xgMasterCoarseTuning;
        _helperNC.xgMasterTransposeF = _helperNC.xgMasterCoarseTuningF;
        var _helperGCH = {
          bank: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.bankMSB(c, _msb(m2)), _helperCH.bankLSB(c, _lsb(m2))] : [_helperCH.bankMSB(c, m2), _helperCH.bankLSB(c, l)];
          },
          modF: function(c, x) {
            return _helperGCH.mod(c, MIDI2.to14b(x));
          },
          mod: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.modMSB(c, _msb(m2)), _helperCH.modLSB(c, _lsb(m2))] : [_helperCH.modMSB(c, m2), _helperCH.modLSB(c, l)];
          },
          breathF: function(c, x) {
            return _helperGCH.breath(c, MIDI2.to14b(x));
          },
          breath: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.breathMSB(c, _msb(m2)), _helperCH.breathLSB(c, _lsb(m2))] : [_helperCH.breathMSB(c, m2), _helperCH.breathLSB(c, l)];
          },
          footF: function(c, x) {
            return _helperGCH.foot(c, MIDI2.to14b(x));
          },
          foot: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.footMSB(c, _msb(m2)), _helperCH.footLSB(c, _lsb(m2))] : [_helperCH.footMSB(c, m2), _helperCH.footLSB(c, l)];
          },
          portamentoTimeF: function(c, x) {
            return _helperGCH.portamentoTime(c, MIDI2.to14b(x));
          },
          portamentoTime: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.portamentoMSB(c, _msb(m2)), _helperCH.portamentoLSB(c, _lsb(m2))] : [_helperCH.portamentoMSB(c, m2), _helperCH.portamentoLSB(c, l)];
          },
          dataF: function(c, x) {
            return _helperGCH.data(c, MIDI2.to14b(x));
          },
          data: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.dataMSB(c, _msb(m2)), _helperCH.dataLSB(c, _lsb(m2))] : [_helperCH.dataMSB(c, m2), _helperCH.dataLSB(c, l)];
          },
          volumeF: function(c, x) {
            return _helperGCH.volume(c, MIDI2.to14b(x));
          },
          volume: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.volumeMSB(c, _msb(m2)), _helperCH.volumeLSB(c, _lsb(m2))] : [_helperCH.volumeMSB(c, m2), _helperCH.volumeLSB(c, l)];
          },
          balanceF: function(c, x) {
            return _helperGCH.balance(c, MIDI2.to14b((x + 1) / 2));
          },
          balance: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.balanceMSB(c, _msb(m2)), _helperCH.balanceLSB(c, _lsb(m2))] : [_helperCH.balanceMSB(c, m2), _helperCH.balanceLSB(c, l)];
          },
          panF: function(c, x) {
            return _helperGCH.pan(c, MIDI2.to14b((x + 1) / 2));
          },
          pan: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.panMSB(c, _msb(m2)), _helperCH.panLSB(c, _lsb(m2))] : [_helperCH.panMSB(c, m2), _helperCH.panLSB(c, l)];
          },
          expressionF: function(c, x) {
            return _helperGCH.expression(c, MIDI2.to14b(x));
          },
          expression: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.expressionMSB(c, _msb(m2)), _helperCH.expressionLSB(c, _lsb(m2))] : [_helperCH.expressionMSB(c, m2), _helperCH.expressionLSB(c, l)];
          },
          nrpn: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.nrpnMSB(c, _msb(m2)), _helperCH.nrpnLSB(c, _lsb(m2))] : [_helperCH.nrpnMSB(c, m2), _helperCH.nrpnLSB(c, l)];
          },
          rpn: function(c, m2, l) {
            return typeof l == "undefined" ? [_helperCH.rpnMSB(c, _msb(m2)), _helperCH.rpnLSB(c, _lsb(m2))] : [_helperCH.rpnMSB(c, m2), _helperCH.rpnLSB(c, l)];
          },
          rpnPitchBendRange: function(c, m2, l) {
            return _helperGCH.rpn(c, 0, 0).concat(_helperGCH.data(c, m2, l));
          },
          rpnPitchBendRangeF: function(c, x) {
            return _helperGCH.rpnPitchBendRange(c, _7b(x - x % 1), Math.floor(x % 1 * 100));
          },
          rpnFineTuning: function(c, m2, l) {
            return _helperGCH.rpn(c, 0, 1).concat(_helperGCH.data(c, m2, l));
          },
          rpnFineTuningF: function(c, x) {
            return _helperGCH.rpn(c, 0, 1).concat(_helperGCH.dataF(c, (x % 1 + 1) / 2));
          },
          rpnCoarseTuning: function(c, m2) {
            return _helperGCH.rpn(c, 0, 2).concat([_helperCH.dataMSB(c, m2)]);
          },
          rpnCoarseTuningF: function(c, x) {
            return _helperGCH.rpn(c, 0, 2).concat([_helperCH.dataMSB(c, 64 + (x - x % 1))]);
          },
          rpnTuning: function(c, n2, m2, l) {
            return _helperGCH.rpnCoarseTuning(c, n2).concat(_helperGCH.rpnFineTuning(c, m2, l));
          },
          rpnTuningF: function(c, x) {
            return _helperGCH.rpnCoarseTuningF(c, x).concat(_helperGCH.rpnFineTuningF(c, x));
          },
          rpnTuningA: function(c, a) {
            return _helperGCH.rpnTuningF(c, MIDI2.shift(a));
          },
          rpnSelectTuningProgram: function(c, n2) {
            return _helperGCH.rpn(c, 0, 3).concat([_helperCH.dataMSB(c, n2)]);
          },
          rpnSelectTuningBank: function(c, n2) {
            return _helperGCH.rpn(c, 0, 4).concat([_helperCH.dataMSB(c, n2)]);
          },
          rpnSelectTuning: function(c, n2, k2) {
            return typeof k2 == "undefined" ? _helperGCH.rpnSelectTuningProgram(c, n2) : _helperGCH.rpnSelectTuningBank(c, n2).concat(_helperGCH.rpnSelectTuningProgram(c, k2));
          },
          rpnModulationDepthRange: function(c, m2, l) {
            return _helperGCH.rpn(c, 0, 5).concat(_helperGCH.data(c, m2, l));
          },
          rpnModulationDepthRangeF: function(c, x) {
            return _helperGCH.rpnModulationDepthRange(c, _7b(x - x % 1), Math.floor(x % 1 * 128));
          },
          rpnNull: function(c) {
            return _helperGCH.rpn(c, 127, 127);
          },
          mode1: function(c) {
            return [_helperCH.omni(c, true), _helperCH.poly(c)];
          },
          mode2: function(c) {
            return [_helperCH.omni(c, true), _helperCH.mono(c)];
          },
          mode3: function(c) {
            return [_helperCH.omni(c, false), _helperCH.poly(c)];
          },
          mode4: function(c) {
            return [_helperCH.omni(c, false), _helperCH.mono(c)];
          }
        };
        var _helperGNC = {
          sxMasterTuning: function(n2, m2, l) {
            return [_helperNC.sxMasterCoarseTuning.call(this, n2), _helperNC.sxMasterFineTuning.call(this, m2, l)];
          },
          sxMasterTuningF: function(x) {
            return [_helperNC.sxMasterCoarseTuningF.call(this, x), _helperNC.sxMasterFineTuningF.call(this, x)];
          },
          gsMasterTuningF: function(x) {
            return [_helperNC.gsMasterCoarseTuningF.call(this, x), _helperNC.gsMasterFineTuningF.call(this, x)];
          },
          xgMasterTuningF: function(x) {
            return [_helperNC.xgMasterCoarseTuningF.call(this, x), _helperNC.xgMasterFineTuningF.call(this, x)];
          },
          sxMasterTuningA: function(a) {
            return _helperGNC.sxMasterTuningF.call(this, MIDI2.shift(a));
          },
          gsMasterTuningA: function(a) {
            return _helperGNC.gsMasterTuningF.call(this, MIDI2.shift(a));
          },
          xgMasterTuningA: function(a) {
            return _helperGNC.xgMasterTuningF.call(this, MIDI2.shift(a));
          },
          gsScaleTuning: function(c, a) {
            var out = [];
            if (a.length != 12)
              throw RangeError("Wrong input size: " + a.length);
            for (var i2 = 0; i2 < 12; i2++)
              out.push(_helperNC.gsOctaveTuning.call(this, c, i2, a[i2]));
            return out;
          },
          gsScaleTuningF: function(c, a) {
            var out = [];
            if (a.length != 12)
              throw RangeError("Wrong input size: " + a.length);
            for (var i2 = 0; i2 < 12; i2++)
              out.push(_helperNC.gsOctaveTuningF.call(this, c, i2, a[i2]));
            return out;
          },
          xgScaleTuning: function(c, a) {
            var out = [];
            if (a.length != 12)
              throw RangeError("Wrong input size: " + a.length);
            for (var i2 = 0; i2 < 12; i2++)
              out.push(_helperNC.xgOctaveTuning.call(this, c, i2, a[i2]));
            return out;
          },
          xgScaleTuningF: function(c, a) {
            var out = [];
            if (a.length != 12)
              throw RangeError("Wrong input size: " + a.length);
            for (var i2 = 0; i2 < 12; i2++)
              out.push(_helperNC.xgOctaveTuningF.call(this, c, i2, a[i2]));
            return out;
          }
        };
        function _smf(ff, dd) {
          var midi = new MIDI2();
          midi.ff = _8b(ff);
          midi.dd = typeof dd == "undefined" ? "" : _8bs(dd);
          return midi;
        }
        var _helperSMF = {
          smf: function(arg) {
            if (arg instanceof MIDI2)
              return new MIDI2(arg);
            var arr = arg instanceof Array ? arg : arguments;
            var ff = _8b(arr[0]);
            var dd = "";
            if (arr.length == 2)
              dd = _2s(arr[1]);
            else if (arr.length > 2)
              dd = _2s(Array.prototype.slice.call(arr, 1));
            return _smf(ff, dd);
          },
          smfSeqNumber: function(dd) {
            if (dd == parseInt(dd)) {
              if (dd < 0 || dd > 65535)
                throw RangeError("Sequence number out of range: " + dd);
              dd = String.fromCharCode(dd >> 8) + String.fromCharCode(dd & 255);
            } else {
              dd = "" + dd;
              if (dd.length == 0)
                dd = "\0\0";
              else if (dd.length == 1)
                dd = "\0" + dd;
              else if (dd.length > 2)
                throw RangeError("Sequence number out of range" + _smftxt(dd));
            }
            return _smf(0, dd);
          },
          smfText: function(dd) {
            return _smf(1, JZZ4.lib.toUTF8(dd));
          },
          smfCopyright: function(dd) {
            return _smf(2, JZZ4.lib.toUTF8(dd));
          },
          smfSeqName: function(dd) {
            return _smf(3, JZZ4.lib.toUTF8(dd));
          },
          smfInstrName: function(dd) {
            return _smf(4, JZZ4.lib.toUTF8(dd));
          },
          smfLyric: function(dd) {
            return _smf(5, JZZ4.lib.toUTF8(dd));
          },
          smfMarker: function(dd) {
            return _smf(6, JZZ4.lib.toUTF8(dd));
          },
          smfCuePoint: function(dd) {
            return _smf(7, JZZ4.lib.toUTF8(dd));
          },
          smfProgName: function(dd) {
            return _smf(8, JZZ4.lib.toUTF8(dd));
          },
          smfDevName: function(dd) {
            return _smf(9, JZZ4.lib.toUTF8(dd));
          },
          smfChannelPrefix: function(dd) {
            if (dd == parseInt(dd)) {
              _validateChannel(dd);
              dd = String.fromCharCode(dd);
            } else {
              dd = "" + dd;
              if (dd.length == 0)
                dd = "\0";
              else if (dd.length > 1 || dd.charCodeAt(0) > 15)
                throw RangeError("Channel number out of range" + _smftxt(dd));
            }
            return _smf(32, dd);
          },
          smfMidiPort: function(dd) {
            if (dd == parseInt(dd)) {
              if (dd < 0 || dd > 127)
                throw RangeError("Port number out of range: " + dd);
              dd = String.fromCharCode(dd);
            } else {
              dd = "" + dd;
              if (dd.length == 0)
                dd = "\0";
              else if (dd.length > 1 || dd.charCodeAt(0) > 127)
                throw RangeError("Port number out of range" + _smftxt(dd));
            }
            return _smf(33, dd);
          },
          smfEndOfTrack: function(dd) {
            if (_2s(dd) != "")
              throw RangeError("Unexpected data" + _smftxt(_2s(dd)));
            return _smf(47);
          },
          smfTempo: function(dd) {
            if (("" + dd).length == 3)
              return _smf(81, dd);
            if (dd == parseInt(dd) && dd > 0 && dd <= 16777215) {
              return _smf(81, String.fromCharCode(dd >> 16) + String.fromCharCode(dd >> 8 & 255) + String.fromCharCode(dd & 255));
            }
            throw RangeError("Out of range" + _smftxt(_2s(dd)));
          },
          smfBPM: function(bpm) {
            return _helperSMF.smfTempo(Math.round(6e7 / bpm));
          },
          smfSMPTE: function(dd) {
            if (dd instanceof SMPTE)
              return _smf(84, String.fromCharCode(dd.hour) + String.fromCharCode(dd.minute) + String.fromCharCode(dd.second) + String.fromCharCode(dd.frame) + String.fromCharCode(dd.quarter % 4 * 25));
            var s = "" + dd;
            if (s.length == 5) {
              return _smf(84, dd);
            }
            var arr = dd instanceof Array ? dd : Array.prototype.slice.call(arguments);
            arr.splice(0, 0, 30);
            return _helperSMF.smfSMPTE(new SMPTE(arr));
          },
          smfTimeSignature: function(a, b, c, d) {
            var nn, dd, cc, bb;
            var m2 = ("" + a).match(/^\s*(\d+)\s*\/\s*(\d+)\s*$/);
            if (m2) {
              nn = parseInt(m2[1]);
              dd = parseInt(m2[2]);
              if (nn > 0 && nn < 256 && dd > 0 && !(dd & dd - 1)) {
                cc = dd;
                dd = 0;
                for (cc >>= 1; cc; cc >>= 1)
                  dd++;
                cc = b == parseInt(b) ? b : 24;
                bb = c == parseInt(c) ? c : 8;
                return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));
              } else if (("" + a).length == 4)
                return _smf(88, a);
            } else if (a == parseInt(a) && b == parseInt(b)) {
              if (a > 0 && a < 256 && b > 0 && !(b & b - 1)) {
                nn = a;
                dd = 0;
                cc = b;
                for (cc >>= 1; cc; cc >>= 1)
                  dd++;
                cc = c == parseInt(c) ? c : 24;
                bb = d == parseInt(d) ? d : 8;
                return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));
              } else if (("" + a).length == 4)
                return _smf(88, a);
              a = a + "/" + b;
            } else if (("" + a).length == 4)
              return _smf(88, a);
            throw RangeError("Wrong time signature" + _smftxt(_2s("" + a)));
          },
          smfKeySignature: function(dd) {
            dd = "" + dd;
            var m2 = dd.match(/^\s*([A-H][b#]?)\s*(|maj|major|dur|m|min|minor|moll)\s*$/i);
            if (m2) {
              var sf = {
                CB: 0,
                GB: 1,
                DB: 2,
                AB: 3,
                EB: 4,
                BB: 5,
                F: 6,
                C: 7,
                G: 8,
                D: 9,
                A: 10,
                E: 11,
                B: 12,
                H: 12,
                "F#": 13,
                "C#": 14,
                "G#": 15,
                "D#": 16,
                "A#": 17
              }[m2[1].toUpperCase()];
              var mi = { "": 0, MAJ: 0, MAJOR: 0, DUR: 0, M: 1, MIN: 1, MINOR: 1, MOLL: 1 }[m2[2].toUpperCase()];
              if (typeof sf != "undefined" && typeof mi != "undefined") {
                if (mi)
                  sf -= 3;
                sf -= 7;
                if (sf >= -7 && sf < 0)
                  dd = String.fromCharCode(256 + sf) + String.fromCharCode(mi);
                else if (sf >= 0 && sf <= 7)
                  dd = String.fromCharCode(sf) + String.fromCharCode(mi);
              }
            }
            if (dd.length == 2 && dd.charCodeAt(1) <= 1 && (dd.charCodeAt(0) <= 7 || dd.charCodeAt(0) <= 255 && dd.charCodeAt(0) >= 249))
              return _smf(89, dd);
            throw RangeError("Incorrect key signature" + _smftxt(dd));
          },
          smfSequencer: function(dd) {
            return _smf(127, _2s(dd));
          }
        };
        var _helpers = {};
        function _copyHelperNC(name2, func) {
          MIDI2[name2] = function() {
            return new MIDI2(func.apply(this, arguments));
          };
          _helpers[name2] = function() {
            return this.send(func.apply(this, arguments));
          };
        }
        function _copyHelperSMF(name2, func) {
          MIDI2[name2] = function() {
            return func.apply(this, arguments);
          };
          _helpers[name2] = function() {
            return this.send(func.apply(this, arguments));
          };
        }
        function _copyHelperGNC(name2, func) {
          MIDI2[name2] = function() {
            var i2;
            var g = [];
            var a = func.apply(this, arguments);
            for (i2 = 0; i2 < a.length; i2++)
              g.push(new MIDI2(a[i2]));
            return g;
          };
          _helpers[name2] = function() {
            var a = func.apply(this, arguments);
            var g = this;
            for (var i2 = 0; i2 < a.length; i2++)
              g = g.send(a[i2]);
            return g;
          };
        }
        function _copyHelperMPE(name2, func) {
          MIDI2[name2] = function() {
            return new MIDI2(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
          };
          _helpers[name2] = function() {
            if (typeof this._master != "undefined") {
              var msg2 = new MIDI2(func.apply(this, [this._master].concat(Array.prototype.slice.call(arguments))));
              msg2._mpe = msg2[1];
              return this.send(msg2);
            }
            return this.send(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
          };
        }
        function _copyHelperCH(name2, func) {
          MIDI2[name2] = function() {
            return new MIDI2(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
          };
          _helpers[name2] = function() {
            if (typeof this._master != "undefined") {
              var chan;
              var args = Array.prototype.slice.call(arguments);
              if (args.length < func.length)
                args = [this._master].concat(args);
              else {
                chan = _7bn(args[0]);
                args[0] = this._master;
              }
              var msg2 = new MIDI2(func.apply(this, args));
              msg2._mpe = chan;
              return this.send(msg2);
            }
            return this.send(func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));
          };
        }
        function _copyHelperGCH(name2, func) {
          MIDI2[name2] = function() {
            var i2;
            var g = [];
            var a = func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));
            for (i2 = 0; i2 < a.length; i2++)
              g.push(new MIDI2(a[i2]));
            return g;
          };
          _helpers[name2] = function() {
            var i2;
            var a;
            var g;
            if (typeof this._master != "undefined") {
              var chan;
              var args = Array.prototype.slice.call(arguments);
              if (args.length < func.length)
                args = [this._master].concat(args);
              else {
                chan = _7bn(args[0]);
                args[0] = this._master;
              }
              a = func.apply(this, args);
              g = this;
              for (i2 = 0; i2 < a.length; i2++) {
                var msg2 = MIDI2(a[i2]);
                msg2._mpe = chan;
                g = g.send(msg2);
              }
              return g;
            }
            a = func.apply(this, typeof this._ch == "undefined" ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));
            g = this;
            for (i2 = 0; i2 < a.length; i2++)
              g = g.send(a[i2]);
            return g;
          };
        }
        _for(_helperNC, function(n2) {
          _copyHelperNC(n2, _helperNC[n2]);
        });
        _for(_helperSMF, function(n2) {
          _copyHelperSMF(n2, _helperSMF[n2]);
        });
        _for(_helperGNC, function(n2) {
          _copyHelperGNC(n2, _helperGNC[n2]);
        });
        _for(_helperMPE, function(n2) {
          _copyHelperMPE(n2, _helperMPE[n2]);
        });
        _for(_helperCH, function(n2) {
          _copyHelperCH(n2, _helperCH[n2]);
        });
        _for(_helperGCH, function(n2) {
          _copyHelperGCH(n2, _helperGCH[n2]);
        });
        function _copyMidiHelpers(M) {
          _for(_helpers, function(n2) {
            M.prototype[n2] = _helpers[n2];
          });
        }
        _copyMidiHelpers(_M);
        var _channelMap = { a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
        for (k = 0; k < 16; k++)
          _channelMap[k] = k;
        MIDI2.prototype.getChannel = function() {
          if (this.ff == 32 && this.dd.length == 1 && this.dd.charCodeAt(0) < 16)
            return this.dd.charCodeAt(0);
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 239)
            return;
          return c & 15;
        };
        MIDI2.prototype.setChannel = function(x) {
          x = _channelMap[x];
          if (typeof x == "undefined")
            return this;
          if (this.ff == 32)
            this.dd = String.fromCharCode(x);
          else {
            var c = this[0];
            if (typeof c != "undefined" && c >= 128 && c <= 239)
              this[0] = c & 240 | x;
          }
          return this;
        };
        MIDI2.prototype.getNote = function() {
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 175)
            return;
          return this[1];
        };
        MIDI2.prototype.setNote = function(x) {
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 175)
            return this;
          x = MIDI2.noteValue(x);
          if (typeof x != "undefined")
            this[1] = x;
          return this;
        };
        MIDI2.prototype.getVelocity = function() {
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 159)
            return;
          return this[2];
        };
        MIDI2.prototype.setVelocity = function(x) {
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 159)
            return this;
          x = parseInt(x);
          if (x >= 0 && x < 128)
            this[2] = x;
          return this;
        };
        MIDI2.prototype.getSysExId = function() {
          if (this[0] == 240)
            return this[2];
        };
        MIDI2.prototype.setSysExId = function(x) {
          if (this[0] == 240 && this.length > 2) {
            x = parseInt(x);
            if (x >= 0 && x < 128)
              this[2] = x;
          }
          return this;
        };
        MIDI2.prototype.getData = function() {
          if (typeof this.dd != "undefined")
            return this.dd.toString();
        };
        MIDI2.prototype.setData = function(dd) {
          this.dd = _2s(dd);
          return this;
        };
        function _is_yamaha_smf(ff, dd) {
          return ff == 127 && typeof dd != "undefined" && dd.charCodeAt(0) == 67 && dd.charCodeAt(1) == 123;
        }
        function _is_yamaha_chord(ff, dd) {
          return _is_yamaha_smf(ff, dd) && dd.charCodeAt(2) == 1;
        }
        function _yamaha_chord(a, b) {
          if (a >= 0 && a <= 127 && b >= 0 && b <= 127) {
            var c = a & 15;
            var d = a >> 4;
            if (c > 0 && c < 8 && d < 7)
              c = ["C", "D", "E", "F", "G", "A", "B"][c - 1] + ["bbb", "bb", "b", "", "#", "##", "###"][d];
            else
              return "-";
            if (b > 34)
              return c + "?";
            else
              return c + [
                "",
                "6",
                "Maj7",
                "Maj7(#11)",
                "(9)",
                "Maj7(9)",
                "6(9)",
                "aug",
                "m",
                "m6",
                "m7",
                "m7b5",
                "m(9)",
                "m7(9)",
                "m7(11)",
                "m+7",
                "m+7(9)",
                "dim",
                "dim7",
                "7",
                "7sus4",
                "7b5",
                "7(9)",
                "7(#11)",
                "7(13)",
                "7(b9)",
                "7(b13)",
                "7(#9)",
                "Maj7aug",
                "7aug",
                "1+8",
                "1+5",
                "sus4",
                "1+2+5",
                "cc"
              ][b];
          }
          return "-";
        }
        MIDI2.prototype.getText = function() {
          if (typeof this.dd != "undefined") {
            if (_is_yamaha_chord(this.ff, this.dd))
              return _yamaha_chord(this.dd.charCodeAt(3), this.dd.charCodeAt(4));
            else
              return JZZ4.lib.fromUTF8(this.dd);
          }
          if (this.isMidiSoft()) {
            var s = [];
            for (var i2 = 6; i2 < this.length - 1; i2++)
              s.push(String.fromCharCode(this[i2]));
            return s.join("");
          }
        };
        MIDI2.prototype.setText = function(dd) {
          this.dd = JZZ4.lib.toUTF8(dd);
          return this;
        };
        MIDI2.prototype.getTempo = function() {
          if (this.ff == 81 && typeof this.dd != "undefined") {
            return this.dd.charCodeAt(0) * 65536 + this.dd.charCodeAt(1) * 256 + this.dd.charCodeAt(2);
          }
        };
        MIDI2.prototype.getBPM = function() {
          var ms = this.getTempo();
          if (ms)
            return 6e7 / ms;
        };
        MIDI2.prototype.getTimeSignature = function() {
          if (this.ff == 88 && typeof this.dd != "undefined") {
            return [this.dd.charCodeAt(0), 1 << this.dd.charCodeAt(1)];
          }
        };
        MIDI2.prototype.getKeySignature = function() {
          if (this.ff == 89 && typeof this.dd != "undefined") {
            var sf = this.dd.charCodeAt(0);
            var mi = this.dd.charCodeAt(1);
            if (sf & 128)
              sf = sf - 256;
            if (sf >= -7 && sf <= 7 && mi >= 0 && mi <= 1) {
              return [
                sf,
                ["Cb", "Gb", "Db", "Ab", "Eb", "Bb", "F", "C", "G", "D", "A", "E", "B", "F#", "C#", "G#", "D#", "A#"][mi ? sf + 10 : sf + 7],
                !!mi
              ];
            }
          }
        };
        MIDI2.prototype.isNoteOn = function() {
          var c = this[0];
          if (typeof c == "undefined" || c < 144 || c > 159)
            return false;
          return this[2] > 0 ? true : false;
        };
        MIDI2.prototype.isNoteOff = function() {
          var c = this[0];
          if (typeof c == "undefined" || c < 128 || c > 159)
            return false;
          if (c < 144)
            return true;
          return this[2] == 0 ? true : false;
        };
        MIDI2.prototype.isSysEx = function() {
          return this[0] == 240;
        };
        MIDI2.prototype.isFullSysEx = function() {
          return this[0] == 240 && this[this.length - 1] == 247;
        };
        MIDI2.prototype.isMidiSoft = function() {
          return this.isFullSysEx() && this[1] == 0 && this[2] == 32 && this[3] == 36 && this[4] == 0;
        };
        MIDI2.prototype.isSMF = function() {
          return this.ff >= 0 && this.ff <= 127;
        };
        MIDI2.prototype.isEOT = function() {
          return this.ff == 47;
        };
        MIDI2.prototype.isTempo = function() {
          return this.ff == 81;
        };
        MIDI2.prototype.isTimeSignature = function() {
          return this.ff == 88;
        };
        MIDI2.prototype.isKeySignature = function() {
          return this.ff == 89;
        };
        MIDI2.prototype.isGmReset = function() {
          return this.match([240, 126, [0, 0], 9, [0, 0], 247]);
        };
        MIDI2.prototype.isGsReset = function() {
          return this.match([240, 65, [0, 0], 66, 18, 64, 0, 127, 0, 65, 247]);
        };
        MIDI2.prototype.isXgReset = function() {
          return this.match([240, 67, [16, 240], 76, 0, 0, 126, 0, 247]);
        };
        MIDI2.prototype.match = function(a) {
          var i2, m2;
          for (i2 = 0; i2 < a.length; i2++) {
            m2 = a[i2][1];
            if (typeof m2 == "undefined") {
              if (this[i2] != a[i2])
                return false;
            } else {
              if ((this[i2] & m2) != (a[i2][0] & m2))
                return false;
            }
          }
          return true;
        };
        function _s2a(x) {
          var a = [];
          for (var i2 = 0; i2 < x.length; i2++) {
            a[i2] = x.charCodeAt(i2);
          }
          return a;
        }
        function _a2s(x) {
          var a = "";
          for (var i2 = 0; i2 < x.length; i2++) {
            a += String.fromCharCode(x[i2]);
          }
          return a;
        }
        function _2s(x) {
          return x instanceof Array ? _a2s(x) : typeof x == "undefined" ? "" : "" + x;
        }
        function _s2n(x) {
          var n2 = 0;
          for (var i2 = 0; i2 < x.length; i2++)
            n2 = (n2 << 8) + x.charCodeAt(i2);
          return n2;
        }
        function __hex(x) {
          return (x < 16 ? "0" : "") + x.toString(16);
        }
        function _hex(x) {
          var a = [];
          for (var i2 = 0; i2 < x.length; i2++) {
            a[i2] = __hex(x[i2]);
          }
          return a.join(" ");
        }
        function _toLine(s) {
          var out = "";
          for (var i2 = 0; i2 < s.length; i2++) {
            if (s[i2] == "\n")
              out += "\\n";
            else if (s[i2] == "\r")
              out += "\\r";
            else if (s[i2] == "	")
              out += "\\t";
            else if (s.charCodeAt(i2) < 32)
              out += "\\x" + __hex(s.charCodeAt(i2));
            else
              out += s[i2];
          }
          return out;
        }
        function _smfhex(dd) {
          return dd.length ? ": " + _hex(_s2a(dd)) : "";
        }
        function _smftxt(dd) {
          return dd.length ? ": " + _toLine(JZZ4.lib.fromUTF8(dd)) : "";
        }
        MIDI2.prototype.label = function(s) {
          this.lbl = this.lbl ? this.lbl + ", " + s : s;
          return this;
        };
        MIDI2.prototype.toString = function() {
          return this.lbl ? this._str() + " (" + this.lbl + ")" : this._str();
        };
        MIDI2.prototype._str = function() {
          var s;
          var ss;
          if (!this.length) {
            if (typeof this.ff != "undefined") {
              s = "ff" + __hex(this.ff) + " -- ";
              if (this.ff == 0)
                s += "Sequence Number: " + _s2n(this.dd);
              else if (this.ff > 0 && this.ff < 10)
                s += ["", "Text", "Copyright", "Sequence Name", "Instrument Name", "Lyric", "Marker", "Cue Point", "Program Name", "Device Name"][this.ff] + _smftxt(this.dd);
              else if (this.ff == 32)
                s += "Channel Prefix" + _smfhex(this.dd);
              else if (this.ff == 33)
                s += "MIDI Port" + _smfhex(this.dd);
              else if (this.ff == 47)
                s += "End of Track" + _smfhex(this.dd);
              else if (this.ff == 81) {
                var bpm = Math.round(this.getBPM() * 100) / 100;
                s += "Tempo: " + bpm + " bpm";
              } else if (this.ff == 84)
                s += "SMPTE Offset: " + _smptetxt(_s2a(this.dd));
              else if (this.ff == 88) {
                var d = 1 << this.dd.charCodeAt(1);
                s += "Time Signature: " + this.dd.charCodeAt(0) + "/" + d;
                s += " " + this.dd.charCodeAt(2) + " " + this.dd.charCodeAt(3);
              } else if (this.ff == 89) {
                s += "Key Signature: ";
                var ks = this.getKeySignature();
                if (ks) {
                  s += ks[1];
                  if (ks[2])
                    s += " min";
                } else
                  s += "invalid";
              } else if (this.ff == 127) {
                if (this.dd.charCodeAt(0) == 67) {
                  if (this.dd.charCodeAt(1) == 123) {
                    s += "[XF:" + __hex(this.dd.charCodeAt(2)) + "]";
                    ss = {
                      0: "Version",
                      1: "Chord",
                      2: "Rehearsal Mark",
                      3: "Phrase Mark",
                      4: "Max Phrase Mark",
                      5: "Fingering Number",
                      12: "Guide Track Flag",
                      16: "Guitar Info",
                      18: "Chord Voicing",
                      127: "XG Song Data Number"
                    }[this.dd.charCodeAt(2)];
                    s += ss ? " " + ss : "";
                    s += ": ";
                    if (this.dd.charCodeAt(2) == 0) {
                      return s + this.dd.substr(3, 4) + " " + _hex(_s2a(this.dd.substr(7)));
                    }
                    if (this.dd.charCodeAt(2) == 1) {
                      return s + this.getText();
                    }
                    return s + _hex(_s2a(this.dd.substr(3)));
                  }
                }
                s += "Sequencer Specific" + _smfhex(this.dd);
              } else
                s += "SMF" + _smfhex(this.dd);
              return s;
            }
            return "empty";
          }
          s = _hex(this);
          if (this[0] < 128)
            return s;
          ss = {
            241: "MIDI Time Code",
            242: "Song Position",
            243: "Song Select",
            244: "Undefined",
            245: "Undefined",
            246: "Tune request",
            248: "Timing clock",
            249: "Undefined",
            250: "Start",
            251: "Continue",
            252: "Stop",
            253: "Undefined",
            254: "Active Sensing",
            255: "Reset"
          }[this[0]];
          if (ss)
            return s + " -- " + ss;
          if (this.isMidiSoft()) {
            ss = _toLine(this.getText());
            if (ss)
              ss = " " + ss;
            return s + " -- [K:" + __hex(this[5]) + "]" + ss;
          }
          var c = this[0] >> 4;
          ss = { 8: "Note Off", 10: "Aftertouch", 12: "Program Change", 13: "Channel Aftertouch", 14: "Pitch Wheel" }[c];
          if (ss)
            return s + " -- " + ss;
          if (c == 9)
            return s + " -- " + (this[2] ? "Note On" : "Note Off");
          if (c != 11)
            return s;
          ss = {
            0: "Bank Select MSB",
            1: "Modulation Wheel MSB",
            2: "Breath Controller MSB",
            4: "Foot Controller MSB",
            5: "Portamento Time MSB",
            6: "Data Entry MSB",
            7: "Channel Volume MSB",
            8: "Balance MSB",
            10: "Pan MSB",
            11: "Expression Controller MSB",
            12: "Effect Control 1 MSB",
            13: "Effect Control 2 MSB",
            16: "General Purpose Controller 1 MSB",
            17: "General Purpose Controller 2 MSB",
            18: "General Purpose Controller 3 MSB",
            19: "General Purpose Controller 4 MSB",
            31: "Karaoke",
            32: "Bank Select LSB",
            33: "Modulation Wheel LSB",
            34: "Breath Controller LSB",
            36: "Foot Controller LSB",
            37: "Portamento Time LSB",
            38: "Data Entry LSB",
            39: "Channel Volume LSB",
            40: "Balance LSB",
            42: "Pan LSB",
            43: "Expression Controller LSB",
            44: "Effect control 1 LSB",
            45: "Effect control 2 LSB",
            48: "General Purpose Controller 1 LSB",
            49: "General Purpose Controller 2 LSB",
            50: "General Purpose Controller 3 LSB",
            51: "General Purpose Controller 4 LSB",
            64: "Damper Pedal",
            65: "Portamento",
            66: "Sostenuto",
            67: "Soft Pedal",
            68: "Legato",
            69: "Hold 2",
            70: "Sound Variation",
            71: "Filter Resonance",
            72: "Release Time",
            73: "Attack Time",
            74: "Brightness",
            75: "Decay Time",
            76: "Vibrato Rate",
            77: "Vibrato Depth",
            78: "Vibrato Delay",
            79: "Sound Controller 10",
            80: "General Purpose Controller 5",
            81: "General Purpose Controller 6",
            82: "General Purpose Controller 7",
            83: "General Purpose Controller 8",
            84: "Portamento Control",
            88: "High Resolution Velocity Prefix",
            91: "Effects 1 Depth",
            92: "Effects 2 Depth",
            93: "Effects 3 Depth",
            94: "Effects 4 Depth",
            95: "Effects 5 Depth",
            96: "Data Increment",
            97: "Data Decrement",
            98: "Non-Registered Parameter Number LSB",
            99: "Non-Registered Parameter Number MSB",
            100: "Registered Parameter Number LSB",
            101: "Registered Parameter Number MSB",
            120: "All Sound Off",
            121: "Reset All Controllers",
            122: "Local Control On/Off",
            123: "All Notes Off",
            124: "Omni Mode Off",
            125: "Omni Mode On",
            126: "Mono Mode On",
            127: "Poly Mode On"
          }[this[1]];
          if (this[1] >= 64 && this[1] <= 69)
            ss += this[2] < 64 ? " Off" : " On";
          if (!ss)
            ss = "Undefined";
          return s + " -- " + ss;
        };
        MIDI2.prototype._stamp = function(obj) {
          this._from.push(obj._orig ? obj._orig : obj);
          return this;
        };
        MIDI2.prototype._unstamp = function(obj) {
          if (typeof obj == "undefined")
            this._from = [];
          else {
            if (obj._orig)
              obj = obj._orig;
            var i2 = this._from.indexOf(obj);
            if (i2 > -1)
              this._from.splice(i2, 1);
          }
          return this;
        };
        MIDI2.prototype._stamped = function(obj) {
          if (obj._orig)
            obj = obj._orig;
          for (var i2 = 0; i2 < this._from.length; i2++)
            if (this._from[i2] == obj)
              return true;
          return false;
        };
        JZZ4.MIDI = MIDI2;
        _J.prototype.MIDI = MIDI2;
        function _clear_ctxt() {
          var i2;
          this._cc = [];
          for (i2 = 0; i2 < 16; i2++)
            this._cc[i2] = {};
        }
        function _rpn_txt(msb, lsb) {
          var a = typeof msb == "undefined" ? "??" : __hex(msb);
          var b = typeof lsb == "undefined" ? "??" : __hex(lsb);
          var c = {
            "0000": "Pitch Bend Sensitivity",
            "0001": "Channel Fine Tune",
            "0002": "Channel Coarse Tune",
            "0003": "Select Tuning Program",
            "0004": "Select Tuning Bank",
            "0005": "Vibrato Depth Range",
            "7f7f": "NONE"
          }[a + "" + b];
          return "RPN " + a + " " + b + (c ? ": " + c : "");
        }
        function _nrpn_txt(msb, lsb) {
          var a = typeof msb == "undefined" ? "??" : __hex(msb);
          var b = typeof lsb == "undefined" ? "??" : __hex(lsb);
          return "NRPN " + a + " " + b;
        }
        function _read_ctxt(msg2) {
          if (!msg2.length || msg2[0] < 128)
            return msg2;
          if (msg2[0] == 255) {
            this._clear();
            return msg2;
          }
          var ch = msg2[0] & 15;
          var st = msg2[0] >> 4;
          var s;
          if (st == 12) {
            msg2._bm = this._cc[ch].bm;
            msg2._bl = this._cc[ch].bl;
            if (JZZ4.MIDI.programName)
              msg2.label(JZZ4.MIDI.programName(msg2[1], msg2._bm, msg2._bl));
          } else if (st == 11) {
            switch (msg2[1]) {
              case 0:
                this._cc[ch].bm = msg2[2];
                break;
              case 32:
                this._cc[ch].bl = msg2[2];
                break;
              case 98:
                this._cc[ch].nl = msg2[2];
                this._cc[ch].rn = "n";
                break;
              case 99:
                this._cc[ch].nm = msg2[2];
                this._cc[ch].rn = "n";
                break;
              case 100:
                this._cc[ch].rl = msg2[2];
                this._cc[ch].rn = "r";
                break;
              case 101:
                this._cc[ch].rm = msg2[2];
                this._cc[ch].rn = "r";
                break;
              case 6:
              case 38:
              case 96:
              case 97:
                if (this._cc[ch].rn == "r") {
                  msg2._rm = this._cc[ch].rm;
                  msg2._rl = this._cc[ch].rl;
                  msg2.label(_rpn_txt(this._cc[ch].rm, this._cc[ch].rl));
                }
                if (this._cc[ch].rn == "n") {
                  msg2._nm = this._cc[ch].rm;
                  msg2._nl = this._cc[ch].nl;
                  msg2.label(_nrpn_txt(this._cc[ch].nm, this._cc[ch].nl));
                }
                break;
            }
          } else if (msg2.isFullSysEx()) {
            if (msg2[1] == 127) {
              if (msg2[3] == 4) {
                s = { 1: "Master Volume", 2: "Master Balance", 3: "Master Fine Tuning", 4: "Master Coarse Tuning" }[msg2[4]];
                if (s)
                  msg2.label(s);
              } else if (msg2[3] == 8) {
                s = { 2: "Note Tuning", 7: "Note Tuning, Bank", 8: "Scale Tuning, 1 byte format", 9: "Scale Tuning, 2 byte format" }[msg2[4]];
                if (s)
                  msg2.label(s);
              }
            } else if (msg2[1] == 126) {
              if (msg2[3] == 6) {
                if (msg2[4] == 1)
                  msg2.label("Device ID Request");
                else if (msg2[4] == 2) {
                  msg2.label("Device ID Response");
                }
              } else if (msg2[3] == 8) {
                s = {
                  0: "Bulk Tuning Dump Request",
                  1: "Bulk Tuning Dump",
                  3: "Bulk Tuning Dump Request, Bank",
                  4: "Bulk Tuning Dump, Bank",
                  5: "Scale Tuning Dump, 1 byte format",
                  6: "Scale Tuning Dump, 2 byte format",
                  7: "Note Tuning, Bank",
                  8: "Scale Tuning, 1 byte format",
                  9: "Scale Tuning, 2 byte format"
                }[msg2[4]];
                if (s)
                  msg2.label(s);
              } else if (msg2[3] == 9) {
                if (msg2[4] == 1) {
                  msg2.label("GM1 System On");
                  this._clear();
                  this._gm = "1";
                } else if (msg2[4] == 2) {
                  msg2.label("GM System Off");
                  this._clear();
                  this._gm = "0";
                } else if (msg2[4] == 3) {
                  msg2.label("GM2 System On");
                  this._clear();
                  this._gm = "2";
                }
              }
            } else if (msg2[1] == 67) {
              if ((msg2[2] & 240) == 16 && msg2[3] == 76) {
                if (msg2[4] == 0 && msg2[5] == 0 && msg2[6] == 126 && msg2[7] == 0) {
                  msg2.label("XG System On");
                  this._clear();
                  this._gm = "Y";
                } else if (msg2[4] == 0 && msg2[5] == 0 && msg2[6] == 0)
                  msg2.label("XG Master Tuning");
                else if (msg2[4] == 0 && msg2[5] == 0 && msg2[6] == 4)
                  msg2.label("XG Master Volume");
                else if (msg2[4] == 0 && msg2[5] == 0 && msg2[6] == 6)
                  msg2.label("XG Master Transpose");
                else if (msg2[4] == 8 && msg2[5] < 16 && msg2[6] >= 65 && msg2[6] <= 76)
                  msg2.label("XG Scale Tuning");
                else
                  msg2.label("XG Parameter");
              }
            } else if (msg2[1] == 65) {
              if (msg2[3] == 66 && msg2[4] == 18) {
                if (msg2[5] == 64) {
                  if (msg2[6] == 0) {
                    if (msg2[7] == 127 && msg2[8] == 0 && msg2[9] == 65) {
                      msg2.label("GS Reset");
                      this._clear();
                      this._gm = "R";
                    } else if (msg2[7] == 0)
                      msg2.label("GS Master Tuning");
                    else if (msg2[7] == 4)
                      msg2.label("GS Master Volume");
                    else if (msg2[7] == 5)
                      msg2.label("GS Master Transpose");
                    else
                      msg2.label("GS Parameter");
                  } else if ((msg2[6] & 240) == 16 && msg2[7] == 21)
                    msg2.label("GS Drum Part Change");
                  else if ((msg2[6] & 240) == 16 && msg2[7] >= 64 && msg2[7] <= 75)
                    msg2.label("GS Scale Tuning");
                  else
                    msg2.label("GS Parameter");
                }
                if (msg2[5] == 65)
                  msg2.label("GS Parameter");
              }
            }
          }
          return msg2;
        }
        function Context() {
          var self = new _M();
          self._clear = _clear_ctxt;
          self._read = _read_ctxt;
          self._receive = function(msg2) {
            this._emit(this._read(msg2));
          };
          self._clear();
          self._resume();
          return self;
        }
        JZZ4.Context = Context;
        _J.prototype.Context = Context;
        function MPE() {
          var self = this instanceof MPE ? this : self = new MPE();
          self.reset();
          if (arguments.length)
            MPE.prototype.setup.apply(self, arguments);
          return self;
        }
        MPE.validate = function(arg) {
          var a = arg instanceof Array ? arg : arguments;
          if (a[0] != parseInt(a[0]) || a[0] < 0 || a[0] > 14)
            throw RangeError("Bad master channel value: " + a[0]);
          if (a[1] != parseInt(a[1]) || a[1] < 0 || a[0] + a[1] > 15)
            throw RangeError("Bad zone size value: " + a[1]);
        };
        MPE.prototype.reset = function() {
          for (var n2 = 0; n2 < 16; n2++)
            this[n2] = { band: 0, master: n2 };
        };
        MPE.prototype.setup = function(m2, n2) {
          MPE.validate(m2, n2);
          var k2;
          var last = m2 + n2;
          if (this[m2].master == m2 && this[m2].band == n2)
            return;
          if (!n2 && !this[m2].band)
            return;
          if (this[m2].band) {
            k2 = m2 + this[m2].band;
            if (last < k2)
              last = k2;
          } else if (this[m2].master == m2 - 1) {
            k2 = m2 - 1;
            k2 = k2 + this[k2].band;
            if (last < k2)
              last = k2;
            this[m2 - 1] = { band: 0, master: m2 - 1 };
          } else if (this[m2].master != m2) {
            k2 = this[m2].master;
            k2 = k2 + this[k2].band;
            if (last < k2)
              last = k2;
            this[this[m2].master].band = m2 - this[m2].master - 1;
          }
          this[m2].master = m2;
          this[m2].band = n2;
          for (k2 = m2 + 1; k2 <= m2 + n2; k2++) {
            if (this[k2].band && last < k2 + this[k2].band)
              last = k2 + this[k2].band;
            this[k2] = { band: 0, master: m2 };
          }
          for (; k2 <= last; k2++)
            this[k2] = { band: 0, master: k2 };
        };
        MPE.prototype.filter = function(msg2) {
          var c = msg2.getChannel();
          if (!this[c] || !this[this[c].master].band)
            return msg2;
          var m2 = this[c].master;
          var n2 = this[m2].band;
          var i2, j2, k2;
          if (typeof msg2._mpe != "undefined") {
            k2 = 256;
            for (i2 = m2 + 1; i2 <= m2 + n2; i2++) {
              if (!this[i2].notes) {
                if (k2 > 0) {
                  c = i2;
                  k2 = 0;
                }
              } else {
                if (k2 > this[i2].notes.length) {
                  c = i2;
                  k2 = this[i2].notes.length;
                }
                for (j2 = 0; j2 < this[i2].notes.length; j2++) {
                  if (this[i2].notes[j2] == msg2._mpe) {
                    c = i2;
                    k2 = -1;
                    break;
                  }
                }
              }
            }
            msg2.setChannel(c);
            msg2._mpe = void 0;
          }
          if (c == m2)
            return msg2;
          if (msg2.isNoteOn()) {
            if (!this[c].notes)
              this[c].notes = [];
            _push(this[c].notes, msg2.getNote());
          } else if (msg2.isNoteOff()) {
            if (this[c].notes)
              _pop(this[c].notes, msg2.getNote());
          }
          return msg2;
        };
        JZZ4.MPE = MPE;
        JZZ4.lib = {};
        JZZ4.lib.now = _now;
        JZZ4.lib.schedule = _schedule;
        JZZ4.lib.openMidiOut = function(name2, engine) {
          var port = new _M();
          engine._openOut(port);
          port._info = engine._info(name2);
          return port;
        };
        JZZ4.lib.openMidiIn = function(name2, engine) {
          var port = new _M();
          engine._openIn(port);
          port._info = engine._info(name2);
          return port;
        };
        JZZ4.lib.registerMidiOut = function(name2, engine) {
          var x = engine._info(name2);
          for (var i2 = 0; i2 < _virtual._outs.length; i2++)
            if (_virtual._outs[i2].name == x.name)
              return false;
          x.engine = engine;
          _virtual._outs.push(x);
          if (_jzz) {
            _postRefresh();
            if (_jzz._bad) {
              _jzz._repair();
              _jzz._resume();
            }
          }
          return true;
        };
        JZZ4.lib.registerMidiIn = function(name2, engine) {
          var x = engine._info(name2);
          for (var i2 = 0; i2 < _virtual._ins.length; i2++)
            if (_virtual._ins[i2].name == x.name)
              return false;
          x.engine = engine;
          _virtual._ins.push(x);
          if (_jzz) {
            _postRefresh();
            if (_jzz._bad) {
              _jzz._repair();
              _jzz._resume();
            }
          }
          return true;
        };
        var _ac;
        function _initAudioContext() {
          if (!_ac && typeof window !== "undefined") {
            var AudioContext2 = window.AudioContext || window.webkitAudioContext;
            if (AudioContext2) {
              _ac = new AudioContext2();
              if (_ac && !_ac.createGain)
                _ac.createGain = _ac.createGainNode;
              var _activateAudioContext = function() {
                if (_ac.state != "running") {
                  _ac.resume();
                  var osc = _ac.createOscillator();
                  var gain = _ac.createGain();
                  try {
                    gain.gain.value = 0;
                  } catch (err) {
                  }
                  gain.gain.setTargetAtTime(0, _ac.currentTime, 0.01);
                  osc.connect(gain);
                  gain.connect(_ac.destination);
                  if (!osc.start)
                    osc.start = osc.noteOn;
                  if (!osc.stop)
                    osc.stop = osc.noteOff;
                  osc.start(0.1);
                  osc.stop(0.11);
                } else if (typeof document != "undefined") {
                  document.removeEventListener("touchstart", _activateAudioContext);
                  document.removeEventListener("touchend", _activateAudioContext);
                  document.removeEventListener("mousedown", _activateAudioContext);
                  document.removeEventListener("keydown", _activateAudioContext);
                }
              };
              if (typeof document != "undefined") {
                document.addEventListener("touchstart", _activateAudioContext);
                document.addEventListener("touchend", _activateAudioContext);
                document.addEventListener("mousedown", _activateAudioContext);
                document.addEventListener("keydown", _activateAudioContext);
              }
              _activateAudioContext();
            }
          }
        }
        JZZ4.lib.copyMidiHelpers = _copyMidiHelpers;
        JZZ4.lib.getAudioContext = function() {
          _initAudioContext();
          return _ac;
        };
        var _b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        JZZ4.lib.fromBase64 = function(input) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i2 = 0;
          input = input.replace(/[^A-Za-z0-9+/=]/g, "");
          while (i2 < input.length) {
            enc1 = _b64.indexOf(input.charAt(i2++));
            enc2 = _b64.indexOf(input.charAt(i2++));
            enc3 = _b64.indexOf(input.charAt(i2++));
            enc4 = _b64.indexOf(input.charAt(i2++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          return output;
        };
        JZZ4.lib.toBase64 = function(data) {
          var o1, o2, o3, h1, h2, h3, h4, bits, i2 = 0, ac = 0, enc = "", arr = [];
          if (!data)
            return data;
          do {
            o1 = data.charCodeAt(i2++);
            o2 = data.charCodeAt(i2++);
            o3 = data.charCodeAt(i2++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h2 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            arr[ac++] = _b64.charAt(h1) + _b64.charAt(h2) + _b64.charAt(h3) + _b64.charAt(h4);
          } while (i2 < data.length);
          enc = arr.join("");
          var r = data.length % 3;
          return r ? enc.slice(0, r - 3) + "===".slice(r) : enc;
        };
        JZZ4.lib.fromUTF8 = function(data) {
          data = typeof data == "undefined" ? "" : "" + data;
          var out = "";
          var i2, n2, m2;
          for (i2 = 0; i2 < data.length; i2++) {
            n2 = data.charCodeAt(i2);
            if (n2 > 255)
              return data;
            if (n2 < 128)
              out += data[i2];
            else if ((n2 & 224) == 192) {
              n2 = (n2 & 31) << 6;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += m2 & 63;
              out += String.fromCharCode(n2);
            } else if ((n2 & 240) == 224) {
              n2 = (n2 & 15) << 12;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += (m2 & 63) << 6;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += m2 & 63;
              out += String.fromCharCode(n2);
            } else if ((n2 & 248) == 240) {
              n2 = (n2 & 7) << 18;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += (m2 & 63) << 12;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += (m2 & 63) << 6;
              i2++;
              if (i2 >= data.length)
                return data;
              m2 = data.charCodeAt(i2);
              if ((m2 & 192) != 128)
                return data;
              n2 += m2 & 63;
              if (n2 > 1114111)
                return data;
              n2 -= 65536;
              out += String.fromCharCode(55296 + (n2 >> 10));
              out += String.fromCharCode(56320 + (n2 & 1023));
            }
          }
          return out;
        };
        JZZ4.lib.toUTF8 = function(data) {
          data = typeof data == "undefined" ? "" : "" + data;
          var out = "";
          var i2, n2;
          for (i2 = 0; i2 < data.length; i2++) {
            n2 = data.charCodeAt(i2);
            if (n2 < 128)
              out += data[i2];
            else if (n2 < 2048) {
              out += String.fromCharCode(192 + (n2 >> 6));
              out += String.fromCharCode(128 + (n2 & 63));
            } else if (n2 < 65536) {
              out += String.fromCharCode(224 + (n2 >> 12));
              out += String.fromCharCode(128 + (n2 >> 6 & 63));
              out += String.fromCharCode(128 + (n2 & 63));
            } else {
              out += String.fromCharCode(240 + (n2 >> 18));
              out += String.fromCharCode(128 + (n2 >> 12 & 63));
              out += String.fromCharCode(128 + (n2 >> 6 & 63));
              out += String.fromCharCode(128 + (n2 & 63));
            }
          }
          return out;
        };
        var _wma = [];
        var _outputMap = {};
        var _inputMap = {};
        var Promise2 = _scope.Promise;
        if (typeof Promise2 !== "function") {
          Promise2 = function(executor) {
            this.executor = executor;
          };
          Promise2.prototype.then = function(resolve, reject) {
            if (typeof resolve !== "function") {
              resolve = _nop;
            }
            if (typeof reject !== "function") {
              reject = _nop;
            }
            this.executor(resolve, reject);
          };
        }
        function DOMException(name2, message, code) {
          this.name = name2;
          this.message = message;
          this.code = code;
        }
        function MIDIConnectionEvent(port, target) {
          this.bubbles = false;
          this.cancelBubble = false;
          this.cancelable = false;
          this.currentTarget = target;
          this.defaultPrevented = false;
          this.eventPhase = 0;
          this.path = [];
          this.port = port;
          this.returnValue = true;
          this.srcElement = target;
          this.target = target;
          this.timeStamp = _now();
          this.type = "statechange";
        }
        function MIDIMessageEvent(port, data) {
          this.bubbles = false;
          this.cancelBubble = false;
          this.cancelable = false;
          this.currentTarget = port;
          this.data = data;
          this.defaultPrevented = false;
          this.eventPhase = 0;
          this.path = [];
          this.receivedTime = _now();
          this.returnValue = true;
          this.srcElement = port;
          this.target = port;
          this.timeStamp = this.receivedTime;
          this.type = "midimessage";
        }
        function _statechange(p, a) {
          if (p) {
            if (p.onstatechange)
              p.onstatechange(new MIDIConnectionEvent(p, p));
            if (a.onstatechange)
              a.onstatechange(new MIDIConnectionEvent(p, a));
          }
        }
        function MIDIInput(a, p) {
          var self = this;
          var _open = false;
          var _ochng = null;
          var _onmsg = null;
          this.type = "input";
          this.id = p.id;
          this.name = p.name;
          this.manufacturer = p.man;
          this.version = p.ver;
          Object.defineProperty(this, "state", { get: function() {
            return p.connected ? "connected" : "disconnected";
          }, enumerable: true });
          Object.defineProperty(this, "connection", { get: function() {
            return _open ? p.proxy ? "open" : "pending" : "closed";
          }, enumerable: true });
          Object.defineProperty(this, "onmidimessage", {
            get: function() {
              return _onmsg;
            },
            set: function(value) {
              if (_func(value)) {
                _onmsg = value;
                if (!_open)
                  self.open().then(_nop, _nop);
              } else
                _onmsg = null;
            },
            enumerable: true
          });
          Object.defineProperty(this, "onstatechange", {
            get: function() {
              return _ochng;
            },
            set: function(value) {
              if (_func(value))
                _ochng = value;
              else
                _ochng = null;
            },
            enumerable: true
          });
          this.open = function() {
            return new Promise2(function(resolve, reject) {
              if (_open)
                resolve(self);
              else {
                p.open().then(function() {
                  if (!_open) {
                    _open = true;
                    _statechange(self, a);
                  }
                  resolve(self);
                }, function() {
                  reject(new DOMException("InvalidAccessError", "Port is not available", 15));
                });
              }
            });
          };
          this.close = function() {
            return new Promise2(function(resolve) {
              if (_open) {
                _open = false;
                p.close();
                _statechange(self, a);
              }
              resolve(self);
            });
          };
          Object.freeze(this);
        }
        function _split(q) {
          var i2, k2;
          while (q.length) {
            for (i2 = 0; i2 < q.length; i2++)
              if (q[i2] == parseInt(q[i2]) && q[i2] >= 128 && q[i2] <= 255 && q[i2] != 247)
                break;
            q.splice(0, i2);
            if (!q.length)
              return;
            if (q[0] == 240) {
              for (i2 = 1; i2 < q.length; i2++)
                if (q[i2] == 247)
                  break;
              if (i2 == q.length)
                return;
              return q.splice(0, i2 + 1);
            } else {
              k2 = _datalen(q[0]) + 1;
              if (k2 > q.length)
                return;
              for (i2 = 1; i2 < k2; i2++)
                if (q[i2] != parseInt(q[i2]) || q[i2] < 0 || q[i2] >= 128)
                  break;
              if (i2 == k2)
                return q.splice(0, i2);
              else
                q.splice(0, i2);
            }
          }
        }
        function _InputProxy(id, name2, man, ver) {
          var self = this;
          this.id = id;
          this.name = name2;
          this.man = man;
          this.ver = ver;
          this.connected = true;
          this.ports = [];
          this.pending = [];
          this.proxy = void 0;
          this.queue = [];
          this.onmidi = function(msg2) {
            var m2;
            self.queue = self.queue.concat(msg2.slice());
            for (m2 = _split(self.queue); m2; m2 = _split(self.queue)) {
              for (i = 0; i < self.ports.length; i++) {
                if (self.ports[i][0].onmidimessage && (m2[0] != 240 || self.ports[i][1])) {
                  self.ports[i][0].onmidimessage(new MIDIMessageEvent(self, new Uint8Array(m2)));
                }
              }
            }
          };
        }
        _InputProxy.prototype.open = function() {
          var self = this;
          return new Promise2(function(resolve, reject) {
            var i2;
            if (self.proxy || !self.connected)
              resolve();
            else {
              self.pending.push([resolve, reject]);
              if (self.pending.length == 1) {
                JZZ4().openMidiIn(self.name).or(function() {
                  for (i2 = 0; i2 < self.pending.length; i2++)
                    self.pending[i2][1]();
                  self.pending = [];
                }).and(function() {
                  self.proxy = this;
                  self.proxy.connect(self.onmidi);
                  for (i2 = 0; i2 < self.pending.length; i2++)
                    self.pending[i2][0]();
                  self.pending = [];
                });
              }
            }
          });
        };
        _InputProxy.prototype.close = function() {
          var i2;
          if (this.proxy) {
            for (i2 = 0; i2 < this.ports.length; i2++)
              if (this.ports[i2].connection == "open")
                return;
            this.proxy.close();
            this.proxy = void 0;
          }
        };
        _InputProxy.prototype.disconnect = function() {
          this.connected = false;
          if (this.proxy) {
            this.proxy.close();
            this.proxy = void 0;
          }
        };
        _InputProxy.prototype.reconnect = function() {
          var self = this;
          var i2, p;
          var a = [];
          this.connected = true;
          for (i2 = 0; i2 < _wma.length; i2++) {
            p = _wma[i2].inputs.get(this.id);
            if (p.connection == "closed")
              _statechange(p, _wma[i2]);
            else
              a.push([p, _wma[i2]]);
          }
          if (a.length) {
            JZZ4()._openMidiInNR(self.name).or(function() {
              for (i2 = 0; i2 < a.length; i2++)
                a[i2][0].close();
            }).and(function() {
              self.proxy = this;
              self.proxy.connect(self.onmidi);
              for (i2 = 0; i2 < a.length; i2++)
                _statechange(a[i2][0], a[i2][1]);
            });
          }
        };
        function _datalen(x) {
          if (x >= 128 && x <= 191 || x >= 224 && x <= 239 || x == 242)
            return 2;
          if (x >= 192 && x <= 223 || x == 241 || x == 243)
            return 1;
          return 0;
        }
        var _epr = "Failed to execute 'send' on 'MIDIOutput': ";
        function _validate(arr, sysex) {
          var i2, k2;
          var msg2;
          var data = [];
          for (i2 = 0; i2 < arr.length; i2++) {
            if (arr[i2] != parseInt(arr[i2]) || arr[i2] < 0 || arr[i2] > 255)
              throw TypeError(_epr + arr[i2] + " is not a UInt8 value.");
          }
          k2 = 0;
          for (i2 = 0; i2 < arr.length; i2++) {
            if (!k2) {
              if (arr[i2] < 128)
                throw TypeError(_epr + "Running status is not allowed at index " + i2 + " (" + arr[i2] + ").");
              if (arr[i2] == 247)
                throw TypeError(_epr + "Unexpected end of system exclusive message at index " + i2 + " (" + arr[i2] + ").");
              msg2 = [arr[i2]];
              data.push(msg2);
              if (arr[i2] == 240) {
                if (!sysex)
                  throw new DOMException("InvalidAccessError", _epr + "System exclusive messag is not allowed at index " + i2 + " (" + arr[i2] + ").", 15);
                k2 = -1;
                for (; i2 < arr.length; i2++) {
                  msg2.push(arr[i2]);
                  if (arr[i2] == 247) {
                    k2 = 0;
                    break;
                  }
                }
              } else {
                k2 = _datalen(arr[i2]);
              }
            } else {
              if (arr[i2] > 127)
                throw TypeError(_epr + "Unexpected status byte at index " + i2 + " (" + arr[i2] + ").");
              msg2.push(arr[i2]);
              k2--;
            }
          }
          if (k2)
            throw TypeError(_epr + "Message is incomplete");
          return [data];
        }
        function MIDIOutput(a, p) {
          var self = this;
          var _open = false;
          var _ochng = null;
          this.type = "output";
          this.id = p.id;
          this.name = p.name;
          this.manufacturer = p.man;
          this.version = p.ver;
          Object.defineProperty(this, "state", { get: function() {
            return p.connected ? "connected" : "disconnected";
          }, enumerable: true });
          Object.defineProperty(this, "connection", { get: function() {
            return _open ? p.proxy ? "open" : "pending" : "closed";
          }, enumerable: true });
          Object.defineProperty(this, "onstatechange", {
            get: function() {
              return _ochng;
            },
            set: function(value) {
              if (_func(value))
                _ochng = value;
              else
                _ochng = null;
            },
            enumerable: true
          });
          this.open = function() {
            return new Promise2(function(resolve, reject) {
              if (_open)
                resolve(self);
              else {
                p.open().then(function() {
                  if (!_open) {
                    _open = true;
                    _statechange(self, a);
                  }
                  resolve(self);
                }, function() {
                  reject(new DOMException("InvalidAccessError", "Port is not available", 15));
                });
              }
            });
          };
          this.close = function() {
            return new Promise2(function(resolve) {
              if (_open) {
                _open = false;
                self.clear();
                p.close();
                _statechange(self, a);
              }
              resolve(self);
            });
          };
          this.clear = function() {
          };
          this.send = function(data, timestamp) {
            _validate(data, a.sysexEnabled);
            if (!p.connected)
              throw new DOMException("InvalidStateError", "Port is not connected", 11);
            if (_open) {
              var now = _now();
              if (timestamp > now)
                setTimeout(function() {
                  p.proxy.send(data);
                }, timestamp - now);
              else
                p.proxy.send(data);
            } else
              this.open().then(function() {
                self.send(data, timestamp);
              }, _nop);
          };
          Object.freeze(this);
        }
        function _OutputProxy(id, name2, man, ver) {
          this.id = id;
          this.name = name2;
          this.man = man;
          this.ver = ver;
          this.connected = true;
          this.ports = [];
          this.pending = [];
          this.proxy = void 0;
        }
        _OutputProxy.prototype.open = function() {
          var self = this;
          return new Promise2(function(resolve, reject) {
            var i2;
            if (self.proxy || !self.connected)
              resolve();
            else {
              self.pending.push([resolve, reject]);
              if (self.pending.length == 1) {
                JZZ4().openMidiOut(self.name).or(function() {
                  for (i2 = 0; i2 < self.pending.length; i2++)
                    self.pending[i2][1]();
                  self.pending = [];
                }).and(function() {
                  self.proxy = this;
                  for (i2 = 0; i2 < self.pending.length; i2++)
                    self.pending[i2][0]();
                  self.pending = [];
                });
              }
            }
          });
        };
        _OutputProxy.prototype.close = function() {
          var i2;
          if (this.proxy) {
            for (i2 = 0; i2 < this.ports.length; i2++)
              if (this.ports[i2].connection == "open")
                return;
            this.proxy.close();
            this.proxy = void 0;
          }
        };
        _OutputProxy.prototype.disconnect = function() {
          this.connected = false;
          if (this.proxy) {
            this.proxy.close();
            this.proxy = void 0;
          }
        };
        _OutputProxy.prototype.reconnect = function() {
          var self = this;
          var i2, p;
          var a = [];
          this.connected = true;
          for (i2 = 0; i2 < _wma.length; i2++) {
            p = _wma[i2].outputs.get(this.id);
            if (p.connection == "closed")
              _statechange(p, _wma[i2]);
            else
              a.push([p, _wma[i2]]);
          }
          if (a.length) {
            JZZ4()._openMidiOutNR(self.name).or(function() {
              for (i2 = 0; i2 < a.length; i2++)
                a[i2][0].close();
            }).and(function() {
              self.proxy = this;
              for (i2 = 0; i2 < a.length; i2++)
                _statechange(a[i2][0], a[i2][1]);
            });
          }
        };
        function _Maplike(data) {
          this.has = function(id) {
            return data.hasOwnProperty(id) && data[id].connected;
          };
          this.keys = function() {
            try {
              var m2 = /* @__PURE__ */ new Map();
              for (var id in data)
                if (this.has(id))
                  m2.set(id, this.get(id));
              return m2.keys();
            } catch (e) {
            }
          };
          this.values = function() {
            try {
              var m2 = /* @__PURE__ */ new Map();
              for (var id in data)
                if (this.has(id))
                  m2.set(id, this.get(id));
              return m2.values();
            } catch (e) {
            }
          };
          this.entries = function() {
            try {
              var m2 = /* @__PURE__ */ new Map();
              for (var id in data)
                if (this.has(id))
                  m2.set(id, this.get(id));
              return m2.entries();
            } catch (e) {
            }
          };
          this.forEach = function(fun, self) {
            if (typeof self == "undefined")
              self = this;
            for (var id in data)
              if (this.has(id))
                fun.call(self, this.get(id), id, this);
          };
          Object.defineProperty(this, "size", {
            get: function() {
              var len = 0;
              for (var id in data)
                if (this.has(id))
                  len++;
              return len;
            },
            enumerable: true
          });
        }
        function MIDIInputMap(_access, _inputs) {
          this.get = function(id) {
            if (_inputMap.hasOwnProperty(id) && _inputMap[id].connected) {
              if (!_inputs[id]) {
                _inputs[id] = new MIDIInput(_access, _inputMap[id]);
                _inputMap[id].ports.push([_inputs[id], _access.sysexEnabled]);
              }
              return _inputs[id];
            }
          };
          Object.freeze(this);
        }
        MIDIInputMap.prototype = new _Maplike(_inputMap);
        MIDIInputMap.prototype.constructor = MIDIInputMap;
        function MIDIOutputMap(_access, _outputs) {
          this.get = function(id) {
            if (_outputMap.hasOwnProperty(id) && _outputMap[id].connected) {
              if (!_outputs[id]) {
                _outputs[id] = new MIDIOutput(_access, _outputMap[id]);
                _outputMap[id].ports.push([_outputs[id], _access.sysexEnabled]);
              }
              return _outputs[id];
            }
          };
          Object.freeze(this);
        }
        MIDIOutputMap.prototype = new _Maplike(_outputMap);
        MIDIOutputMap.prototype.constructor = MIDIOutputMap;
        function _wm_watch(x) {
          var i2, k2, p, a;
          for (i2 = 0; i2 < x.inputs.added.length; i2++) {
            p = x.inputs.added[i2];
            if (!_inputMap.hasOwnProperty(p.id))
              _inputMap[p.id] = new _InputProxy(p.id, p.name, p.manufacturer, p.version);
            _inputMap[p.id].reconnect();
          }
          for (i2 = 0; i2 < x.outputs.added.length; i2++) {
            p = x.outputs.added[i2];
            if (!_outputMap.hasOwnProperty(p.id))
              _outputMap[p.id] = new _OutputProxy(p.id, p.name, p.manufacturer, p.version);
            _outputMap[p.id].reconnect();
          }
          for (i2 = 0; i2 < x.inputs.removed.length; i2++) {
            p = x.inputs.removed[i2];
            if (_inputMap.hasOwnProperty(p.id)) {
              a = [];
              for (k2 = 0; k2 < _wma.length; k2++)
                a.push([_wma[k2].inputs.get(p.id), _wma[k2]]);
              _inputMap[p.id].disconnect();
              for (k2 = 0; k2 < a.length; k2++)
                _statechange(a[k2][0], a[k2][1]);
            }
          }
          for (i2 = 0; i2 < x.outputs.removed.length; i2++) {
            p = x.outputs.removed[i2];
            if (_outputMap.hasOwnProperty(p.id)) {
              a = [];
              for (k2 = 0; k2 < _wma.length; k2++)
                a.push([_wma[k2].outputs.get(p.id), _wma[k2]]);
              _outputMap[p.id].disconnect();
              for (k2 = 0; k2 < a.length; k2++)
                _statechange(a[k2][0], a[k2][1]);
            }
          }
        }
        function MIDIAccess(sysex) {
          var _inputs = {};
          var _outputs = {};
          var _onstatechange = null;
          var self = this;
          this.sysexEnabled = sysex;
          this.inputs = new MIDIInputMap(self, _inputs);
          this.outputs = new MIDIOutputMap(self, _outputs);
          Object.defineProperty(this, "onstatechange", {
            get: function() {
              return _onstatechange;
            },
            set: function(f) {
              _onstatechange = _func(f) ? f : null;
            },
            enumerable: true
          });
          Object.freeze(this);
          var i2;
          var p;
          var info = _jzz._info;
          for (i2 = 0; i2 < info.inputs.length; i2++) {
            p = info.inputs[i2];
            if (!_inputMap.hasOwnProperty(p.id))
              _inputMap[p.id] = new _InputProxy(p.id, p.name, p.manufacturer, p.version);
          }
          for (i2 = 0; i2 < info.outputs.length; i2++) {
            p = info.outputs[i2];
            if (!_outputMap.hasOwnProperty(p.id))
              _outputMap[p.id] = new _OutputProxy(p.id, p.name, p.manufacturer, p.version);
          }
          if (!_wma.length)
            JZZ4().onChange(_wm_watch);
          _wma.push(this);
        }
        JZZ4.requestMIDIAccess = function(opt) {
          return new Promise2(function(resolve, reject) {
            JZZ4.JZZ(opt).or(function() {
            }).and(function() {
              var sysex = !!(opt && opt.sysex);
              if (sysex && !this.info().sysex)
                reject(new DOMException("SecurityError", "Sysex is not allowed", 18));
              else {
                var wma = new MIDIAccess(sysex);
                resolve(wma);
              }
            });
          });
        };
        if (typeof navigator !== "undefined" && !navigator.requestMIDIAccess)
          navigator.requestMIDIAccess = JZZ4.requestMIDIAccess;
        JZZ4.close = function() {
          if (_engine._close)
            _engine._close();
        };
        (function(JZZ5) {
          if (!JZZ5)
            return;
          if (!JZZ5.synth)
            JZZ5.synth = {};
          if (JZZ5.synth.Tiny)
            return;
          var _version2 = "1.3.2";
          function WebAudioTinySynth(opt) {
            this.__proto__ = this.sy = {
              is: "webaudio-tinysynth",
              properties: {
                masterVol: { type: Number, value: 0.5, observer: "setMasterVol" },
                reverbLev: { type: Number, value: 0.3, observer: "setReverbLev" },
                quality: { type: Number, value: 1, observer: "setQuality" },
                debug: { type: Number, value: 0 },
                src: { type: String, value: null, observer: "loadMIDIUrl" },
                loop: { type: Number, value: 0 },
                tsmode: { type: Number, value: 0 },
                voices: { type: Number, value: 64 },
                useReverb: { type: Number, value: 1 }
              },
              program: [],
              drummap: [],
              program1: [
                [{ w: "sine", v: 0.4, d: 0.7, r: 0.1 }, { w: "triangle", v: 3, d: 0.7, s: 0.1, g: 1, a: 0.01, k: -1.2 }],
                [{ w: "triangle", v: 0.4, d: 0.7, r: 0.1 }, { w: "triangle", v: 4, t: 3, d: 0.4, s: 0.1, g: 1, k: -1, a: 0.01 }],
                [{ w: "sine", d: 0.7, r: 0.1 }, { w: "triangle", v: 4, f: 2, d: 0.5, s: 0.5, g: 1, k: -1 }],
                [{ w: "sine", d: 0.7, v: 0.2 }, { w: "triangle", v: 4, t: 3, f: 2, d: 0.3, g: 1, k: -1, a: 0.01, s: 0.5 }],
                [{ w: "sine", v: 0.35, d: 0.7 }, { w: "sine", v: 3, t: 7, f: 1, d: 1, s: 1, g: 1, k: -0.7 }],
                [{ w: "sine", v: 0.35, d: 0.7 }, { w: "sine", v: 8, t: 7, f: 1, d: 0.5, s: 1, g: 1, k: -0.7 }],
                [{ w: "sawtooth", v: 0.34, d: 2 }, { w: "sine", v: 8, f: 0.1, d: 2, s: 1, r: 2, g: 1 }],
                [{ w: "triangle", v: 0.34, d: 1.5 }, { w: "square", v: 6, f: 0.1, d: 1.5, s: 0.5, r: 2, g: 1 }],
                [{ w: "sine", d: 0.3, r: 0.3 }, { w: "sine", v: 7, t: 11, d: 0.03, g: 1 }],
                [{ w: "sine", d: 0.3, r: 0.3 }, { w: "sine", v: 11, t: 6, d: 0.2, s: 0.4, g: 1 }],
                [{ w: "sine", v: 0.2, d: 0.3, r: 0.3 }, { w: "sine", v: 11, t: 5, d: 0.1, s: 0.4, g: 1 }],
                [{ w: "sine", v: 0.2, d: 0.6, r: 0.6 }, { w: "triangle", v: 11, t: 5, f: 1, s: 0.5, g: 1 }],
                [{ w: "sine", v: 0.3, d: 0.2, r: 0.2 }, { w: "sine", v: 6, t: 5, d: 0.02, g: 1 }],
                [{ w: "sine", v: 0.3, d: 0.2, r: 0.2 }, { w: "sine", v: 7, t: 11, d: 0.03, g: 1 }],
                [{ w: "sine", v: 0.2, d: 1, r: 1 }, { w: "sine", v: 11, t: 3.5, d: 1, r: 1, g: 1 }],
                [{ w: "triangle", v: 0.2, d: 0.5, r: 0.2 }, { w: "sine", v: 6, t: 2.5, d: 0.2, s: 0.1, r: 0.2, g: 1 }],
                [{ w: "w9999", v: 0.22, s: 0.9 }, { w: "w9999", v: 0.22, t: 2, f: 2, s: 0.9 }],
                [{ w: "w9999", v: 0.2, s: 1 }, { w: "sine", v: 11, t: 6, f: 2, s: 0.1, g: 1, h: 6e-3, r: 2e-3, d: 2e-3 }, { w: "w9999", v: 0.2, t: 2, f: 1, h: 0, s: 1 }],
                [{ w: "w9999", v: 0.2, d: 0.1, s: 0.9 }, { w: "w9999", v: 0.25, t: 4, f: 2, s: 0.5 }],
                [{ w: "w9999", v: 0.3, a: 0.04, s: 0.9 }, { w: "w9999", v: 0.2, t: 8, f: 2, a: 0.04, s: 0.9 }],
                [{ w: "sine", v: 0.2, a: 0.02, d: 0.05, s: 1 }, { w: "sine", v: 6, t: 3, f: 1, a: 0.02, d: 0.05, s: 1, g: 1 }],
                [{ w: "triangle", v: 0.2, a: 0.02, d: 0.05, s: 0.8 }, { w: "square", v: 7, t: 3, f: 1, d: 0.05, s: 1.5, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 0.2, s: 0.5 }, { w: "square", v: 1, d: 0.03, s: 2, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 0.1, s: 0.8 }, { w: "square", v: 1, a: 0.3, d: 0.1, s: 2, g: 1 }],
                [{ w: "sine", v: 0.3, d: 0.5, f: 1 }, { w: "triangle", v: 5, t: 3, f: -1, d: 1, s: 0.1, g: 1 }],
                [{ w: "sine", v: 0.4, d: 0.6, f: 1 }, { w: "triangle", v: 12, t: 3, d: 0.6, s: 0.1, g: 1, f: -1 }],
                [{ w: "triangle", v: 0.3, d: 1, f: 1 }, { w: "triangle", v: 6, f: -1, d: 0.4, s: 0.5, g: 1, t: 3 }],
                [{ w: "sine", v: 0.3, d: 1, f: -1 }, { w: "triangle", v: 11, f: 1, d: 0.4, s: 0.5, g: 1, t: 3 }],
                [{ w: "sine", v: 0.4, d: 0.1, r: 0.01 }, { w: "sine", v: 7, g: 1 }],
                [{ w: "triangle", v: 0.4, d: 1, f: 1 }, { w: "square", v: 4, f: -1, d: 1, s: 0.7, g: 1 }],
                [{ w: "triangle", v: 0.35, d: 1, f: 1 }, { w: "square", v: 7, f: -1, d: 0.3, s: 0.5, g: 1 }],
                [{ w: "sine", v: 0.2, t: 1.5, a: 5e-3, h: 0.2, d: 0.6 }, { w: "sine", v: 11, t: 5, f: 2, d: 1, s: 0.5, g: 1 }],
                [{ w: "sine", d: 0.3 }, { w: "sine", v: 4, t: 3, d: 1, s: 1, g: 1 }],
                [{ w: "sine", d: 0.3 }, { w: "sine", v: 4, t: 3, d: 1, s: 1, g: 1 }],
                [{ w: "w9999", d: 0.3, v: 0.7, s: 0.5 }, { w: "sawtooth", v: 1.2, d: 0.02, s: 0.5, g: 1, h: 0, r: 0.02 }],
                [{ w: "sine", d: 0.3 }, { w: "sine", v: 4, t: 3, d: 1, s: 1, g: 1 }],
                [{ w: "triangle", v: 0.3, t: 2, d: 1 }, { w: "triangle", v: 15, t: 2.5, d: 0.04, s: 0.1, g: 1 }],
                [{ w: "triangle", v: 0.3, t: 2, d: 1 }, { w: "triangle", v: 15, t: 2.5, d: 0.04, s: 0.1, g: 1 }],
                [{ w: "triangle", d: 0.7 }, { w: "square", v: 0.4, t: 0.5, f: 1, d: 0.2, s: 10, g: 1 }],
                [{ w: "triangle", d: 0.7 }, { w: "square", v: 0.4, t: 0.5, f: 1, d: 0.2, s: 10, g: 1 }],
                [{ w: "sawtooth", v: 0.4, a: 0.1, d: 11 }, { w: "sine", v: 5, d: 11, s: 0.2, g: 1 }],
                [{ w: "sawtooth", v: 0.4, a: 0.1, d: 11 }, { w: "sine", v: 5, d: 11, s: 0.2, g: 1 }],
                [{ w: "sawtooth", v: 0.4, a: 0.1, d: 11 }, { w: "sine", v: 5, t: 0.5, d: 11, s: 0.2, g: 1 }],
                [{ w: "sawtooth", v: 0.4, a: 0.1, d: 11 }, { w: "sine", v: 5, t: 0.5, d: 11, s: 0.2, g: 1 }],
                [{ w: "sine", v: 0.4, a: 0.1, d: 11 }, { w: "sine", v: 6, f: 2.5, d: 0.05, s: 1.1, g: 1 }],
                [{ w: "sine", v: 0.3, d: 0.1, r: 0.1 }, { w: "square", v: 4, t: 3, d: 1, s: 0.2, g: 1 }],
                [{ w: "sine", v: 0.3, d: 0.5, r: 0.5 }, { w: "sine", v: 7, t: 2, f: 2, d: 1, r: 1, g: 1 }],
                [{ w: "triangle", v: 0.6, h: 0.03, d: 0.3, r: 0.3, t: 0.5 }, { w: "n0", v: 8, t: 1.5, d: 0.08, r: 0.08, g: 1 }],
                [{ w: "sawtooth", v: 0.3, a: 0.03, s: 0.5 }, { w: "sawtooth", v: 0.2, t: 2, f: 2, d: 1, s: 2 }],
                [{ w: "sawtooth", v: 0.3, f: -2, a: 0.03, s: 0.5 }, { w: "sawtooth", v: 0.2, t: 2, f: 2, d: 1, s: 2 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }, { w: "sawtooth", v: 0.2, t: 2, f: 2, a: 1, d: 1, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }, { w: "sawtooth", v: 0.2, f: 2, a: 0.02, d: 1, s: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.03, s: 1 }, { w: "sine", v: 3, t: 5, f: 1, d: 1, s: 1, g: 1 }],
                [{ w: "sine", v: 0.4, a: 0.03, s: 0.9 }, { w: "sine", v: 1, t: 2, f: 3, d: 0.03, s: 0.2, g: 1 }],
                [{ w: "triangle", v: 0.6, a: 0.05, s: 0.5 }, { w: "sine", v: 1, f: 0.8, d: 0.2, s: 0.2, g: 1 }],
                [{ w: "square", v: 0.15, a: 0.01, d: 0.2, r: 0.2, t: 0.5, h: 0.03 }, { w: "square", v: 4, f: 0.5, d: 0.2, r: 11, a: 0.01, g: 1, h: 0.02 }, { w: "square", v: 0.15, t: 4, f: 1, a: 0.02, d: 0.15, r: 0.15, h: 0.03 }, { g: 3, w: "square", v: 4, f: -0.5, a: 0.01, h: 0.02, d: 0.15, r: 11 }],
                [{ w: "square", v: 0.2, a: 0.01, d: 1, s: 0.6, r: 0.04 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.5, r: 0.08 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.04, d: 1, s: 0.4, r: 0.08 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.15, a: 0.04, s: 1 }, { w: "sine", v: 2, d: 0.1, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.5, r: 0.08 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.6, r: 0.08 }, { w: "sine", v: 1, f: 0.2, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 0.5, s: 0.7, r: 0.08 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.5, r: 0.08 }, { w: "sine", v: 1, d: 0.1, s: 4, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 2, s: 0.6 }, { w: "sine", v: 2, d: 1, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 2, s: 0.6 }, { w: "sine", v: 2, d: 1, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.6 }, { w: "sine", v: 2, d: 1, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, d: 1, s: 0.6 }, { w: "sine", v: 2, d: 1, g: 1 }],
                [{ w: "sine", v: 0.4, a: 0.02, d: 0.7, s: 0.5 }, { w: "square", v: 5, t: 2, d: 0.2, s: 0.5, g: 1 }],
                [{ w: "sine", v: 0.3, a: 0.05, d: 0.2, s: 0.8 }, { w: "sawtooth", v: 6, f: 0.1, d: 0.1, s: 0.3, g: 1 }],
                [{ w: "sine", v: 0.3, a: 0.03, d: 0.2, s: 0.4 }, { w: "square", v: 7, f: 0.2, d: 1, s: 0.1, g: 1 }],
                [{ w: "square", v: 0.2, a: 0.05, d: 0.1, s: 0.8 }, { w: "square", v: 4, d: 0.1, s: 1.1, g: 1 }],
                [{ w: "sine", a: 0.02, d: 2 }, { w: "sine", v: 6, t: 2, d: 0.04, g: 1 }],
                [{ w: "sine", v: 0.7, a: 0.03, d: 0.4, s: 0.4 }, { w: "sine", v: 4, t: 2, f: 0.2, d: 0.4, g: 1 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 0.4, s: 0.6 }, { w: "sine", v: 3, t: 2, d: 0, s: 1, g: 1 }],
                [{ w: "sine", v: 0.4, a: 0.06, d: 0.3, s: 0.3 }, { w: "sine", v: 7, t: 2, d: 0.2, s: 0.2, g: 1 }],
                [{ w: "sine", a: 0.02, d: 0.3, s: 0.3 }, { w: "sawtooth", v: 3, t: 2, d: 0.3, g: 1 }],
                [{ w: "sine", v: 0.4, a: 0.02, d: 2, s: 0.1 }, { w: "sawtooth", v: 8, t: 2, f: 1, d: 0.5, g: 1 }],
                [{ w: "sine", v: 0.7, a: 0.03, d: 0.5, s: 0.3 }, { w: "sine", v: 3e-3, t: 0, f: 4, d: 0.1, s: 2e-3, g: 1 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }, { w: "sine", v: 1, t: 2, f: 1, d: 0.02, g: 1 }],
                [{ w: "square", v: 0.3, d: 1, s: 0.5 }, { w: "square", v: 1, f: 0.2, d: 1, s: 0.5, g: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 2, s: 0.5 }, { w: "square", v: 2, f: 0.1, s: 0.5, g: 1 }],
                [{ w: "triangle", v: 0.5, a: 0.05, d: 2, s: 0.6 }, { w: "sine", v: 4, t: 2, g: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.01, d: 2, s: 0.3 }, { w: "sine", v: 22, t: 2, f: 1, d: 0.03, s: 0.2, g: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 1, s: 0.5 }, { w: "sine", v: 11, t: 11, a: 0.2, d: 0.05, s: 0.3, g: 1 }],
                [{ w: "sine", v: 0.3, a: 0.06, d: 1, s: 0.5 }, { w: "sine", v: 7, f: 1, d: 1, s: 0.2, g: 1 }],
                [{ w: "sawtooth", v: 0.3, a: 0.03, d: 0.7, s: 0.3, r: 0.2 }, { w: "sawtooth", v: 0.3, t: 0.75, d: 0.7, a: 0.1, s: 0.3, r: 0.2 }],
                [{ w: "triangle", v: 0.3, a: 0.01, d: 0.7, s: 0.5 }, { w: "square", v: 5, t: 0.5, d: 0.7, s: 0.5, g: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.02, d: 0.3, s: 0.3, r: 0.3 }, { w: "square", v: 3, t: 4, f: 1, a: 0.02, d: 0.1, s: 1, g: 1 }, { w: "triangle", v: 0.08, t: 0.5, a: 0.1, h: 0, d: 0.1, s: 0.5, r: 0.1, b: 0, c: 0 }],
                [{ w: "sine", v: 0.3, a: 0.05, d: 1, s: 0.7, r: 0.3 }, { w: "sine", v: 2, f: 1, d: 0.3, s: 1, g: 1 }],
                [{ w: "square", v: 0.3, a: 0.03, d: 0.5, s: 0.3, r: 0.1 }, { w: "square", v: 4, f: 1, a: 0.03, d: 0.1, g: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.08, d: 1, s: 0.3, r: 0.1 }, { w: "square", v: 2, f: 1, d: 0.3, s: 0.3, g: 1, t: 4, a: 0.08 }],
                [{ w: "sine", v: 0.3, a: 0.05, d: 1, s: 0.3, r: 0.1 }, { w: "sine", v: 0.1, t: 2.001, f: 1, d: 1, s: 50, g: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.03, d: 0.7, s: 0.3, r: 0.2 }, { w: "sine", v: 12, t: 7, f: 1, d: 0.5, s: 1.7, g: 1 }],
                [{ w: "sine", v: 0.3, a: 0.05, d: 1, s: 0.3, r: 0.1 }, { w: "sawtooth", v: 22, t: 6, d: 0.06, s: 0.3, g: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.05, d: 11, r: 0.3 }, { w: "triangle", v: 1, d: 1, s: 8, g: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 4, s: 0.8, r: 0.1 }, { w: "square", v: 1, t: 2, f: 8, a: 1, d: 1, s: 1, r: 0.1, g: 1 }],
                [{ w: "triangle", v: 0.3, d: 1, s: 0.5, t: 0.8, a: 0.2, p: 1.25, q: 0.2 }, { w: "sawtooth", v: 0.2, a: 0.2, d: 0.3, s: 1, t: 1.2, p: 1.25, q: 0.2 }],
                [{ w: "sine", v: 0.3, d: 1, s: 0.3 }, { w: "square", v: 22, t: 11, d: 0.5, s: 0.1, g: 1 }],
                [{ w: "sawtooth", v: 0.3, a: 0.04, d: 1, s: 0.8, r: 0.1 }, { w: "square", v: 1, t: 0.5, d: 1, s: 2, g: 1 }],
                [{ w: "triangle", v: 0.3, d: 1, s: 0.3 }, { w: "sine", v: 22, t: 6, d: 0.6, s: 0.05, g: 1 }],
                [{ w: "sine", v: 0.6, a: 0.1, d: 0.05, s: 0.4 }, { w: "sine", v: 5, t: 5, f: 1, d: 0.05, s: 0.3, g: 1 }],
                [{ w: "sine", a: 0.1, d: 0.05, s: 0.4, v: 0.8 }, { w: "sine", v: 5, t: 5, f: 1, d: 0.05, s: 0.3, g: 1 }],
                [{ w: "square", v: 0.3, a: 0.1, d: 0.1, s: 0.4 }, { w: "square", v: 1, f: 1, d: 0.3, s: 0.1, g: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 0.5, r: 0.5 }, { w: "sawtooth", v: 11, t: 5, d: 0.05, g: 1 }],
                [{ w: "square", v: 0.3, d: 0.2, r: 0.2 }, { w: "square", v: 7, t: 3, d: 0.05, g: 1 }],
                [{ w: "triangle", d: 0.2, r: 0.2 }, { w: "square", v: 9, t: 3, d: 0.1, r: 0.1, g: 1 }],
                [{ w: "triangle", d: 0.3, r: 0.3 }, { w: "square", v: 6, t: 3, d: 1, r: 1, g: 1 }],
                [{ w: "triangle", v: 0.4, d: 0.2, r: 0.2 }, { w: "square", v: 22, t: 12, d: 0.1, r: 0.1, g: 1 }],
                [{ w: "sine", v: 0.25, a: 0.02, d: 0.05, s: 0.8 }, { w: "square", v: 1, t: 2, d: 0.03, s: 11, g: 1 }],
                [{ w: "sine", v: 0.3, a: 0.05, d: 11 }, { w: "square", v: 7, t: 3, f: 1, s: 0.7, g: 1 }],
                [{ w: "square", v: 0.3, a: 0.05, d: 0.1, s: 0.8 }, { w: "square", v: 4, d: 0.1, s: 1.1, g: 1 }],
                [{ w: "sine", v: 0.4, d: 0.3, r: 0.3 }, { w: "sine", v: 7, t: 9, d: 0.1, r: 0.1, g: 1 }],
                [{ w: "sine", v: 0.7, d: 0.1, r: 0.1 }, { w: "sine", v: 22, t: 7, d: 0.05, g: 1 }],
                [{ w: "sine", v: 0.6, d: 0.15, r: 0.15 }, { w: "square", v: 11, t: 3.2, d: 0.1, r: 0.1, g: 1 }],
                [{ w: "sine", v: 0.8, d: 0.07, r: 0.07 }, { w: "square", v: 11, t: 7, r: 0.01, g: 1 }],
                [{ w: "triangle", v: 0.7, t: 0.5, d: 0.2, r: 0.2, p: 0.95 }, { w: "n0", v: 9, g: 1, d: 0.2, r: 0.2 }],
                [{ w: "sine", v: 0.7, d: 0.1, r: 0.1, p: 0.9 }, { w: "square", v: 14, t: 2, d: 5e-3, r: 5e-3, g: 1 }],
                [{ w: "square", d: 0.15, r: 0.15, p: 0.5 }, { w: "square", v: 4, t: 5, d: 1e-3, r: 1e-3, g: 1 }],
                [{ w: "n1", v: 0.3, a: 1, s: 1, d: 0.15, r: 0, t: 0.5 }],
                [{ w: "sine", t: 12.5, d: 0, r: 0, p: 0.5, v: 0.3, h: 0.2, q: 0.5 }, { g: 1, w: "sine", v: 1, t: 2, d: 0, r: 0, s: 1 }, { g: 1, w: "n0", v: 0.2, t: 2, a: 0.6, h: 0, d: 0.1, r: 0.1, b: 0, c: 0 }],
                [{ w: "n0", v: 0.2, a: 0.05, h: 0.02, d: 0.02, r: 0.02 }],
                [{ w: "n0", v: 0.4, a: 1, d: 1, t: 0.25 }],
                [{ w: "sine", v: 0.3, a: 0.1, d: 1, s: 0.5 }, { w: "sine", v: 4, t: 0, f: 1.5, d: 1, s: 1, r: 0.1, g: 1 }, { g: 1, w: "sine", v: 4, t: 0, f: 2, a: 0.6, h: 0, d: 0.1, s: 1, r: 0.1, b: 0, c: 0 }],
                [{ w: "square", v: 0.3, t: 0.25, d: 11, s: 1 }, { w: "square", v: 12, t: 0, f: 8, d: 1, s: 1, r: 11, g: 1 }],
                [{ w: "n0", v: 0.4, t: 0.5, a: 1, d: 11, s: 1, r: 0.5 }, { w: "square", v: 1, t: 0, f: 14, d: 1, s: 1, r: 11, g: 1 }],
                [{ w: "sine", t: 0, f: 1221, a: 0.2, d: 1, r: 0.25, s: 1 }, { g: 1, w: "n0", v: 3, t: 0.5, d: 1, s: 1, r: 1 }],
                [{ w: "sine", d: 0.4, r: 0.4, p: 0.1, t: 2.5, v: 1 }, { w: "n0", v: 12, t: 2, d: 1, r: 1, g: 1 }]
              ],
              program0: [
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 0.7 }],
                [{ w: "sawtooth", v: 0.3, d: 0.7 }],
                [{ w: "sawtooth", v: 0.3, d: 0.7 }],
                [{ w: "sine", v: 0.5, d: 0.3, r: 0.3 }],
                [{ w: "triangle", v: 0.5, d: 0.3, r: 0.3 }],
                [{ w: "square", v: 0.2, d: 0.3, r: 0.3 }],
                [{ w: "square", v: 0.2, d: 0.3, r: 0.3 }],
                [{ w: "sine", v: 0.5, d: 0.1, r: 0.1 }],
                [{ w: "sine", v: 0.5, d: 0.1, r: 0.1 }],
                [{ w: "square", v: 0.2, d: 1, r: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 0.7, r: 0.7 }],
                [{ w: "sine", v: 0.5, a: 0.01, s: 1 }],
                [{ w: "sine", v: 0.7, d: 0.02, s: 0.7 }],
                [{ w: "square", v: 0.2, s: 1 }],
                [{ w: "triangle", v: 0.5, a: 0.01, s: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "square", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "square", v: 0.2, a: 0.05, s: 1 }],
                [{ w: "triangle", v: 0.5, d: 0.5 }],
                [{ w: "square", v: 0.2, d: 0.6 }],
                [{ w: "square", v: 0.2, d: 0.6 }],
                [{ w: "triangle", v: 0.8, d: 0.6 }],
                [{ w: "triangle", v: 0.4, d: 0.05 }],
                [{ w: "square", v: 0.2, d: 1 }],
                [{ w: "square", v: 0.2, d: 1 }],
                [{ w: "sine", v: 0.4, d: 0.6 }],
                [{ w: "triangle", v: 0.7, d: 0.4 }],
                [{ w: "triangle", v: 0.7, d: 0.7 }],
                [{ w: "triangle", v: 0.7, d: 0.7 }],
                [{ w: "triangle", v: 0.7, d: 0.7 }],
                [{ w: "square", v: 0.3, d: 0.2 }],
                [{ w: "square", v: 0.3, d: 0.2 }],
                [{ w: "square", v: 0.3, d: 0.1, s: 0.2 }],
                [{ w: "sawtooth", v: 0.4, d: 0.1, s: 0.2 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 0.1 }],
                [{ w: "sawtooth", v: 0.3, d: 0.5, r: 0.5 }],
                [{ w: "triangle", v: 0.6, d: 0.1, r: 0.1, h: 0.03, p: 0.8 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, s: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.03, s: 1 }],
                [{ w: "sine", v: 0.3, a: 0.03, s: 1 }],
                [{ w: "triangle", v: 0.3, a: 0.05, s: 1 }],
                [{ w: "sawtooth", v: 0.5, a: 0.01, d: 0.1 }],
                [{ w: "square", v: 0.3, a: 0.05, d: 0.2, s: 0.6 }],
                [{ w: "square", v: 0.3, a: 0.05, d: 0.2, s: 0.6 }],
                [{ w: "square", v: 0.3, a: 0.05, d: 0.2, s: 0.6 }],
                [{ w: "square", v: 0.2, a: 0.05, d: 0.01, s: 1 }],
                [{ w: "square", v: 0.3, a: 0.05, s: 1 }],
                [{ w: "square", v: 0.3, s: 0.7 }],
                [{ w: "square", v: 0.3, s: 0.7 }],
                [{ w: "square", v: 0.3, s: 0.7 }],
                [{ w: "square", v: 0.3, a: 0.02, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.02, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.03, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.04, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.02, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.05, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.03, d: 2 }],
                [{ w: "square", v: 0.3, a: 0.03, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "sine", v: 0.7, a: 0.02, d: 2 }],
                [{ w: "square", v: 0.3, s: 0.7 }],
                [{ w: "sawtooth", v: 0.4, s: 0.7 }],
                [{ w: "triangle", v: 0.5, s: 0.7 }],
                [{ w: "sawtooth", v: 0.4, s: 0.7 }],
                [{ w: "sawtooth", v: 0.4, d: 12 }],
                [{ w: "sine", v: 0.4, a: 0.06, d: 12 }],
                [{ w: "sawtooth", v: 0.4, d: 12 }],
                [{ w: "sawtooth", v: 0.4, d: 12 }],
                [{ w: "sawtooth", v: 0.3, d: 12 }],
                [{ w: "triangle", v: 0.5, d: 12 }],
                [{ w: "square", v: 0.3, d: 12 }],
                [{ w: "triangle", v: 0.5, a: 0.08, d: 11 }],
                [{ w: "sawtooth", v: 0.5, a: 0.05, d: 11 }],
                [{ w: "sawtooth", v: 0.5, d: 11 }],
                [{ w: "triangle", v: 0.5, d: 11 }],
                [{ w: "triangle", v: 0.5, d: 11 }],
                [{ w: "triangle", v: 0.5, d: 11 }],
                [{ w: "triangle", v: 0.5, d: 11 }],
                [{ w: "square", v: 0.3, d: 11 }],
                [{ w: "sawtooth", v: 0.5, a: 0.04, d: 11 }],
                [{ w: "sawtooth", v: 0.5, d: 11 }],
                [{ w: "triangle", v: 0.5, a: 0.8, d: 11 }],
                [{ w: "triangle", v: 0.5, d: 11 }],
                [{ w: "square", v: 0.3, d: 11 }],
                [{ w: "sawtooth", v: 0.3, d: 1, r: 1 }],
                [{ w: "sawtooth", v: 0.5, d: 0.3 }],
                [{ w: "sawtooth", v: 0.5, d: 0.3, r: 0.3 }],
                [{ w: "sawtooth", v: 0.5, d: 0.3, r: 0.3 }],
                [{ w: "square", v: 0.3, d: 0.2, r: 0.2 }],
                [{ w: "square", v: 0.3, a: 0.02, d: 2 }],
                [{ w: "sawtooth", v: 0.2, a: 0.02, d: 0.7 }],
                [{ w: "triangle", v: 0.5, d: 1 }],
                [{ w: "sawtooth", v: 0.3, d: 0.3, r: 0.3 }],
                [{ w: "sine", v: 0.8, d: 0.1, r: 0.1 }],
                [{ w: "square", v: 0.2, d: 0.1, r: 0.1, p: 1.05 }],
                [{ w: "sine", v: 0.8, d: 0.05, r: 0.05 }],
                [{ w: "triangle", v: 0.5, d: 0.1, r: 0.1, p: 0.96 }],
                [{ w: "triangle", v: 0.5, d: 0.1, r: 0.1, p: 0.97 }],
                [{ w: "square", v: 0.3, d: 0.1, r: 0.1 }],
                [{ w: "n1", v: 0.3, a: 1, s: 1, d: 0.15, r: 0, t: 0.5 }],
                [{ w: "triangle", v: 0.5, d: 0.03, t: 0, f: 1332, r: 1e-3, p: 1.1 }],
                [{ w: "n0", v: 0.2, t: 0.1, d: 0.02, a: 0.05, h: 0.02, r: 0.02 }],
                [{ w: "n0", v: 0.4, a: 1, d: 1, t: 0.25 }],
                [{ w: "sine", v: 0.3, a: 0.8, d: 1, t: 0, f: 1832 }],
                [{ w: "triangle", d: 0.5, t: 0, f: 444, s: 1 }],
                [{ w: "n0", v: 0.4, d: 1, t: 0, f: 22, s: 1 }],
                [{ w: "n0", v: 0.5, a: 0.2, d: 11, t: 0, f: 44 }],
                [{ w: "n0", v: 0.5, t: 0.25, d: 0.4, r: 0.4 }]
              ],
              drummap1: [
                [{ w: "triangle", t: 0, f: 70, v: 1, d: 0.05, h: 0.03, p: 0.9, q: 0.1 }, { w: "n0", g: 1, t: 6, v: 17, r: 0.01, h: 0, p: 0 }],
                [{ w: "triangle", t: 0, f: 88, v: 1, d: 0.05, h: 0.03, p: 0.5, q: 0.1 }, { w: "n0", g: 1, t: 5, v: 42, r: 0.01, h: 0, p: 0 }],
                [{ w: "n0", f: 222, p: 0, t: 0, r: 0.01, h: 0 }],
                [{ w: "triangle", v: 0.3, f: 180, d: 0.05, t: 0, h: 0.03, p: 0.9, q: 0.1 }, { w: "n0", v: 0.6, t: 0, f: 70, h: 0.02, r: 0.01, p: 0 }, { g: 1, w: "square", v: 2, t: 0, f: 360, r: 0.01, b: 0, c: 0 }],
                [{ w: "square", f: 1150, v: 0.34, t: 0, r: 0.03, h: 0.025, d: 0.03 }, { g: 1, w: "n0", t: 0, f: 13, h: 0.025, d: 0.1, s: 1, r: 0.1, v: 1 }],
                [{ w: "triangle", f: 200, v: 1, d: 0.06, t: 0, r: 0.06 }, { w: "n0", g: 1, t: 0, f: 400, v: 12, r: 0.02, d: 0.02 }],
                [{ w: "triangle", f: 100, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.4, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "n1", f: 390, v: 0.25, r: 0.01, t: 0 }],
                [{ w: "triangle", f: 120, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.5, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "n1", v: 0.25, f: 390, r: 0.03, t: 0, h: 5e-3, d: 0.03 }],
                [{ w: "triangle", f: 140, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.3, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "n1", v: 0.25, f: 390, t: 0, d: 0.2, r: 0.2 }, { w: "n0", v: 0.3, t: 0, c: 0, f: 440, h: 5e-3, d: 0.05 }],
                [{ w: "triangle", f: 155, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.3, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "triangle", f: 180, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.3, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "n1", v: 0.3, f: 1200, d: 0.2, r: 0.2, h: 0.05, t: 0 }, { w: "n1", t: 0, v: 1, d: 0.1, r: 0.1, p: 1.2, f: 440 }],
                [{ w: "triangle", f: 220, v: 0.9, d: 0.12, h: 0.02, p: 0.5, t: 0, r: 0.12 }, { g: 1, w: "n0", v: 5, t: 0.3, h: 0.015, d: 5e-3, r: 5e-3 }],
                [{ w: "n1", f: 500, v: 0.15, d: 0.4, r: 0.4, h: 0, t: 0 }, { w: "n0", v: 0.1, t: 0, r: 0.01, f: 440 }],
                [{ w: "n1", v: 0.3, f: 800, d: 0.2, r: 0.2, h: 0.05, t: 0 }, { w: "square", t: 0, v: 1, d: 0.1, r: 0.1, p: 0.1, f: 220, g: 1 }],
                [{ w: "sine", f: 1651, v: 0.15, d: 0.2, r: 0.2, h: 0, t: 0 }, { w: "sawtooth", g: 1, t: 1.21, v: 7.2, d: 0.1, r: 11, h: 1 }, { g: 1, w: "n0", v: 3.1, t: 0.152, d: 2e-3, r: 2e-3 }],
                null,
                [{ w: "n1", v: 0.3, f: 1200, d: 0.2, r: 0.2, h: 0.05, t: 0 }, { w: "n1", t: 0, v: 1, d: 0.1, r: 0.1, p: 1.2, f: 440 }],
                null,
                [{ w: "n1", v: 0.3, f: 555, d: 0.25, r: 0.25, h: 0.05, t: 0 }, { w: "n1", t: 0, v: 1, d: 0.1, r: 0.1, f: 440, a: 5e-3, h: 0.02 }],
                [{ w: "sawtooth", f: 776, v: 0.2, d: 0.3, t: 0, r: 0.3 }, { g: 1, w: "n0", v: 2, t: 0, f: 776, a: 5e-3, h: 0.02, d: 0.1, s: 1, r: 0.1, c: 0 }, { g: 11, w: "sine", v: 0.1, t: 0, f: 22, d: 0.3, r: 0.3, b: 0, c: 0 }],
                [{ w: "n1", f: 440, v: 0.15, d: 0.4, r: 0.4, h: 0, t: 0 }, { w: "n0", v: 0.4, t: 0, r: 0.01, f: 440 }],
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                [{ w: "sine", f: 1720, v: 0.3, d: 0.02, t: 0, r: 0.02 }, { w: "square", g: 1, t: 0, f: 2876, v: 6, d: 0.2, s: 1, r: 0.2 }],
                [{ w: "sine", f: 1720, v: 0.3, d: 0.25, t: 0, r: 0.25 }, { w: "square", g: 1, t: 0, f: 2876, v: 6, d: 0.2, s: 1, r: 0.2 }]
              ],
              drummap0: [
                [{ w: "triangle", t: 0, f: 110, v: 1, d: 0.05, h: 0.02, p: 0.1 }],
                [{ w: "triangle", t: 0, f: 150, v: 0.8, d: 0.1, p: 0.1, h: 0.02, r: 0.01 }],
                [{ w: "n0", f: 392, v: 0.5, d: 0.01, p: 0, t: 0, r: 0.05 }],
                [{ w: "n0", f: 33, d: 0.05, t: 0 }],
                [{ w: "n0", f: 100, v: 0.7, d: 0.03, t: 0, r: 0.03, h: 0.02 }],
                [{ w: "n0", f: 44, v: 0.7, d: 0.02, p: 0.1, t: 0, h: 0.02 }],
                [{ w: "triangle", f: 240, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "n0", f: 440, v: 0.2, r: 0.01, t: 0 }],
                [{ w: "triangle", f: 270, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "n0", f: 440, v: 0.2, d: 0.04, r: 0.04, t: 0 }],
                [{ w: "triangle", f: 300, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "n0", f: 440, v: 0.2, d: 0.1, r: 0.1, h: 0.02, t: 0 }],
                [{ w: "triangle", f: 320, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "triangle", f: 360, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "n0", f: 150, v: 0.2, d: 0.1, r: 0.1, h: 0.05, t: 0, p: 0.1 }],
                [{ w: "triangle", f: 400, v: 0.9, d: 0.1, h: 0.02, p: 0.1, t: 0 }],
                [{ w: "n0", f: 150, v: 0.2, d: 0.1, r: 0.01, h: 0.05, t: 0, p: 0.1 }],
                [{ w: "n0", f: 150, v: 0.2, d: 0.1, r: 0.01, h: 0.05, t: 0, p: 0.1 }],
                [{ w: "n0", f: 440, v: 0.3, d: 0.1, p: 0.9, t: 0, r: 0.1 }],
                [{ w: "n0", f: 200, v: 0.2, d: 0.05, p: 0.9, t: 0 }],
                [{ w: "n0", f: 440, v: 0.3, d: 0.12, p: 0.9, t: 0 }],
                [{ w: "sine", f: 800, v: 0.4, d: 0.06, t: 0 }],
                [{ w: "n0", f: 150, v: 0.2, d: 0.1, r: 0.01, h: 0.05, t: 0, p: 0.1 }],
                [{ w: "n0", f: 33, v: 0.3, d: 0.2, p: 0.9, t: 0 }],
                [{ w: "n0", f: 300, v: 0.3, d: 0.14, p: 0.9, t: 0 }],
                [{ w: "sine", f: 200, d: 0.06, t: 0 }],
                [{ w: "sine", f: 150, d: 0.06, t: 0 }],
                [{ w: "sine", f: 300, t: 0 }],
                [{ w: "sine", f: 300, d: 0.06, t: 0 }],
                [{ w: "sine", f: 250, d: 0.06, t: 0 }],
                [{ w: "square", f: 300, v: 0.3, d: 0.06, p: 0.8, t: 0 }],
                [{ w: "square", f: 260, v: 0.3, d: 0.06, p: 0.8, t: 0 }],
                [{ w: "sine", f: 850, v: 0.5, d: 0.07, t: 0 }],
                [{ w: "sine", f: 790, v: 0.5, d: 0.07, t: 0 }],
                [{ w: "n0", f: 440, v: 0.3, a: 0.05, t: 0 }],
                [{ w: "n0", f: 440, v: 0.3, a: 0.05, t: 0 }],
                [{ w: "triangle", f: 1800, v: 0.4, p: 0.9, t: 0, h: 0.03 }],
                [{ w: "triangle", f: 1800, v: 0.3, p: 0.9, t: 0, h: 0.13 }],
                [{ w: "n0", f: 330, v: 0.3, a: 0.02, t: 0, r: 0.01 }],
                [{ w: "n0", f: 330, v: 0.3, a: 0.02, t: 0, h: 0.04, r: 0.01 }],
                [{ w: "n0", f: 440, v: 0.3, t: 0 }],
                [{ w: "sine", f: 800, t: 0 }],
                [{ w: "sine", f: 700, t: 0 }],
                [{ w: "n0", f: 330, v: 0.3, t: 0 }],
                [{ w: "n0", f: 330, v: 0.3, t: 0, h: 0.1, r: 0.01, p: 0.7 }],
                [{ w: "sine", t: 0, f: 1200, v: 0.3, r: 0.01 }],
                [{ w: "sine", t: 0, f: 1200, v: 0.3, d: 0.2, r: 0.2 }]
              ],
              ready: function() {
                var i2;
                this.pg = [];
                this.vol = [];
                this.ex = [];
                this.bend = [];
                this.rpnidx = [];
                this.brange = [];
                this.sustain = [];
                this.notetab = [];
                this.rhythm = [];
                this.masterTuningC = 0;
                this.masterTuningF = 0;
                this.tuningC = [];
                this.tuningF = [];
                this.scaleTuning = [];
                this.maxTick = 0, this.playTick = 0, this.playing = 0;
                this.releaseRatio = 3.5;
                for (var i2 = 0; i2 < 16; ++i2) {
                  this.pg[i2] = 0;
                  this.vol[i2] = 3 * 100 * 100 / (127 * 127);
                  this.bend[i2] = 0;
                  this.brange[i2] = 256;
                  this.tuningC[i2] = 0;
                  this.tuningF[i2] = 0;
                  this.scaleTuning[i2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                  this.rhythm[i2] = 0;
                }
                this.rhythm[9] = 1;
                this.preroll = 0.2;
                this.relcnt = 0;
                setInterval(
                  function() {
                    if (++this.relcnt >= 3) {
                      this.relcnt = 0;
                      for (var i3 = this.notetab.length - 1; i3 >= 0; --i3) {
                        var nt = this.notetab[i3];
                        if (this.actx.currentTime > nt.e) {
                          this._pruneNote(nt);
                          this.notetab.splice(i3, 1);
                        }
                      }
                    }
                    if (this.playing && this.song.ev.length > 0) {
                      var e = this.song.ev[this.playIndex];
                      while (this.actx.currentTime + this.preroll > this.playTime) {
                        if (e.m[0] == 65361) {
                          this.song.tempo = e.m[1];
                          this.tick2Time = 4 * 60 / this.song.tempo / this.song.timebase;
                        } else
                          this.send(e.m, this.playTime);
                        ++this.playIndex;
                        if (this.playIndex >= this.song.ev.length) {
                          if (this.loop) {
                            e = this.song.ev[this.playIndex = 0];
                            this.playTick = e.t;
                          } else {
                            this.playTick = this.maxTick;
                            this.playing = 0;
                            break;
                          }
                        } else {
                          e = this.song.ev[this.playIndex];
                          this.playTime += (e.t - this.playTick) * this.tick2Time;
                          this.playTick = e.t;
                        }
                      }
                    }
                  }.bind(this),
                  60
                );
                this.isReady = 1;
              },
              setMasterVol: function(v) {
                if (v != void 0)
                  this.masterVol = v;
                if (this.out)
                  this.out.gain.value = this.masterVol;
              },
              setReverbLev: function(v) {
                if (v != void 0)
                  this.reverbLev = v;
                var r = parseFloat(this.reverbLev);
                if (this.rev && !isNaN(r))
                  this.rev.gain.value = r * 8;
              },
              setLoop: function(f) {
                this.loop = f;
              },
              setVoices: function(v) {
                this.voices = v;
              },
              reset: function() {
                for (var i2 = 0; i2 < 16; ++i2) {
                  this.setProgram(i2, 0);
                  this.setBendRange(i2, 256);
                  this.setModulation(i2, 0);
                  this.setChVol(i2, 100);
                  this.setPan(i2, 64);
                  this.resetAllControllers(i2);
                  this.allSoundOff(i2);
                  this.rhythm[i2] = 0;
                  this.tuningC[i2] = 0;
                  this.tuningF[i2] = 0;
                  this.scaleTuning[i2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
                this.masterTuningC = 0;
                this.masterTuningF = 0;
                this.rhythm[9] = 1;
              },
              setQuality: function(q) {
                var i2, k3, n2, p;
                if (q != void 0)
                  this.quality = q;
                for (i2 = 0; i2 < 128; ++i2)
                  this.setTimbre(0, i2, this.program0[i2]);
                for (i2 = 0; i2 < this.drummap0.length; ++i2)
                  this.setTimbre(1, i2 + 35, this.drummap0[i2]);
                if (this.quality) {
                  for (i2 = 0; i2 < this.program1.length; ++i2)
                    this.setTimbre(0, i2, this.program1[i2]);
                  for (i2 = 0; i2 < this.drummap.length; ++i2) {
                    if (this.drummap1[i2])
                      this.setTimbre(1, i2 + 35, this.drummap1[i2]);
                  }
                }
              },
              setTimbre: function(m2, n2, p) {
                var defp = { g: 0, w: "sine", t: 1, f: 0, v: 0.5, a: 0, h: 0.01, d: 0.01, s: 0, r: 0.05, p: 1, q: 1, k: 0 };
                function filldef(p2) {
                  for (n2 = 0; n2 < p2.length; ++n2) {
                    for (k2 in defp) {
                      if (!p2[n2].hasOwnProperty(k2) || typeof p2[n2][k2] == "undefined")
                        p2[n2][k2] = defp[k2];
                    }
                  }
                  return p2;
                }
                if (m2 && n2 >= 35 && n2 <= 81)
                  this.drummap[n2 - 35] = filldef(p);
                if (m2 == 0 && n2 >= 0 && n2 <= 127)
                  this.program[n2] = filldef(p);
              },
              _pruneNote: function(nt) {
                for (var k3 = nt.o.length - 1; k3 >= 0; --k3) {
                  if (nt.o[k3].frequency) {
                    nt.o[k3].frequency.cancelScheduledValues(0);
                  } else {
                    nt.o[k3].playbackRate.cancelScheduledValues(0);
                  }
                  nt.g[k3].gain.cancelScheduledValues(0);
                  nt.o[k3].stop();
                  if (nt.o[k3].detune) {
                    try {
                      this.chmod[nt.ch].disconnect(nt.o[k3].detune);
                    } catch (c) {
                    }
                  }
                  nt.g[k3].gain.value = 0;
                }
              },
              _limitVoices: function(ch, n2) {
                this.notetab.sort(function(n1, n22) {
                  if (n1.f != n22.f)
                    return n1.f - n22.f;
                  if (n1.e != n22.e)
                    return n22.e - n1.e;
                  return n22.t - n1.t;
                });
                for (var i2 = this.notetab.length - 1; i2 >= 0; --i2) {
                  var nt = this.notetab[i2];
                  if (this.actx.currentTime > nt.e || i2 >= this.voices - 1) {
                    this._pruneNote(nt);
                    this.notetab.splice(i2, 1);
                  }
                }
              },
              _note: function(t, ch, n2, v, p) {
                var out, sc, pn;
                var o = [], g = [], vp = [], fp = [], r = [];
                var f = 440 * Math.pow(2, (n2 - 69 + this.masterTuningC + this.tuningC[ch] + (this.masterTuningF + this.tuningF[ch] / 8192 + this.scaleTuning[ch][n2 % 12])) / 12);
                this._limitVoices(ch, n2);
                for (var i2 = 0; i2 < p.length; ++i2) {
                  pn = p[i2];
                  var dt = t + pn.a + pn.h;
                  if (pn.g == 0)
                    out = this.chvol[ch], sc = v * v / 16384, fp[i2] = f * pn.t + pn.f;
                  else if (pn.g > 10)
                    out = g[pn.g - 11].gain, sc = 1, fp[i2] = fp[pn.g - 11] * pn.t + pn.f;
                  else if (o[pn.g - 1].frequency)
                    out = o[pn.g - 1].frequency, sc = fp[pn.g - 1], fp[i2] = fp[pn.g - 1] * pn.t + pn.f;
                  else
                    out = o[pn.g - 1].playbackRate, sc = fp[pn.g - 1] / 440, fp[i2] = fp[pn.g - 1] * pn.t + pn.f;
                  switch (pn.w[0]) {
                    case "n":
                      o[i2] = this.actx.createBufferSource();
                      o[i2].buffer = this.noiseBuf[pn.w];
                      o[i2].loop = true;
                      o[i2].playbackRate.value = fp[i2] / 440;
                      if (pn.p != 1)
                        this._setParamTarget(o[i2].playbackRate, fp[i2] / 440 * pn.p, t, pn.q);
                      if (o[i2].detune) {
                        this.chmod[ch].connect(o[i2].detune);
                        o[i2].detune.value = this.bend[ch];
                      }
                      break;
                    default:
                      o[i2] = this.actx.createOscillator();
                      o[i2].frequency.value = fp[i2];
                      if (pn.p != 1)
                        this._setParamTarget(o[i2].frequency, fp[i2] * pn.p, t, pn.q);
                      if (pn.w[0] == "w")
                        o[i2].setPeriodicWave(this.wave[pn.w]);
                      else
                        o[i2].type = pn.w;
                      if (o[i2].detune) {
                        this.chmod[ch].connect(o[i2].detune);
                        o[i2].detune.value = this.bend[ch];
                      }
                      break;
                  }
                  g[i2] = this.actx.createGain();
                  r[i2] = pn.r;
                  o[i2].connect(g[i2]);
                  g[i2].connect(out);
                  vp[i2] = sc * pn.v;
                  if (pn.k)
                    vp[i2] *= Math.pow(2, (n2 - 60) / 12 * pn.k);
                  if (pn.a) {
                    g[i2].gain.value = 0;
                    g[i2].gain.setValueAtTime(0, t);
                    g[i2].gain.linearRampToValueAtTime(vp[i2], t + pn.a);
                  } else
                    g[i2].gain.setValueAtTime(vp[i2], t);
                  this._setParamTarget(g[i2].gain, pn.s * vp[i2], dt, pn.d);
                  o[i2].start(t);
                  if (this.rhythm[ch]) {
                    o[i2].onended = function(a, b) {
                      return function() {
                        if (b)
                          a.disconnect(b);
                      };
                    }(this.chmod[ch], o[i2].detune);
                    o[i2].stop(t + p[0].d * this.releaseRatio);
                  }
                }
                if (!this.rhythm[ch])
                  this.notetab.push({ t, e: 99999, ch, n: n2, o, g, t2: t + pn.a, v: vp, r, f: 0 });
              },
              _setParamTarget: function(p, v, t, d) {
                if (d != 0)
                  p.setTargetAtTime(v, t, d);
                else
                  p.setValueAtTime(v, t);
              },
              _releaseNote: function(nt, t) {
                if (nt.ch != 9) {
                  for (var k3 = nt.g.length - 1; k3 >= 0; --k3) {
                    nt.g[k3].gain.cancelScheduledValues(t);
                    if (t == nt.t2)
                      nt.g[k3].gain.setValueAtTime(nt.v[k3], t);
                    else if (t < nt.t2)
                      nt.g[k3].gain.setValueAtTime(nt.v[k3] * (t - nt.t) / (nt.t2 - nt.t), t);
                    this._setParamTarget(nt.g[k3].gain, 0, t, nt.r[k3]);
                  }
                }
                nt.e = t + nt.r[0] * this.releaseRatio;
                nt.f = 1;
              },
              setModulation: function(ch, v, t) {
                this.chmod[ch].gain.setValueAtTime(v * 100 / 127, this._tsConv(t));
              },
              setChVol: function(ch, v, t) {
                this.vol[ch] = 3 * v * v / (127 * 127);
                this.chvol[ch].gain.setValueAtTime(this.vol[ch] * this.ex[ch], this._tsConv(t));
              },
              setPan: function(ch, v, t) {
                if (this.chpan[ch])
                  this.chpan[ch].pan.setValueAtTime((v - 64) / 64, this._tsConv(t));
              },
              setExpression: function(ch, v, t) {
                this.ex[ch] = v * v / (127 * 127);
                this.chvol[ch].gain.setValueAtTime(this.vol[ch] * this.ex[ch], this._tsConv(t));
              },
              setSustain: function(ch, v, t) {
                this.sustain[ch] = v;
                t = this._tsConv(t);
                if (v < 64) {
                  for (var i2 = this.notetab.length - 1; i2 >= 0; --i2) {
                    var nt = this.notetab[i2];
                    if (t >= nt.t && nt.ch == ch && nt.f == 1)
                      this._releaseNote(nt, t);
                  }
                }
              },
              allSoundOff: function(ch) {
                for (var i2 = this.notetab.length - 1; i2 >= 0; --i2) {
                  var nt = this.notetab[i2];
                  if (nt.ch == ch) {
                    this._pruneNote(nt);
                    this.notetab.splice(i2, 1);
                  }
                }
              },
              resetAllControllers: function(ch) {
                this.bend[ch] = 0;
                this.ex[ch] = 1;
                this.rpnidx[ch] = 16383;
                this.sustain[ch] = 0;
                if (this.chvol[ch]) {
                  this.chvol[ch].gain.value = this.vol[ch] * this.ex[ch];
                  this.chmod[ch].gain.value = 0;
                }
              },
              setBendRange: function(ch, v) {
                this.brange[ch] = v;
              },
              setProgram: function(ch, v) {
                if (this.debug)
                  console.log("Pg(" + ch + ")=" + v);
                this.pg[ch] = v;
              },
              setBend: function(ch, v, t) {
                t = this._tsConv(t);
                var br = this.brange[ch] * 100 / 127;
                this.bend[ch] = (v - 8192) * br / 8192;
                for (var i2 = this.notetab.length - 1; i2 >= 0; --i2) {
                  var nt = this.notetab[i2];
                  if (nt.ch == ch) {
                    for (var k3 = nt.o.length - 1; k3 >= 0; --k3) {
                      if (nt.o[k3].frequency) {
                        if (nt.o[k3].detune)
                          nt.o[k3].detune.setValueAtTime(this.bend[ch], t);
                      }
                    }
                  }
                }
              },
              noteOn: function(ch, n2, v, t) {
                if (v == 0) {
                  this.noteOff(ch, n2, t);
                  return;
                }
                t = this._tsConv(t);
                if (this.rhythm[ch]) {
                  if (n2 >= 35 && n2 <= 81)
                    this._note(t, ch, n2, v, this.drummap[n2 - 35]);
                  return;
                }
                this._note(t, ch, n2, v, this.program[this.pg[ch]]);
              },
              noteOff: function(ch, n2, t) {
                if (this.rhythm[ch])
                  return;
                t = this._tsConv(t);
                for (var i2 = this.notetab.length - 1; i2 >= 0; --i2) {
                  var nt = this.notetab[i2];
                  if (t >= nt.t && nt.ch == ch && nt.n == n2 && nt.f == 0) {
                    nt.f = 1;
                    if (this.sustain[ch] < 64)
                      this._releaseNote(nt, t);
                  }
                }
              },
              _tsConv: function(t) {
                if (t == void 0 || t <= 0) {
                  t = 0;
                  if (this.actx)
                    t = this.actx.currentTime;
                } else {
                  if (this.tsmode)
                    t = t * 1e-3 - this.tsdiff;
                }
                return t;
              },
              setTsMode: function(tsmode) {
                this.tsmode = tsmode;
              },
              send: function(msg2, t) {
                var ch = msg2[0] & 15;
                var cmd = msg2[0] & ~15;
                if (cmd < 128 || cmd >= 256)
                  return;
                if (this.audioContext.state == "suspended") {
                  this.audioContext.resume();
                }
                switch (cmd) {
                  case 176:
                    switch (msg2[1]) {
                      case 1:
                        this.setModulation(ch, msg2[2], t);
                        break;
                      case 7:
                        this.setChVol(ch, msg2[2], t);
                        break;
                      case 10:
                        this.setPan(ch, msg2[2], t);
                        break;
                      case 11:
                        this.setExpression(ch, msg2[2], t);
                        break;
                      case 64:
                        this.setSustain(ch, msg2[2], t);
                        break;
                      case 98:
                      case 99:
                        this.rpnidx[ch] = 16383;
                        break;
                      case 100:
                        this.rpnidx[ch] = this.rpnidx[ch] & 16256 | msg2[2];
                        break;
                      case 101:
                        this.rpnidx[ch] = this.rpnidx[ch] & 127 | msg2[2] << 7;
                        break;
                      case 6:
                        switch (this.rpnidx[ch]) {
                          case 0:
                            this.brange[ch] = (msg2[2] << 7) + (this.brange[ch] & 127);
                            break;
                          case 1:
                            this.tuningF[ch] = (msg2[2] << 7) + (this.tuningF[ch] + 8192 & 127) - 8192;
                            break;
                          case 2:
                            this.tuningC[ch] = msg2[2] - 64;
                            break;
                        }
                        break;
                      case 38:
                        switch (this.rpnidx[ch]) {
                          case 0:
                            this.brange[ch] = this.brange[ch] & 16256 | msg2[2];
                            break;
                          case 1:
                            this.tuningF[ch] = (this.tuningF[ch] + 8192 & 16256 | msg2[2]) - 8192;
                            break;
                          case 2:
                            break;
                        }
                        break;
                      case 120:
                      case 123:
                      case 124:
                      case 125:
                      case 126:
                      case 127:
                        this.allSoundOff(ch);
                        break;
                      case 121:
                        this.resetAllControllers(ch);
                        break;
                    }
                    break;
                  case 192:
                    this.setProgram(ch, msg2[1]);
                    break;
                  case 224:
                    this.setBend(ch, msg2[1] + (msg2[2] << 7), t);
                    break;
                  case 144:
                    this.noteOn(ch, msg2[1], msg2[2], t);
                    break;
                  case 128:
                    this.noteOff(ch, msg2[1], t);
                    break;
                  case 240:
                    if (msg2[0] == 255) {
                      this.reset();
                      break;
                    }
                    if (msg2[0] != 254 && this.debug) {
                      var ds = [];
                      for (var ii = 0; ii < msg2.length; ++ii)
                        ds.push(msg2[ii].toString(16));
                    }
                    if (msg2[0] == 240) {
                      if (msg2[1] == 127 && msg2[3] == 4) {
                        if (msg2[4] == 3 && msg2.length >= 8) {
                          this.masterTuningF = (msg2[6] * 128 + msg2[5] - 8192) / 8192;
                        }
                        if (msg2[4] == 4 && msg2.length >= 8) {
                          this.masterTuningC = msg2[6] - 64;
                        }
                      }
                      if (msg2[1] == 65 && msg2[3] == 66 && msg2[4] == 18 && msg2[5] == 64) {
                        if ((msg2[6] & 240) == 16 && msg2.length == 11) {
                          var c = [9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15][msg2[6] & 15];
                          if (msg2[7] == 21) {
                            this.rhythm[c] = msg2[8];
                          } else if (msg2[7] >= 64 && msg2[7] <= 75) {
                            this.scaleTuning[c][msg2[7] - 64] = (msg2[8] - 64) / 100;
                          }
                        } else if (msg2[6] == 0) {
                          if (msg2[7] == 0 && msg2.length == 14) {
                            this.masterTuningF = (msg2[8] * 4096 + msg2[9] * 256 + msg2[10] * 16 + msg2[11] - 1024) / 1e3;
                          } else if (msg2[7] == 5 && msg2.length == 11) {
                            this.masterTuningC = msg2[8] - 64;
                          }
                        }
                      }
                    }
                    break;
                }
              },
              _createWave: function(w) {
                var imag = new Float32Array(w.length);
                var real2 = new Float32Array(w.length);
                for (var i2 = 1; i2 < w.length; ++i2)
                  imag[i2] = w[i2];
                return this.actx.createPeriodicWave(real2, imag);
              },
              getAudioContext: function() {
                return this.actx;
              },
              setAudioContext: function(actx, dest) {
                this.audioContext = this.actx = actx;
                this.dest = dest;
                if (!dest)
                  this.dest = actx.destination;
                this.tsdiff = performance.now() * 1e-3 - this.actx.currentTime;
                this.out = this.actx.createGain();
                this.comp = this.actx.createDynamicsCompressor();
                var blen = this.actx.sampleRate * 0.5 | 0;
                this.convBuf = this.actx.createBuffer(2, blen, this.actx.sampleRate);
                this.noiseBuf = {};
                this.noiseBuf.n0 = this.actx.createBuffer(1, blen, this.actx.sampleRate);
                this.noiseBuf.n1 = this.actx.createBuffer(1, blen, this.actx.sampleRate);
                var d1 = this.convBuf.getChannelData(0);
                var d2 = this.convBuf.getChannelData(1);
                var dn = this.noiseBuf.n0.getChannelData(0);
                var dr = this.noiseBuf.n1.getChannelData(0);
                for (var i2 = 0; i2 < blen; ++i2) {
                  if (i2 / blen < Math.random()) {
                    d1[i2] = Math.exp(-3 * i2 / blen) * (Math.random() - 0.5) * 0.5;
                    d2[i2] = Math.exp(-3 * i2 / blen) * (Math.random() - 0.5) * 0.5;
                  }
                  dn[i2] = Math.random() * 2 - 1;
                }
                for (var jj = 0; jj < 64; ++jj) {
                  var r1 = Math.random() * 10 + 1;
                  var r2 = Math.random() * 10 + 1;
                  for (i2 = 0; i2 < blen; ++i2) {
                    var dd = Math.sin(i2 / blen * 2 * Math.PI * 440 * r1) * Math.sin(i2 / blen * 2 * Math.PI * 440 * r2);
                    dr[i2] += dd / 8;
                  }
                }
                if (this.useReverb) {
                  this.conv = this.actx.createConvolver();
                  this.conv.buffer = this.convBuf;
                  this.rev = this.actx.createGain();
                  this.rev.gain.value = this.reverbLev;
                  this.out.connect(this.conv);
                  this.conv.connect(this.rev);
                  this.rev.connect(this.comp);
                }
                this.setMasterVol();
                this.out.connect(this.comp);
                this.comp.connect(this.dest);
                this.chvol = [];
                this.chmod = [];
                this.chpan = [];
                this.wave = { "w9999": this._createWave("w9999") };
                this.lfo = this.actx.createOscillator();
                this.lfo.frequency.value = 5;
                this.lfo.start(0);
                for (i2 = 0; i2 < 16; ++i2) {
                  this.chvol[i2] = this.actx.createGain();
                  if (this.actx.createStereoPanner) {
                    this.chpan[i2] = this.actx.createStereoPanner();
                    this.chvol[i2].connect(this.chpan[i2]);
                    this.chpan[i2].connect(this.out);
                  } else {
                    this.chpan[i2] = null;
                    this.chvol[i2].connect(this.out);
                  }
                  this.chmod[i2] = this.actx.createGain();
                  this.lfo.connect(this.chmod[i2]);
                  this.pg[i2] = 0;
                  this.resetAllControllers(i2);
                }
                this.setReverbLev();
                this.reset();
              }
            };
            for (var k2 in this.sy.properties)
              this[k2] = this.sy.properties[k2].value;
            this.setQuality(1);
            if (opt) {
              if (opt.useReverb != void 0)
                this.useReverb = opt.useReverb;
              if (opt.quality != void 0)
                this.setQuality(opt.quality);
              if (opt.voices != void 0)
                this.setVoices(opt.voices);
            }
            this.ready();
          }
          function _clone2(obj, key, val) {
            if (typeof key == "undefined")
              return _clone2(obj, [], []);
            if (obj instanceof Object) {
              for (var i2 = 0; i2 < key.length; i2++)
                if (key[i2] === obj)
                  return val[i2];
              var ret;
              if (obj instanceof Array)
                ret = [];
              else
                ret = {};
              key.push(obj);
              val.push(ret);
              for (var k2 in obj)
                if (obj.hasOwnProperty(k2))
                  ret[k2] = _clone2(obj[k2], key, val);
              return ret;
            }
            return obj;
          }
          var _ac2;
          function initAC() {
            if (!_ac2)
              _ac2 = JZZ5.lib.getAudioContext();
            return !!_ac2;
          }
          var _synth = {};
          var _noname = [];
          var _engine2 = {};
          _engine2._info = function(name2) {
            if (!name2)
              name2 = "JZZ.synth.Tiny";
            return {
              type: "Web Audio",
              name: name2,
              manufacturer: "virtual",
              version: _version2
            };
          };
          _engine2._openOut = function(port, name2) {
            initAC();
            if (!_ac2) {
              port._crash("AudioContext not supported");
              return;
            }
            var synth2;
            if (typeof name2 !== "undefined") {
              name2 = "" + name2;
              if (!_synth[name2])
                _synth[name2] = new WebAudioTinySynth();
              synth2 = _synth[name2];
            } else {
              synth2 = new WebAudioTinySynth();
              _noname.push(synth2);
            }
            synth2.setAudioContext(_ac2);
            port.plug = function(dest) {
              if (dest && (dest.context instanceof AudioContext || dest.context instanceof webkitAudioContext)) {
                synth2.setAudioContext(dest.context, dest);
              }
            };
            port.setSynth = function(n2, s, k2) {
              synth2.setTimbre(!!k2, n2, _clone2(s));
            };
            port.getSynth = function(n2, k2) {
              return k2 ? _clone2(synth2.drummap[n2 - 35]) : _clone2(synth2.program[n2]);
            };
            port._info = _engine2._info(name2);
            port._receive = function(msg2) {
              synth2.send(msg2);
            };
            port._resume();
          };
          JZZ5.synth.Tiny = function(name2) {
            return JZZ5.lib.openMidiOut(name2, _engine2);
          };
          JZZ5.synth.Tiny.register = function(name2) {
            return initAC() ? JZZ5.lib.registerMidiOut(name2, _engine2) : false;
          };
          JZZ5.synth.Tiny.version = function() {
            return _version2;
          };
        })(JZZ4);
        return JZZ4;
      });
    }
  });

  // dist/web/image.js
  function render(x, y, drawing, canvas) {
    const ctx = canvas.getContext("2d");
    switch (drawing.tag) {
      case "ellipse": {
        ctx.fillStyle = drawing.color;
        ctx.strokeStyle = drawing.color;
        const radiusX = drawing.width / 2;
        const radiusY = drawing.height / 2;
        const centerX = x + radiusX;
        const centerY = y + radiusY;
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
        if (drawing.mode === "solid") {
          ctx.fill();
        } else if (drawing.mode === "outline") {
          ctx.stroke();
        }
        break;
      }
      case "rectangle": {
        ctx.fillStyle = drawing.color;
        ctx.strokeStyle = drawing.color;
        if (drawing.mode === "solid") {
          ctx.fillRect(x, y, drawing.width, drawing.height);
        } else if (drawing.mode === "outline") {
          ctx.strokeRect(x, y, drawing.width, drawing.height);
        }
        break;
      }
      case "triangle": {
        ctx.fillStyle = drawing.color;
        ctx.strokeStyle = drawing.color;
        ctx.beginPath();
        ctx.moveTo(x, y + drawing.height);
        ctx.lineTo(x + drawing.width / 2, y);
        ctx.lineTo(x + drawing.width, y + drawing.height);
        ctx.lineTo(x, y + drawing.height);
        if (drawing.mode === "solid") {
          ctx.fill();
        } else if (drawing.mode === "outline") {
          ctx.stroke();
        }
        break;
      }
      case "path": {
        if (drawing.points.length === 0) {
          break;
        }
        ctx.fillStyle = drawing.color;
        ctx.strokeStyle = drawing.color;
        ctx.beginPath();
        ctx.moveTo(x + drawing.points[0][0], y + drawing.points[0][1]);
        drawing.points.slice(1).forEach((p) => {
          ctx.lineTo(x + p[0], y + p[1]);
        });
        if (drawing.mode === "solid") {
          ctx.fill();
        } else {
          ctx.stroke();
        }
        break;
      }
      case "beside": {
        drawing.drawings.forEach((d) => {
          render(x, drawing.align === "top" ? y : drawing.align === "bottom" ? y + drawing.height - d.height : y + (drawing.height - d.height) / 2, d, canvas);
          x += d.width;
        });
        break;
      }
      case "above": {
        drawing.drawings.forEach((d) => {
          render(drawing.align === "left" ? x : drawing.align === "right" ? x + drawing.width - d.width : x + (drawing.width - d.width) / 2, y, d, canvas);
          y += d.height;
        });
        break;
      }
      case "overlay": {
        [...drawing.drawings].reverse().forEach((d) => {
          render(drawing.xAlign === "left" ? x : drawing.xAlign === "right" ? x + drawing.width - d.width : x + (drawing.width - d.width) / 2, drawing.yAlign === "top" ? y : drawing.yAlign === "bottom" ? y + drawing.height - d.height : y + (drawing.height - d.height) / 2, d, canvas);
        });
        break;
      }
      case "overlayOffset": {
        const x1 = drawing.dx > 0 ? x : x + Math.abs(drawing.dx);
        const y1 = drawing.dy > 0 ? y : y + Math.abs(drawing.dy);
        const x2 = drawing.dx > 0 ? x + drawing.dx : x;
        const y2 = drawing.dy > 0 ? y + drawing.dy : y;
        render(x2, y2, drawing.d2, canvas);
        render(x1, y1, drawing.d1, canvas);
        break;
      }
      case "rotate": {
        const centerX = x + drawing.width / 2;
        const centerY = y + drawing.height / 2;
        const angle = drawing.angle * Math.PI / 180;
        ctx.translate(centerX, centerY);
        ctx.rotate(angle);
        ctx.translate(-centerX, -centerY);
        render(x, y, drawing.drawing, canvas);
        ctx.translate(centerX, centerY);
        ctx.rotate(-angle);
        ctx.translate(-centerX, -centerY);
        break;
      }
      case "withDash": {
        ctx.setLineDash(drawing.dashSpec);
        render(x, y, drawing.drawing, canvas);
        ctx.setLineDash([]);
      }
    }
  }
  function clearDrawing(canvas) {
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  function renderDrawing(x, y, drawing, canvas) {
    clearDrawing(canvas);
    render(x, y, drawing, canvas);
  }
  function emitDrawingWidget(node) {
    const canvas = document.createElement("canvas");
    const drawing = JSON.parse(node.textContent);
    canvas.width = drawing.width;
    canvas.height = drawing.height;
    renderDrawing(0, 0, drawing, canvas);
    node.replaceWith(canvas);
  }

  // dist/result.js
  var errorDetails = (phase, message, range, src, hint) => ({
    phase,
    range,
    message,
    src,
    hint
  });
  function detailsToCompleteString(details) {
    const msg2 = [
      `:${details.range ? details.range.start.column : ""}:${details.range ? details.range.start.line : ""}: ${details.phase} error:`,
      `    ${details.message}`
    ];
    if (details.src) {
      msg2.push(`    In program: ${details.src}`);
    }
    if (details.hint) {
      msg2.push(`    Hint: ${details.hint}`);
    }
    return msg2.join("\n");
  }
  function errorToString(err) {
    return err.details.map(detailsToCompleteString).join("\n");
  }
  function errors(errs) {
    return { tag: "error", details: errs, andThen: (f) => errors(errs) };
  }
  function error(phase, message, range, src, hint) {
    return errors([{
      phase,
      range,
      message,
      src,
      hint
    }]);
  }
  function ok(x) {
    return { tag: "ok", value: x, andThen: (f) => f(x) };
  }
  function rethrow(err) {
    return err;
  }
  function join(arr) {
    const result = [];
    for (const e of arr) {
      switch (e.tag) {
        case "error":
          return rethrow(e);
        case "ok":
          result.push(e.value);
      }
    }
    return ok(result);
  }
  function detailsToResult(errs) {
    return errs.length > 0 ? errors(errs) : ok(null);
  }
  var ICE = class extends Error {
    constructor(fn, reason, opts) {
      super(`ICE (${fn}): ${reason}`, opts);
    }
  };

  // dist/web/music.js
  var JZZ = __toESM(require_jzz_combined(), 1);
  function ratioToDouble(ratio) {
    return ratio.num / ratio.den;
  }
  function durationToTimeMs(beat, bpm, dur2) {
    return ratioToDouble(dur2) / (ratioToDouble(beat) * bpm) * 60 * 1e3;
  }
  function compositionToMsgs(beat, bpm, startTime, composition) {
    switch (composition.tag) {
      case "note":
        const endTime = startTime + durationToTimeMs(beat, bpm, composition.duration);
        return {
          endTime,
          msgs: [
            {
              time: startTime,
              data: JZZ.MIDI.noteOn(0, composition.pitch + composition.octave, 127)
            },
            {
              time: endTime,
              data: JZZ.MIDI.noteOff(0, composition.pitch + composition.octave, 127)
            }
          ]
        };
      case "rest":
        return {
          endTime: startTime + durationToTimeMs(beat, bpm, composition.duration),
          msgs: []
        };
      case "par": {
        const msgs = [];
        let endTime2 = 0;
        composition.notes.forEach((note3) => {
          const result = compositionToMsgs(beat, bpm, startTime, note3);
          msgs.push(...result.msgs);
          endTime2 = Math.max(result.endTime, endTime2);
        });
        msgs.sort((c1, c2) => c1.time - c2.time);
        return { endTime: endTime2, msgs };
      }
      case "seq": {
        const msgs = [];
        let time = startTime;
        composition.notes.forEach((note3) => {
          const result = compositionToMsgs(beat, bpm, time, note3);
          msgs.push(...result.msgs);
          time = result.endTime;
          console.log(time);
        });
        msgs.sort((c1, c2) => c1.time - c2.time);
        return { endTime: time, msgs };
      }
      case "mod": {
        if (composition.mod.tag === "pitchBend") {
          const msgs = [];
          const data = compositionToMsgs(beat, bpm, startTime, composition.note);
          msgs.push({ time: startTime, data: JZZ.MIDI.pitchBendF(0, composition.mod.amount) });
          msgs.push(...data.msgs);
          msgs.push({ time: data.endTime, data: JZZ.MIDI.pitchBendF(0, 0) });
          return { msgs, endTime: data.endTime };
        } else if (composition.mod.tag === "tempo") {
          return compositionToMsgs(composition.mod.beat, composition.mod.bpm, startTime, composition.note);
        } else {
          throw new ICE("compositionToMsgs", `unknown mod tag: ${composition.mod.tag}`);
        }
      }
    }
  }
  function playback(synth2, composition) {
    const startTime = window.performance.now();
    const msgs = compositionToMsgs({ num: 1, den: 4 }, 120, 0, composition).msgs;
    console.log(msgs);
    let i = 0;
    const id = window.setInterval(() => {
      const now = window.performance.now();
      while (i < msgs.length) {
        if (msgs[i].time + startTime <= now) {
          synth2.send(msgs[i].data);
          i += 1;
        } else {
          return;
        }
      }
      clearInterval(id);
    });
    return id;
  }
  function emitCompositionWidget(synth2, node) {
    const composition = JSON.parse(node.textContent);
    node.textContent = "";
    const playButton = document.createElement("button");
    playButton.textContent = "\u25B6";
    const stopButton = document.createElement("button");
    stopButton.textContent = "\u25A0";
    let timer = void 0;
    playButton.onclick = function(_e) {
      timer = playback(synth2, composition);
    };
    stopButton.onclick = function(_e) {
      if (timer !== void 0) {
        clearInterval(timer);
      }
    };
    node.appendChild(playButton);
    node.appendChild(stopButton);
  }

  // dist/loc.js
  var mkLoc = (line, column) => ({ line, column });
  var noLoc = () => mkLoc(-1, -1);
  var mkRange = (start, end) => ({ start, end });
  var noRange = () => mkRange(noLoc(), noLoc());

  // dist/lang.js
  var name = (value, range) => ({ value, range });
  var Doc = class {
    sig;
    args;
    desc;
    constructor(sig, args, desc) {
      this.sig = sig;
      this.args = args;
      this.desc = desc;
    }
    docToMarkdown() {
      return `
~~~
${this.sig.trim()}

${this.args.map((arg) => "  " + arg.trim()).join("\n")}
~~~

${this.desc.trim()}
  `.trim();
    }
  };
  var entry = (value, source, range, doc) => ({ value, source, range, doc });
  var Env = class {
    entries;
    constructor(entries) {
      if (entries) {
        this.entries = new Map(entries);
      } else {
        this.entries = /* @__PURE__ */ new Map();
      }
    }
    has(key) {
      return this.entries.has(key);
    }
    get(key) {
      return this.entries.get(key);
    }
    items() {
      return this.entries.entries();
    }
    names() {
      return this.entries.keys();
    }
    append(key, value) {
      return new Env([...this.entries, [key, value]]);
    }
    concat(other) {
      return new Env([...this.entries, ...other.entries]);
    }
    without(keys) {
      const ret = new Env(this.items());
      keys.forEach((k) => ret.entries.delete(k));
      return ret;
    }
  };
  var lbool = (value) => ({ tag: "bool", value });
  var lnum = (value) => ({ tag: "num", value });
  var lchar = (value) => ({ tag: "char", value });
  var lstr = (value) => ({ tag: "str", value });
  var evar = (range, value) => ({ tag: "var", range, value });
  var nlevar = (value) => evar(noRange(), value);
  var elit = (range, value) => ({ tag: "lit", range, value });
  var ebool = (range, value) => elit(range, lbool(value));
  var enumber = (range, value) => elit(range, lnum(value));
  var echar = (range, c) => elit(range, lchar(c));
  var estr = (range, s) => elit(range, lstr(s));
  var nlebool = (value) => elit(noRange(), lbool(value));
  var nlenumber = (value) => elit(noRange(), lnum(value));
  var nlechar = (c) => elit(noRange(), lchar(c));
  var nlestr = (s) => elit(noRange(), lstr(s));
  var ecall = (range, head, args, bracket = "(") => ({ tag: "call", range, head, args, bracket });
  var nlecall = (head, args) => ecall(noRange(), head, args);
  var elam = (range, args, body, bracket = "(") => ({ tag: "lam", range, args, body, bracket });
  var eif = (range, e1, e2, e3, bracket = "(") => ({ tag: "if", range, e1, e2, e3, bracket });
  var nleif = (e1, e2, e3) => eif(noRange(), e1, e2, e3);
  var enil = (range) => ({ tag: "nil", range });
  var nlenil = () => enil(noRange());
  var epair = (range, e1, e2, bracket = "(") => ({ tag: "pair", range, e1, e2, bracket });
  var nlepair = (e1, e2) => epair(noRange(), e1, e2);
  var elet = (range, bindings, body, bracket = "(") => ({ tag: "let", range, bindings, body, bracket });
  var econd = (range, branches, bracket = "(") => ({ tag: "cond", range, branches, bracket });
  var nlecond = (branches) => econd(noRange(), branches);
  var eand = (range, args, bracket = "(") => ({ tag: "and", range, args, bracket });
  var nleand = (args) => eand(noRange(), args);
  var eor = (range, args, bracket = "(") => ({ tag: "or", range, args, bracket });
  var nleor = (args) => eor(noRange(), args);
  var nlestruct = (kind, obj) => ({ tag: "struct", range: noRange(), kind, obj });
  var nleobj = (kind, obj) => ({ tag: "obj", range: noRange(), kind, obj });
  var nleprim = (prim) => ({ tag: "prim", range: noRange(), prim });
  function parens(ss) {
    return `(${ss.join(" ")})`;
  }
  function litToString(l) {
    switch (l.tag) {
      case "bool":
        return l.value ? "#t" : "#f";
      case "num":
        return l.value.toString();
      case "char":
        return `#${l.value}`;
      case "str":
        return `"${l.value}"`;
    }
  }
  function arrayToList(es) {
    let ret = nlenil();
    for (let i = es.length - 1; i >= 0; i--) {
      ret = epair(es[i].range, es[i], ret);
    }
    return ret;
  }
  function unsafeListToArray(e) {
    const ret = [];
    while (e.tag === "pair") {
      ret.push(e.e1);
      e = e.e2;
    }
    return ret;
  }
  function expToString(e) {
    switch (e.tag) {
      case "var":
        return e.value;
      case "lit":
        return litToString(e.value);
      case "call":
        return parens([e.head].concat(e.args).map(expToString));
      case "lam":
        return parens(["lambda", parens(e.args.map((n) => n.value)), expToString(e.body)]);
      case "if":
        return parens(["if", expToString(e.e1), expToString(e.e2), expToString(e.e3)]);
      case "nil":
        return "null";
      case "pair":
        return isList(e) ? parens(["list"].concat(unsafeListToArray(e).map(expToString))) : parens(["cons", expToString(e.e1), expToString(e.e2)]);
      case "let":
        return parens(["let", parens(e.bindings.map(([x, e2]) => `(${x} ${expToString(e2)})`)), expToString(e.body)]);
      case "cond":
        return parens(["cond"].concat(e.branches.map((b) => parens([expToString(b[0]), expToString(b[1])])).join(" ")));
      case "and":
        return parens(["and"].concat(parens(e.args.map(expToString))));
      case "or":
        return parens(["and"].concat(parens(e.args.map(expToString))));
      case "struct":
        return `[struct ${e.obj.kind}]`;
      case "obj":
        return `[object ${e.kind}]`;
      case "prim":
        return `[prim ${e.prim.name}]`;
    }
  }
  function isValue(e) {
    switch (e.tag) {
      case "var":
        return true;
      case "lit":
        return true;
      case "call":
        return false;
      case "lam":
        return true;
      case "if":
        return false;
      case "nil":
        return true;
      case "pair":
        return isValue(e.e1) && isValue(e.e2);
      case "let":
        return false;
      case "cond":
        return false;
      case "and":
        return false;
      case "or":
        return false;
      case "struct":
        return true;
      case "obj":
        return true;
      case "prim":
        return true;
    }
  }
  function isNumber(e) {
    return e.tag === "lit" && e.value.tag === "num";
  }
  function isInteger(e) {
    return e.tag === "lit" && e.value.tag === "num" && Number.isInteger(e.value.value);
  }
  function isReal(e) {
    return e.tag === "lit" && e.value.tag === "num" && !Number.isInteger(e.value.value);
  }
  function isBoolean(e) {
    return e.tag === "lit" && e.value.tag === "bool";
  }
  function isString(e) {
    return e.tag === "lit" && e.value.tag === "str";
  }
  function isChar(e) {
    return e.tag === "lit" && e.value.tag === "char";
  }
  function isLambda(e) {
    return e.tag === "lam";
  }
  function isPair(e) {
    return e.tag === "pair";
  }
  function isList(e) {
    while (e.tag === "pair") {
      e = e.e2;
    }
    return e.tag === "nil";
  }
  function isPrim(e) {
    return e.tag === "prim";
  }
  function isStructKind(e, kind) {
    return e.tag === "struct" && e.kind === `${kind}`;
  }
  function isObj(e) {
    return e.tag === "obj";
  }
  function isObjKind(e, kind) {
    return e.tag === "obj" && e.kind === kind;
  }
  function isProcedure(e) {
    return isLambda(e) || isPrim(e);
  }
  function asNum_(e) {
    return e.value.value;
  }
  function asBool_(e) {
    return e.value.value;
  }
  function asChar_(e) {
    return e.value.value;
  }
  function asString_(e) {
    return e.value.value;
  }
  function asList_(e) {
    return unsafeListToArray(e);
  }
  function asPair_(e) {
    return [e.e1, e.e2];
  }
  function fromObj_(e) {
    return e.obj;
  }
  function asStruct_(e) {
    return e.obj;
  }
  function nameEquals(n1, n2) {
    return n1.value === n2.value;
  }
  function litEquals(l1, l2) {
    if (l1.tag === "num" && l2.tag === "num") {
      return l1.value === l2.value;
    } else if (l1.tag === "bool" && l2.tag === "bool") {
      return l1.value === l2.value;
    } else if (l1.tag === "char" && l2.tag === "char") {
      return l1.value === l2.value;
    } else if (l1.tag === "str" && l2.tag === "str") {
      return l1.value === l2.value;
    } else {
      return false;
    }
  }
  function expEquals(e1, e2) {
    if (e1.tag === "var" && e2.tag === "var") {
      return e1.value === e2.value;
    } else if (e1.tag === "lit" && e2.tag === "lit") {
      return litEquals(e1.value, e2.value);
    } else if (e1.tag === "call" && e2.tag === "call") {
      return expEquals(e1.head, e2.head) && e1.args.length === e2.args.length && e1.args.every((e, i) => expEquals(e, e2.args[i]));
    } else if (e1.tag === "lam" && e2.tag === "lam") {
      return e1.args.length === e2.args.length && e1.args.every((x, i) => nameEquals(x, e2.args[i])) && expEquals(e1.body, e2.body);
    } else if (e1.tag === "if" && e2.tag === "if") {
      return expEquals(e1.e1, e2.e1) && expEquals(e1.e2, e2.e2) && expEquals(e1.e3, e2.e3);
    } else if (e1.tag === "nil" && e2.tag === "nil") {
      return true;
    } else if (e1.tag === "pair" && e2.tag === "pair") {
      return expEquals(e1.e1, e2.e1) && expEquals(e1.e2, e2.e2);
    } else if (e1.tag === "let" && e2.tag === "let") {
      return e1.bindings.length === e2.bindings.length && e1.bindings.every(([x, e], i) => nameEquals(x, e2.bindings[i][0]) && expEquals(e, e2.bindings[i][1])) && expEquals(e1.body, e2.body);
    } else {
      return false;
    }
  }
  var simported = (source) => ({ tag: "imported", source });
  var serror = (errors2) => ({ tag: "error", errors: errors2 });
  var sbinding = (name2) => ({ tag: "binding", name: name2 });
  var svalue = (value) => ({ tag: "value", value });
  var simport = (range, source) => ({ tag: "import", range, source });
  var sdefine = (name2, value) => ({ tag: "define", name: name2, value });
  var sstruct = (id, fields) => ({ tag: "struct", id, fields });
  var sexp = (value) => ({ tag: "exp", value });
  function isStmtDone(stmt) {
    return stmt.tag === "error" || stmt.tag === "binding" || stmt.tag === "value" || stmt.tag === "imported";
  }
  function indexOfCurrentStmt(prog) {
    for (let i = 0; i < prog.statements.length; i++) {
      if (!isStmtDone(prog.statements[i])) {
        return i;
      }
    }
    return -1;
  }

  // dist/messages.js
  var templates = /* @__PURE__ */ new Map([
    ["error-arity", (vs) => `${vs[0]} expects ${vs[1]} arguments but ${vs[2]} arguments were given`],
    ["error-arity-atleast", (vs) => `${vs[0]} expects at least ${vs[1]} arguments but ${vs[2]} arguments were given`],
    ["error-cond-no-branch-applies", (_) => "No guard of the conditional expression evaluated to #t"],
    ["error-duplicate-name", (vs) => `Duplicate name ${vs[0]} given in definition.`],
    ["error-empty-app", (_) => "Function application cannot be empty"],
    ["error-eof", (_) => "Unexpected end of source code encountered"],
    ["error-eof-string", (_) => "Unexpected end of source code encountered while parsing a string literal"],
    ["error-eof-block-comment", (_) => "Unexpected end of source code encountered while parsing a block comment"],
    ["error-hole", (_) => "A hole was encountered!"],
    ["error-import-not-found", (vs) => `Import ${vs[0]} not found`],
    ["error-index-string", (vs) => `${vs[0]} is not a valid index into string "${vs[1]}"`],
    ["error-invalid-char-constant", (_) => "Invalid character constant encountered"],
    ["error-invalid-string-literal", (_) => "Invalid string literal encountered"],
    ["error-runtime-parsing", (vs) => `${vs[0]} expects that its input string ${vs[1]} is a valid ${vs[2]} but it is not.`],
    ["error-precondition-not-met", (vs) => `${vs[0]} expects that argument ${vs[1]} obeys the following property: ${vs[2]}, but ${vs[3]} was given.`],
    ["error-missing-parens", (_) => "Missing closing parentheses"],
    ["error-unmatched-parens", (_) => "Unmatched parentheses encountered"],
    ["error-unrecognized-escape", (vs) => `Unrecognized escape sequence: ${vs[0]}`],
    ["error-reserved-word", (_) => "Cannot use reserved word as a variable name"],
    ["error-runtime", (vs) => `A runtime error was encounter: ${vs[0]}`],
    ["error-type-expected", (vs) => `A ${vs[0]} was expected, but a ${vs[1]} was found`],
    ["error-type-expected-fun", (vs) => `${vs[0]} expected an ${vs[1]} in position ${vs[2]} but a ${vs[3]} was given`],
    ["error-type-expected-call", (vs) => `A function was expected as the first argument to a function call, but a ${vs[0]} was given`],
    ["error-type-expected-cond", (vs) => "A boolean was expected as the guard of a conditional, but a ${vs[0]) was given"],
    ["error-type-filter-bool", (vs) => `Filter's predicate must return a boolean, but a ${vs[0]} was returned instead.`],
    ["error-var-binding", (_) => "A variable was expected in the first position of the binding"],
    ["error-var-undef", (vs) => `Variable ${vs[0]} is not defined`],
    ["error-var-shadowed", (vs) => `Variable ${vs[0]} has already been defined`],
    ["phase-lexer", (_) => "Lexer"],
    ["phase-parser", (_) => "Parser"],
    ["phase-runtime", (_) => "Runtime"],
    ["phase-scope", (_) => "Scope"]
  ]);
  function msg(id, ...args) {
    if (templates.has(id)) {
      return templates.get(id)(args);
    } else {
      throw new ICE("msg", `Identifier not found: ${id}`);
    }
  }

  // dist/sexp.js
  function atom(range, single) {
    return {
      tag: "atom",
      single,
      range,
      toString: () => single
    };
  }
  function slist(range, bracket, list2) {
    return {
      tag: "slist",
      list: list2,
      range,
      bracket,
      toString: () => `(${list2.map((s) => s.toString()).join(" ")})`
    };
  }
  var mkStartingToken = (value, start) => ({
    value,
    range: mkRange(mkLoc(start.line, start.column), mkLoc(start.line, start.column))
  });
  function lexerError(message, tok, hint) {
    return error(msg("phase-lexer"), message, tok?.range, tok?.value, hint);
  }
  var LexerState = class {
    i;
    pos;
    tok;
    constructor() {
      this.i = 0;
      this.pos = mkLoc(0, 0);
      this.tok = void 0;
    }
    isTracking() {
      return this.tok !== void 0;
    }
    startTracking(ch) {
      if (this.tok !== void 0) {
        throw new ICE("startTracking", "startTracking called when a token is already being built");
      } else {
        this.tok = mkStartingToken(ch, this.pos);
      }
    }
    resetTokenState() {
      this.tok = void 0;
    }
    emitToken() {
      if (this.tok === void 0) {
        throw new ICE("emitToken", "emitToken called when a token is not yet being built");
      } else {
        const result = this.tok;
        this.resetTokenState();
        return result;
      }
    }
    advanceColumn() {
      this.i += 1;
      this.pos.column += 1;
    }
    advanceLine() {
      this.i += 1;
      this.pos.line += 1;
      this.pos.column = 0;
    }
    append(s) {
      if (this.tok === void 0) {
        throw new ICE("append", "append called when a token is not yet being built");
      } else {
        this.tok.value += s;
        this.tok.range.end.line = this.pos.line;
        this.tok.range.end.column = this.pos.column;
      }
    }
  };
  function tokenizeWord(word, src, st) {
    for (let i = 0; i < word.length; i++) {
      if (word[i] !== src[st.i]) {
        throw new ICE("tokenizeWord", `Encountered ${src[st.i]} while parsing ${word}`);
      } else {
        st.append(src[st.i]);
        st.advanceColumn();
      }
    }
    return ok(null);
  }
  function tokenizeLineComment(src, st) {
    if (src[st.i] !== ";") {
      throw new ICE("tokenizeLineComment", `Beginning character is not a semicolon: ${src[st.i]}`);
    } else {
      st.startTracking('"');
      st.advanceColumn();
      while (st.i < src.length) {
        if (src[st.i] === "\n") {
          st.advanceLine();
          return st.emitToken();
        } else {
          st.append(src[st.i]);
          st.advanceColumn();
        }
      }
    }
    return st.emitToken();
  }
  function tokenizeBlockComment(src, st) {
    if (st.i >= src.length - 1 || src[st.i] !== "#" || src[st.i + 1] !== "|") {
      throw new ICE("tokenizeBlockComment", `Beginning characters do not start a block comment: ${src[st.i]}${src[st.i + 1]}`);
    } else {
      let blockLevel = 0;
      st.startTracking("#|");
      st.advanceColumn();
      st.advanceColumn();
      while (st.i < src.length - 1) {
        if (src[st.i] === "|" && src[st.i + 1] === "#") {
          blockLevel -= 1;
          if (blockLevel < 0) {
            st.advanceColumn();
            st.advanceColumn();
            return ok(st.emitToken());
          }
        } else if (src[st.i] === "#" && src[st.i + 1] === "|") {
          blockLevel += 1;
          st.advanceColumn();
          st.advanceColumn();
        } else if (src[st.i] === "\n") {
          st.append("\n");
          st.advanceLine();
        } else {
          st.append(src[st.i]);
          st.advanceColumn();
        }
      }
      return lexerError(msg("error-eof-block-comment"));
    }
  }
  function tokenizeCharLiteral(src, st) {
    const namedChars = [
      "alarm",
      "backspace",
      "delete",
      "escape",
      "newline",
      "null",
      "return",
      "space",
      "tab"
    ];
    const startsWithNamedChar = (src2, st2) => {
      for (const n of namedChars) {
        if (src2.startsWith(n, st2.i)) {
          return n;
        }
      }
      return void 0;
    };
    const isWhitespace = (c) => /\s/.test(c);
    const isBracket = (c) => c === "(" || c === ")" || c === "[" || c === "]" || c === "{" || c === "}";
    if (!(st.i < src.length - 1) && src[st.i] !== "#" && src[st.i + 1] !== "\\") {
      throw new ICE("tokenizeCharLiteral", `Beginning characters are not hash-slash: ${src[st.i]}`);
    } else {
      st.startTracking("#\\");
      st.advanceColumn();
      st.advanceColumn();
      let namedChar = startsWithNamedChar(src, st);
      if (namedChar !== void 0) {
        tokenizeWord(namedChar, src, st);
        if (st.i >= src.length || (isWhitespace(src[st.i]) || isBracket(src[st.i]))) {
          return ok(st.emitToken());
        } else {
          st.append(src[st.i]);
          if (src[st.i] === "\n") {
            st.advanceLine();
          } else {
            st.advanceColumn();
          }
          const tok = st.emitToken();
          return lexerError(msg("error-invalid-char-constant"), tok);
        }
      } else if (st.i >= src.length - 1 || isWhitespace(src[st.i]) && !isWhitespace(src[st.i + 1]) || !isWhitespace(src[st.i]) && (isWhitespace(src[st.i + 1]) || isBracket(src[st.i + 1]))) {
        st.append(src[st.i]);
        if (src[st.i] === "\n") {
          st.advanceLine();
        } else {
          st.advanceColumn();
        }
        return ok(st.emitToken());
      } else {
        st.append(src[st.i]);
        st.append(src[st.i + 1]);
        const tok = st.emitToken();
        return lexerError(msg("error-invalid-char-constant"), tok);
      }
    }
  }
  function tokenizeStringLiteral(src, st) {
    if (src[st.i] !== '"') {
      throw new ICE("tokenizeStringLiteral", `Beginning character is not a quote: ${src[st.i]}`);
    } else {
      st.startTracking('"');
      st.advanceColumn();
      while (st.i < src.length) {
        if (src[st.i] === '"') {
          st.append('"');
          st.advanceColumn();
          return ok(st.emitToken());
        } else if (src[st.i] === "\\") {
          if (st.i + 1 === src.length) {
            return lexerError(msg("error-eof-string"));
          } else {
            const ch = src[st.i + 1];
            if (ch === "a") {
              st.append("\x07");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "b") {
              st.append("\b");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "t") {
              st.append("	");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "n") {
              st.append("\n");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "v") {
              st.append("\v");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "f") {
              st.append("\f");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "r") {
              st.append("\r");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "e") {
              st.append("\x1B");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === '"') {
              st.append('"');
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "'") {
              st.append("'");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch === "\\") {
              st.append("\\");
              st.advanceColumn();
              st.advanceColumn();
            } else if (ch >= "0" && ch <= "9") {
              throw new ICE("tokenizeStringLiteral", "Octal escape not supported");
            } else if (ch === "x") {
              throw new ICE("tokenizeStringLiteral", "Hex escape not supported");
            } else if (ch === "u" || ch === "U") {
              throw new ICE("tokenizeStringLiteral", "Unicode escape not supported");
            } else if (ch === "\n") {
              st.advanceColumn();
              st.advanceLine();
            } else {
              return lexerError(msg("error-unrecognized-escape", ch));
            }
          }
        } else {
          st.append(src[st.i]);
          st.advanceColumn();
        }
      }
      return lexerError(msg("error-eof-string"));
    }
  }
  function tokenize(src) {
    const result = [];
    const st = new LexerState();
    while (st.i < src.length) {
      const isWhitespace = /\s/.test(src[st.i]);
      if (src[st.i] === "(" || src[st.i] === ")" || src[st.i] === "[" || src[st.i] === "]" || src[st.i] === "{" || src[st.i] === "}" || src[st.i] === ",") {
        if (st.isTracking()) {
          result.push(st.emitToken());
        }
        st.startTracking(src[st.i]);
        result.push(st.emitToken());
        st.advanceColumn();
      } else if (isWhitespace) {
        if (st.isTracking()) {
          result.push(st.emitToken());
        }
        if (src[st.i] === "\n") {
          st.advanceLine();
        } else {
          st.advanceColumn();
        }
      } else if (src[st.i] === '"') {
        if (st.isTracking()) {
          result.push(st.emitToken());
        }
        const lit = tokenizeStringLiteral(src, st);
        switch (lit.tag) {
          case "error":
            return rethrow(lit);
          case "ok":
            result.push(lit.value);
        }
      } else if (src[st.i] === ";") {
        if (st.isTracking()) {
          result.push(st.emitToken());
        }
        const _comment = tokenizeLineComment(src, st);
      } else if (st.i < src.length - 1 && src[st.i] === "#" && src[st.i + 1] === "|") {
        const _comment = tokenizeBlockComment(src, st);
        switch (_comment.tag) {
          case "error":
            return rethrow(_comment);
          case "ok":
        }
      } else if (st.i < src.length - 1 && src[st.i] === "#" && src[st.i + 1] === "\\") {
        const charConst = tokenizeCharLiteral(src, st);
        switch (charConst.tag) {
          case "error":
            return rethrow(charConst);
          case "ok":
            result.push(charConst.value);
        }
      } else {
        if (!st.isTracking()) {
          st.startTracking(src[st.i]);
        } else {
          st.append(src[st.i]);
        }
        st.advanceColumn();
      }
    }
    if (st.isTracking()) {
      result.push(st.emitToken());
    }
    return ok(result);
  }
  function tokensToSListArgs(endBracket, toks) {
    if (toks.length === 0) {
      return lexerError(msg("error-eof"));
    }
    const sexps = [];
    while (toks.length > 0 && toks[0].value !== endBracket) {
      const next = tokensToSexp(toks);
      switch (next.tag) {
        case "error":
          return rethrow(next);
        case "ok": {
          sexps.push(next.value);
        }
      }
    }
    if (toks.length === 0) {
      return error(msg("phase-lexer"), msg("error-missing-parens"), sexps.length > 0 ? mkRange(sexps[0].range.start, sexps[sexps.length - 1].range.end) : noRange());
    }
    toks.shift();
    return ok(sexps);
  }
  function tokensToSexp(toks) {
    if (toks.length === 0) {
      return lexerError(msg("error-eof"));
    } else {
      const head = toks.shift();
      switch (head.value) {
        case "(":
          return tokensToSListArgs(")", toks).andThen((args) => ok(slist(mkRange(args[0].range.start, args[args.length - 1].range.end), "(", args)));
        case "[":
          return tokensToSListArgs("]", toks).andThen((args) => ok(slist(mkRange(args[0].range.start, args[args.length - 1].range.end), "[", args)));
        case "{":
          return tokensToSListArgs("}", toks).andThen((args) => ok(slist(mkRange(args[0].range.start, args[args.length - 1].range.end), "{", args)));
        case ",":
          return tokensToSexp(toks);
        case ")":
          return lexerError(msg("error-unmatched-parens"), head);
        case "]":
          return lexerError(msg("error-unmatched-parens"), head);
        case "}":
          return lexerError(msg("error-unmatched-parens"), head);
        default:
          return ok(atom(head.range, head.value));
      }
    }
  }
  function tokensToSexps(tokens) {
    const result = [];
    while (tokens.length > 0) {
      const next = tokensToSexp(tokens);
      switch (next.tag) {
        case "error":
          return rethrow(next);
        case "ok":
          result.push(next.value);
      }
    }
    return ok(result);
  }
  function stringToSexps(s) {
    return tokenize(s).andThen(tokensToSexps);
  }
  function sexpToString(s) {
    if (s.tag === "atom") {
      return s.single;
    } else {
      return `(${s.list.map(sexpToString).join(" ")})`;
    }
  }

  // dist/parser.js
  var reservedWords = [
    "and",
    "cond",
    "define",
    "if",
    "import",
    "lambda",
    "or",
    "struct"
  ];
  function parserError(message, s, hint) {
    return error(msg("phase-parser"), message, s?.range, s ? sexpToString(s) : void 0, hint);
  }
  function checkDuplicateNames(names, s) {
    const soFar = [];
    for (const name2 of names) {
      if (soFar.includes(name2.value)) {
        return parserError(msg("error-duplicate-name", name2.value), s);
      } else {
        soFar.push(name2.value);
      }
    }
    return ok(names);
  }
  function sexpToUniqueStringList(s) {
    switch (s.tag) {
      case "atom":
        return parserError(msg("error-type-expected", "list", "identifier"), s);
      case "slist":
        return join(s.list.map((x) => x.tag === "atom" ? ok(name(x.single, x.range)) : parserError(msg("error-type-expected", "identifier", "list"), x))).andThen((names) => checkDuplicateNames(names, s));
    }
  }
  function sexpToBinding(s) {
    switch (s.tag) {
      case "atom":
        return parserError(msg("error-type-expected", "binding", "identifier"), s);
      case "slist":
        return s.list.length !== 2 ? parserError(msg("error-type-expected", "binding", "non-binding"), s) : s.list[0].tag !== "atom" ? parserError(msg("error-var-binding"), s) : sexpToExp(s.list[1]).andThen((e) => ok([name(s.list[0].single, s.list[0].range), e]));
    }
  }
  function sexpToBindings(s) {
    switch (s.tag) {
      case "atom":
        return parserError(msg("error-type-expected", "binding list", "identifier"), s);
      case "slist": {
        const result = new Array(s.list.length);
        for (let i = 0; i < s.list.length; i++) {
          const r = sexpToBinding(s.list[i]);
          switch (r.tag) {
            case "error":
              return rethrow(r);
            case "ok":
              result[i] = r.value;
          }
        }
        return ok(result);
      }
    }
  }
  function sexpToBranch(s) {
    switch (s.tag) {
      case "atom":
        return parserError(msg("error-type-expected", "branch", "identifier"), s);
      case "slist":
        if (s.list.length !== 2) {
          return parserError(msg("error-type-expected", "branch", "non-branch"), s);
        } else {
          return sexpToExp(s.list[0]).andThen((guard) => sexpToExp(s.list[1]).andThen((body) => ok([guard, body])));
        }
    }
  }
  function tryParseString(s) {
    if (s.length < 2 || !s.startsWith('"') || !s.endsWith('"')) {
      return void 0;
    } else {
      return s.slice(1, s.length - 1);
    }
  }
  var intRegex = /^[+-]?\d+$/;
  var floatRegex = /^[+-]?(\d+|(\d*\.\d+)|(\d+\.\d*))([eE][+-]?\d+)?$/;
  var namedCharValues = /* @__PURE__ */ new Map([
    ["alarm", String.fromCharCode(9)],
    ["backspace", String.fromCharCode(7)],
    ["delete", String.fromCharCode(126)],
    ["escape", String.fromCharCode(26)],
    ["newline", String.fromCharCode(9)],
    ["null", String.fromCharCode(-1)],
    ["return", String.fromCharCode(12)],
    ["space", " "],
    ["tab", String.fromCharCode(8)]
  ]);
  function sexpToExp(s) {
    switch (s.tag) {
      case "atom": {
        if (intRegex.test(s.single)) {
          return ok(enumber(s.range, parseInt(s.single, 10)));
        } else if (floatRegex.test(s.single)) {
          return ok(enumber(s.range, parseFloat(s.single)));
        } else if (s.single.startsWith('"')) {
          const result = tryParseString(s.single);
          return result !== void 0 ? ok(estr(s.range, result)) : parserError(msg("error-invalid-string-literal"), s);
        } else if (s.single === "null") {
          return ok(enil(s.range));
        } else if (s.single === "#t" || s.single === "#true") {
          return ok(ebool(s.range, true));
        } else if (s.single === "#f" || s.single === "#false") {
          return ok(ebool(s.range, false));
        } else if (s.single.startsWith("#\\")) {
          const result = s.single.slice(2);
          if (result.length === 1) {
            return ok(echar(s.range, result));
          } else {
            return ok(echar(s.range, namedCharValues.get(result)));
          }
        } else if (reservedWords.includes(s.single)) {
          return parserError(msg("error-reserved-word"), s);
        } else {
          return ok(evar(s.range, s.single));
        }
      }
      case "slist":
        if (s.list.length === 0) {
          return parserError(msg("error-empty-app"));
        } else {
          const head = s.list[0];
          const args = s.list.slice(1);
          switch (head.tag) {
            case "atom":
              switch (head.single) {
                case "lambda":
                  return args.length !== 2 ? parserError(msg("error-arity", "lambda", 2, args.length), s) : sexpToUniqueStringList(args[0]).andThen((xs) => sexpToExp(args[1]).andThen((body) => ok(elam(s.range, xs, body, s.bracket))));
                case "if":
                  return args.length !== 3 ? parserError(msg("error-arity", "if", 3, args.length), s) : sexpToExp(args[0]).andThen((e1) => sexpToExp(args[1]).andThen((e2) => sexpToExp(args[2]).andThen((e3) => ok(eif(s.range, e1, e2, e3, s.bracket)))));
                case "let":
                  return args.length !== 2 ? parserError(msg("error-arity", "let", 2, args.length), s) : sexpToBindings(args[0]).andThen((bindings) => sexpToExp(args[1]).andThen((body) => ok(elet(s.range, bindings, body, s.bracket))));
                case "cond":
                  return args.length === 0 ? parserError(msg("error-arity-atleast", "cond", "1", args.length), s) : join(args.map(sexpToBranch)).andThen((branches) => ok(econd(s.range, branches, s.bracket)));
                case "and":
                  return join(args.map(sexpToExp)).andThen((es) => ok(eand(s.range, es, s.bracket)));
                case "or":
                  return join(args.map(sexpToExp)).andThen((es) => ok(eor(s.range, es, s.bracket)));
                default:
                  return join(args.map(sexpToExp)).andThen((es) => ok(ecall(s.range, evar(head.range, head.single), es, s.bracket)));
              }
            case "slist":
              return sexpToExp(head).andThen((e) => join(args.map(sexpToExp)).andThen((es) => ok(ecall(s.range, e, es, s.bracket))));
          }
        }
    }
  }
  function sexpToStmt(s) {
    switch (s.tag) {
      case "atom":
        return sexpToExp(s).andThen((e) => ok(sexp(e)));
      case "slist":
        if (s.list[0].tag === "atom" && s.list[0].single === "define") {
          const args = s.list.slice(1);
          return args.length !== 2 ? parserError(`Define expects 2 arguments, ${args.length} given`, s) : args[0].tag !== "atom" ? parserError("Define expects a variable as the first argument", s) : sexpToExp(args[1]).andThen((e) => ok(sdefine(name(args[0].single, args[0].range), e)));
        } else if (s.list[0].tag === "atom" && s.list[0].single === "import") {
          const args = s.list.slice(1);
          if (args.length !== 1) {
            return parserError(msg("error-arity", "import", 1, args.length), s);
          } else {
            const source = args[0];
            return source.tag !== "atom" ? parserError(msg("error-type-expected", "module name", source.tag), s) : ok(simport(s.range, source.single));
          }
        } else if (s.list[0].tag === "atom" && s.list[0].single === "struct") {
          const args = s.list.slice(1);
          if (args.length !== 2) {
            return parserError(msg("error-arity", "struct", 2, args.length), s);
          } else if (args[0].tag !== "atom") {
            return parserError(msg("error-type-expected", "struct name", args[0].tag), s);
          } else {
            return sexpToUniqueStringList(args[1]).andThen((fields) => ok(sstruct(name(args[0].single, args[0].range), fields)));
          }
        } else {
          return sexpToExp(s).andThen((e) => ok(sexp(e)));
        }
    }
  }
  function sexpsToProgram(ss) {
    return join(ss.map(sexpToStmt)).andThen((statements) => ok({
      statements
    }));
  }
  function parseProgram(src) {
    return stringToSexps(src).andThen((ss) => sexpsToProgram(ss));
  }

  // dist/lib/utils.js
  function specToPred(spec) {
    switch (spec) {
      case "any":
        return () => true;
      case "number?":
        return isNumber;
      case "integer?":
        return isInteger;
      case "real?":
        return isReal;
      case "boolean?":
        return isBoolean;
      case "string?":
        return isString;
      case "char?":
        return isChar;
      case "procedure?":
        return isProcedure;
      case "pair?":
        return isPair;
      case "list?":
        return isList;
      case "prim?":
        return isPrim;
      case "obj?":
        return isObj;
      default:
        if (spec.length > 0 && /[A-Z]/.test(spec[0])) {
          return (e) => isObjKind(e, spec);
        } else {
          throw new ICE("argSpecToPred", `Unrecognized spec: ${spec}`);
        }
    }
  }
  function checkArgs(func, specs, restSpec, args, call) {
    if (restSpec && args.length < specs.length) {
      return runtimeError(msg("error-arity-atleast", func, specs.length, args.length), call);
    } else if (!restSpec && args.length !== specs.length) {
      return runtimeError(msg("error-arity", func, specs.length, args.length), call);
    }
    let i = 0;
    for (const spec of specs) {
      if (!specToPred(spec)(args[i])) {
        return runtimeError(msg("error-type-expected-fun", func, spec, i + 1, args[i].tag), call);
      }
      i += 1;
    }
    if (restSpec) {
      for (; i < args.length; i++) {
        const arg = args[i];
        if (!specToPred(restSpec)(arg)) {
          return runtimeError(msg("error-type-expected-fun", func, restSpec, i + 1, arg.tag), call);
        }
      }
    }
    return void 0;
  }
  function checkArgsResult(func, specs, restSpec, args, call) {
    const err = checkArgs(func, specs, restSpec, args, call);
    return err ? err : ok(null);
  }

  // dist/lib/docs.js
  var equal = new Doc("(equal? v1 v2): boolean?", [
    "v1: any",
    "v2: any"
  ], "Returns `#t` if and only `v1` and `v2` are (structurally) equal values.");
  var number = new Doc("(number? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a number.");
  var real = new Doc("(real? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a real number.");
  var integer = new Doc("(integer? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is an integer.");
  var nanQ = new Doc("(nan? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is the number `NaN`.");
  var lt = new Doc("(< v1 v2): boolean?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `#t` if and only `v1` is strictly less than `v2`.");
  var leq = new Doc("(<= v1 v2): boolean?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `#t` if and only `v1` is less than or equal to `v2`.");
  var gt = new Doc("(> v1 v2): boolean?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `#t` if and only `v1` is strictly greater than `v2`.");
  var geq = new Doc("(>= v1 v2): boolean?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `#t` if and only `v1` is greater than or equal to `v2`.");
  var numeq = new Doc("(= v1 v2): boolean?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `#t` if and only `v1` is equal to `v2`.");
  var zero = new Doc("(zero? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is zero.");
  var positive = new Doc("(positive? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is positive.");
  var negative = new Doc("(negative? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is negative.");
  var odd = new Doc("(odd? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is odd.");
  var even = new Doc("(even? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is even.");
  var max = new Doc("(max v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the maximum of the given numbers.");
  var min = new Doc("(min v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the minimum of the given numbers.");
  var plus = new Doc("(+ v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the sum of `v1`, `v2`, ... .");
  var minus = new Doc("(- v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the difference of `v1`, `v2`, ... .");
  var times = new Doc("(* v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the product of `v1`, `v2`, ... .");
  var div = new Doc("(/ v1 v2 ...): number?", [
    "v: number?"
  ], "Returns the quotient of `v1`, `v2`, ... .");
  var abs = new Doc("(abs v): number?", [
    "v: number?"
  ], "Returns the absolute value of `v`.");
  var quotient = new Doc("(quotient v1 v2): number?", [
    "v1: integer?",
    "v2: integer?"
  ], "Returns the quotient of `v1` and `v2`, _i.e._, the whole number part of `v1 / v2`.");
  var remainder = new Doc("(remainder v1 v2): number?", [
    "v1: integer?",
    "v2: integer?"
  ], "Returns the remainder of `v1` and `v2`, _i.e._, the remainder of `v1 / v2`.");
  var modulo = new Doc("(modulo v1 v2): number?", [
    "v1: number?",
    "v2: number?"
  ], "Returns `k = n - d * q` where `q` is the integer such that `k` has the same sign as the divisor `d` while being as close to 0 as possible. (Source: [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder).)");
  var floor = new Doc("(floor v): integer?", [
    "v: number?"
  ], "Returns the largest integer less than or equal to `v`.");
  var ceiling = new Doc("(ceiling v): integer?", [
    "v: number?"
  ], "Returns the smallest integer greater than or equal to `v`.");
  var truncate = new Doc("(truncate v): integer?", [
    "v: number?"
  ], "Returns the integer closest to `v` less than or equal to `v`.");
  var round = new Doc("(round v): integer?", [
    "v: number?"
  ], "Returns the integer closest to `v`.");
  var square = new Doc("(square v): number?", [
    "v: number?"
  ], "Returns the square of `v`.");
  var sqrt = new Doc("(sqrt v): number?", [
    "v: number?"
  ], "Returns the square root of `v`.");
  var expt = new Doc("(expt x y): number?", [
    "x: number?",
    "y: number?"
  ], "Returns `x` raised to the power of `y`.");
  var numberString = new Doc("(number->string v): string?", [
    "v: number?"
  ], "Returns the string representation of `v`.");
  var stringNumber = new Doc("(string->number s): number?", [
    "s: string?, presumed to be a number"
  ], "Returns the number denoted by `s` as a `number`.");
  var exp = new Doc("(exp v): number?", [
    "v: number?"
  ], "Returns the exponential of `v`.");
  var log = new Doc("(log v): number?", [
    "v: number?"
  ], "Returns the natural logarithm of `v`.");
  var sin = new Doc("(sin v): number?", [
    "v: number?"
  ], "Returns the sine of `v`.");
  var cos = new Doc("(cos v): number?", [
    "v: number?"
  ], "Returns the cosine of `v`.");
  var tan = new Doc("(tan v): number?", [
    "v: number?"
  ], "Returns the tangent of `v`.");
  var asin = new Doc("(asin v): number?", [
    "v: number?"
  ], "Returns the arc sine of `v`.");
  var acos = new Doc("(acos v): number?", [
    "v: number?"
  ], "Returns the arc cosine of `v`.");
  var atan = new Doc("(atan v): number?", [
    "v: number?"
  ], "Returns the arc tangent of `v`.");
  var not = new Doc("(not v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is `#f`.");
  var boolean = new Doc("(boolean? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a boolean.");
  var nand = new Doc("(nand v1 v2 ...): boolean?", [
    "v: boolean?"
  ], "Equivalent to `(not (and v1 v2 ...))`.");
  var nor = new Doc("(nor v1 v2 ...): boolean?", [
    "v: boolean?"
  ], "Equivalent to `(not (or v1 v2 ...))`.");
  var implies = new Doc("(implies v1 v2): boolean?", [
    "v1: boolean?",
    "v2: boolean?"
  ], "Equivalent to `(if v1 v2 #t)`.");
  var xor = new Doc("(xor v1 v2): boolean?", [
    "v1: boolean?",
    "v2: boolean?"
  ], "Equivalent to `(or (and v1 (not v2)) (and (not v1) v2))`.");
  var pairQ = new Doc("(pair? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a pair.");
  var cons = new Doc("(cons v1 v2): pair?", [
    "v1: any",
    "v2: any"
  ], "Returns a new pair containing `v1` and `v2`.");
  var pair = new Doc("(pair v1 v2): pair?", [
    "v1: any",
    "v2: any"
  ], "Returns a new pair containing `v1` and `v2`.");
  var car = new Doc("(car v): any", [
    "v: pair?"
  ], "Returns the first element of `v`.");
  var cdr = new Doc("(cdr v): any", [
    "v: pair?"
  ], "Returns the second element of `v`.");
  var nullQ = new Doc("(null? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is the empty list.");
  var listQ = new Doc("(list? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a list.");
  var list = new Doc("(list v1 v2 ...): list?", [
    "v: any"
  ], "Returns a new list containing `v1`, `v2`, ... .");
  var makeList = new Doc("(make-list n v): list?", [
    "n: integer?",
    "v: any"
  ], "Returns a new list containing `n` copies of `v`.");
  var length = new Doc("(length v): integer?", [
    "v: list?"
  ], "Returns the length of `v`.");
  var append = new Doc("(append l1 l2 ...): list?", [
    "l: list?"
  ], "Returns a new list containing the elements of lists `l1`, `l2`, ... in sequence.");
  var reverse = new Doc("(reverse l): list?", [
    "l: list?"
  ], "Returns a new list containing the elements of `l` in reverse order.");
  var charQ = new Doc("(char? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a character.");
  var charEq = new Doc("(char=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... are all equivalent characters.");
  var charLt = new Doc("(char<? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have strictly increasing character values.");
  var charGt = new Doc("(char>? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have strictly decreasing character values.");
  var charLeq = new Doc("(char<=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have non-decreasing character values.");
  var charGeq = new Doc("(char>=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have non-increasing character values.");
  var charEqCi = new Doc("(char-ci=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... are all equivalent characters, ignoring case.");
  var charLtCi = new Doc("(char-ci<? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have strictly increasing character values, ignoring case.");
  var charGtCi = new Doc("(char-ci>? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have strictly decreasing character values, ignoring case.");
  var charLeqCi = new Doc("(char-ci<=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have non-decreasing character values, ignoring case.");
  var charGeqCi = new Doc("(char-ci>=? c1 c2 ...): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c1`, `c2`, ... have non-increasing character values, ignoring case.");
  var charAlphabetic = new Doc("(char-alphabetic? c): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c` is an alphabetic character.");
  var charNumeric = new Doc("(char-numeric? c): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c` is a numeric character.");
  var charWhitespace = new Doc("(char-whitespace? c): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c` is a whitespace character.");
  var charUpperCase = new Doc("(char-upper-case? c): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c` is an upper-case character.");
  var charLowerCase = new Doc("(char-lower-case? c): boolean?", [
    "c: char?"
  ], "Returns `#t` if and only `c` is a lower-case character.");
  var digitValue = new Doc("(digit-value c): integer?", [
    "c: char?"
  ], "Returns the numeric value of `c` if `c` is a decimal digit (0-10), otherwise raises an error.");
  var charToInteger = new Doc("(char->integer c): integer?", [
    "c: char?"
  ], "Returns the codepoint value of character `c`.");
  var integerToChar = new Doc("(integer->char n): char?", [
    "n: integer?"
  ], "Returns the character with codepoint value `n`.");
  var charUpcase = new Doc("(char-upcase c): char?", [
    "c: char?"
  ], "Returns the upper-case equivalent of `c`.");
  var charDowncase = new Doc("(char-downcase c): char?", [
    "c: char?"
  ], "Returns the lower-case equivalent of `c`.");
  var charFoldcase = new Doc("(char-foldcase c): char?", [
    "c: char?"
  ], "Returns the case-folded equivalent of `c`. This is a version of `c` that is appropriate for case-insensitive comparison.");
  var stringQ = new Doc("(string? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a string.");
  var makeString = new Doc("(make-string k c): string?", [
    "k: integer?",
    "c: char?"
  ], "Returns a string of length `k` with each character set to `c`.");
  var string = new Doc("(string c1 c2 ...): string?", [
    "c: char?"
  ], "Returns a string consisting of the characters `c1`, `c2`, ...");
  var stringLength = new Doc("(string-length v): integer?", [
    "v: string?"
  ], "Returns the length of `v`.");
  var stringRef = new Doc("(string-ref s n): string?", [
    "s: string?",
    "n: integer?"
  ], "Returns the character at index `n` of string `s`.");
  var stringEq = new Doc("(string=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are equivalent strings.");
  var stringLt = new Doc("(string<? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in strictly lexicographically increasing order.");
  var stringGt = new Doc("(string>? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in strictly lexicographically decreasing order.");
  var stringLeq = new Doc("(string<=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in lexicographical order.");
  var stringGeq = new Doc("(string>=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in reverse lexicographical order.");
  var stringEqCi = new Doc("(string-ci=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are equivalent strings, ignoring case.");
  var stringLtCi = new Doc("(string-ci<? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in strictly lexicographically increasing order, ignoring case.");
  var stringGtCi = new Doc("(string-ci>? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in strictly lexicographically decreasing order, ignoring case.");
  var stringLeqCi = new Doc("(string-ci<=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in lexicographical order, ignoring case.");
  var stringGeqCi = new Doc("(string-ci>=? s1 s2 ...): boolean?", [
    "s: string?"
  ], "Returns `#t` if and only `s1`, `s2`, ... are in reverse lexicographical order, ignoring case.");
  var stringUpcase = new Doc("(string-upcase s): string?", [
    "s: string?"
  ], "Returns the upper-case version of `s`.");
  var stringDowncase = new Doc("(string-downcase s): string?", [
    "s: string?"
  ], "Returns the lower-case version of `s`.");
  var stringFoldcase = new Doc("(string-foldcase s): string?", [
    "s: string?"
  ], "Returns the case-folded version of `s`. This is a version of `s` that is appropriate for case-insensitive comparison.");
  var substring = new Doc("(substring s start end): string?", [
    "s: string?",
    "start: integer?",
    "end: integer?"
  ], "Returns the substring of `s` from index `start` (inclusive) to index `end` (exclusive).");
  var stringAppend = new Doc("(string-append s1 s2 ...): string?", [
    "s: string?"
  ], "Returns a string made by joining `s1`, `s2`, ... together.");
  var stringList = new Doc("(string->list s): list?", [
    "s: string?"
  ], "Returns a list of the characters in `s`.");
  var listString = new Doc("(list->string l): string?", [
    "l: list?"
  ], "Returns a string made by joining the characters in `l` together.");
  var stringSplit = new Doc("(string-split s sep): list?", [
    "s: string?",
    "sep: string?"
  ], "Returns a list of strings obtained by splitting `s` at occurrences of `sep`.");
  var procedure = new Doc("(procedure? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a procedure.");
  var apply = new Doc("(apply f v1 v2 ...): any", [
    "f: procedure?",
    "v: any"
  ], "Calls `f` with arguments `v1`, `v2`, ... .");
  var stringMap = new Doc("(string-map f s): string?", [
    "f: procedure?, a function from characters to characters",
    "s: string?"
  ], "Returns a new string containing the results of applying `f` to each character of `s`.");
  var map = new Doc("(map f l): list?", [
    "f: procedure?",
    "l: list?"
  ], "Returns a new list containing the results of applying `f` to each element of `l`.");
  var filter = new Doc("(filter f l): list?", [
    "f: procedure?, a predicate",
    "l: list?"
  ], "Returns a new list containing the elements of `l` for which `f` returns `#t`.");
  var fold = new Doc("(fold f v l): any", [
    "f: procedure?, a binary function",
    "v: any",
    "l: list?"
  ], "Returns the result of accumulating the result of applying `f` to each element of `l`, starting with initial value `v`.");
  var reduce = new Doc("(reduce f l): any", [
    "f: procedure?, a binary function",
    "l: list?, non-empty"
  ], "Like `fold` but uses the first element of `l` as the initial value.");
  var error2 = new Doc("(error msg): any", [
    "msg: string?"
  ], "Raises a runtime error with message `msg`.");
  var qq = new Doc("{??}: any", [], "A placeholder for an expression that is not yet implemented.");
  var image = new Doc("(image? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is an image.");
  var color = new Doc("(color r b g a): string?", [
    "r: integer?, 0 <= r <= 255",
    "b: integer?, 0 <= b <= 255",
    "g: integer?, 0 <= g <= 255",
    "a: integer?, 0 <= a <= 1"
  ], 'Returns a string of the form `"rgba(r, g, b, a)"` appropriate for use as a color.');
  var ellipse = new Doc("(ellipse width height fill color): drawing?", [
    "width: integer?",
    "height: integer?",
    "fill: boolean?",
    "color: string?"
  ], "Returns a new drawing containing an ellipse with dimensions `width \xD7 height`.");
  var circle = new Doc("(circle radius fill color): drawing?", [
    "radius: number?",
    'fill: string?, either "solid" or "outline"',
    'color: string?, either a color name or the form "rgba(r, g, b, a)"'
  ], "Returns a drawing consisting of a circle of radius `radius`.");
  var rectangle = new Doc("(rectangle width height fill color): drawing?", [
    "width: number?",
    "height: number?",
    'fill: string?, either "solid" or "outline"',
    'color: string?, either a color name or the form "rgba(r, g, b, a)"'
  ], "Returns a drawing consisting of a rectangle with dimensions `width \xD7 height`.");
  var drawingSquare = new Doc("(square width fill color): drawing?", [
    "width: number?",
    'fill: string?, either "solid" or "outline"',
    'color: string?, either a color name or the form "rgba(r, g, b, a)"'
  ], "Returns a drawing consisting of a square with length `width`.");
  var triangle = new Doc("(triangle length fill color): drawing?", [
    "length: number?",
    'fill: string?, either "solid" or "outline"',
    'color: string?, either a color name or the form "rgba(r, g, b, a)"'
  ], "Returns a drawing consisting of a equilateral triangle with length `length`.");
  var path = new Doc("(path width height points fill color): drawing?", [
    "width: number?",
    "height: number?",
    "points: list?, a list of points, pairs of numbers",
    'fill: string?, either "solid" or "outline"',
    'color: string?, either a color name or the form "rgba(r, g, b, a)"'
  ], "Returns a drawing with dimensions `width \xD7 height` formed by connecting the points in `points` with straight lines. The points are specified as a `pair` of coordinates.");
  var beside = new Doc("(beside d1 d2 ...): drawing?", [
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., beside each other (horizontally).");
  var besideAlign = new Doc("(beside/align align d1 d2 ...): drawing?", [
    'align: string?, either "top", "center", or "bottom"',
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., beside each other on the x-axis, aligning them along the y-axis according to `align`.");
  var above = new Doc("(above d1 d2 ...): drawing?", [
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., above each other (vertically in descending order).");
  var aboveAlign = new Doc("(above/align align d1 d2 ...): drawing?", [
    'align: string?, either "left", "middle", or "right"',
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., above each other on the y-axis, aligning them along the x-axis according to `align`.");
  var overlay = new Doc("(overlay d1 d2 ...): drawing?", [
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., on top of each other. (`d1` is the topmost drawing).");
  var overlayAlign = new Doc("(overlay/align xAlign yAlign d1 d2 ...): drawing?", [
    'xAlign: string?, either "left", "middle", or "right"',
    'yAlign: string?, either "top", "center", or "bottom"',
    "d: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1`, `d2`, ..., on top of each other, aligning them according to `xAlign` and `yAlign`.");
  var overlayOffset = new Doc("(overlay/offset d1 dx dy d2): drawing?", [
    "d1: drawing?",
    "dx: number?",
    "dy: number?",
    "d2: drawing?"
  ], "Creates a new drawing formed by places the drawing `d1` on top of `d2`, offset by `(dx, dy)`.");
  var rotate = new Doc("(rotate angle d): drawing?", [
    "angle: number?, in degrees",
    "d: drawing?"
  ], "Returns a new drawing formed by rotating drawing `d` by `angle` degrees around the center of its bounding box. Note: currently buggy and shifts off-center.");
  var withDashes = new Doc("(with-dashes dash-spec d): drawing?", [
    "dash-spec: list?, a list of numbers",
    "d: drawing?"
  ], "Returns a new drawing formed by drawing `d` but with dashes specified by `dash-spec`. `dash-spec` is an list of numbers where each successive pair of numbers describe the length of a dash and the length of the subsequent gap.");
  var pitch = new Doc("(pitch? v): boolean?", [
    "v: any"
  ], 'Returns `#t` if and only `v` is a valid pitch, a string denoting a pitch class, e.g., `"Ab"`.');
  var octave = new Doc("(octave? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a valid octave, an integer in the range (0, 10).");
  var durQ = new Doc("(dur? v): boolean?", [
    "v: any"
  ], "Returns `#t` if and only `v` is a valid duration object.");
  var dur = new Doc("(dur num den): duration?", [
    "num: integer?",
    "den: integer?"
  ], "Creates a new duration object representing the ratio `num/den`.");
  var note = new Doc("(note pit oct dur): composition?", [
    "pit: pitch?",
    "oct: integer?",
    "dur: dur?"
  ], "Creates a new composition consisting of a single note from the given pitch, octave, and duration.");
  var rest = new Doc("(rest dur): composition?", [
    "dur: dur?"
  ], "Creates a new composition consisting of a single rest from the given duration.");
  var par = new Doc("(par comp1 comp2 ...): composition?", [
    "comp: composition?"
  ], "Creates a new composition that plays `comp1`, `comp2`, ..., in parallel.");
  var seq = new Doc("(seq comp1 comp2 ...): composition?", [
    "comp: composition?"
  ], "Creates a new composition that plays `comp1`, `comp2`, ..., in sequence.");
  var mod = new Doc("(mod kind comp): composition?", [
    "kind: mod?",
    "comp: composition?"
  ], "Creates a new composition that plays `comp` with the given modification `mod`.");
  var bend = new Doc("(bend amount): composition?", [
    "amount: number?, -1 <= amount <= 1"
  ], "Creates a new composition where the pitch is bent by a factor of `amount \xD7 2` semitones. If `amount = 0`, then the pitch is played normally.");
  var tempo = new Doc("(tempo beat bpm comp): composition?", [
    "beat: dur?, the pulse of the tempo",
    "bpm: number?, beats per minute",
    "comp: composition?"
  ], "Creates a new composition that plays `comp` at the given `beat` and `bpm`.");

  // dist/pretty.js
  var namedCharTable = new Map(Array.from(namedCharValues.entries()).map(([name2, value]) => [value, name2]));
  function charToName(s) {
    return namedCharTable.get(s) ?? s;
  }
  function litToString2(l) {
    switch (l.tag) {
      case "bool":
        return l.value ? "#t" : "#f";
      case "num":
        return l.value.toString();
      case "char":
        return `#\\${charToName(l.value)}`;
      case "str":
        return `"${l.value}"`;
    }
  }
  function isSimpleExp(e) {
    switch (e.tag) {
      case "var":
        return true;
      case "lit":
        return true;
      case "call":
        return e.args.every(isSimpleExp);
      case "lam":
        return false;
      case "if":
        return false;
      case "nil":
        return true;
      case "pair":
        return true;
      case "let":
        return false;
      case "cond":
        return false;
      case "and":
        return true;
      case "or":
        return true;
      case "struct":
        return true;
      case "obj":
        return true;
      case "prim":
        return true;
    }
  }
  function nestingDepth(e) {
    switch (e.tag) {
      case "var":
        return 0;
      case "lit":
        return 0;
      case "call":
        return 1 + Math.max(...e.args.map(nestingDepth));
      case "lam":
        return 1 + nestingDepth(e.body);
      case "if":
        return 1 + Math.max(nestingDepth(e.e1), nestingDepth(e.e2), nestingDepth(e.e3));
      case "nil":
        return 0;
      case "pair":
        return 1 + Math.max(nestingDepth(e.e1), nestingDepth(e.e2));
      case "let":
        return 0;
      case "cond":
        return 0;
      case "and":
        return 0;
      case "or":
        return 0;
      case "struct":
        return 0;
      case "obj":
        return 0;
      case "prim":
        return 0;
    }
  }
  function parens2(bracketKind, ss, sep = " ") {
    switch (bracketKind) {
      case "(":
        return `(${ss.join(sep)})`;
      case "{":
        return `{${ss.join(sep)}}`;
      case "[":
        return `[${ss.join(sep)}]`;
    }
  }
  function indent(col, s) {
    return `${" ".repeat(col)}${s}`;
  }
  function expToString2(col, e, htmlOutput = false) {
    switch (e.tag) {
      case "var":
        return e.value;
      case "lit":
        return litToString2(e.value);
      case "call": {
        const allExps = [e.head, ...e.args];
        if (allExps.every(isSimpleExp) && allExps.every((e2) => nestingDepth(e2) <= 4) && e.args.length <= 5) {
          return parens2(e.bracket, [e.head].concat(e.args).map((arg) => expToString2(col, arg, htmlOutput)));
        } else {
          return parens2(e.bracket, [
            `${expToString2(col, e.head, htmlOutput)}`,
            ...e.args.map((arg) => `${indent(col + 2, expToString2(col + 2, arg, htmlOutput))}`)
          ], "\n");
        }
      }
      case "lam": {
        const preamble = `(lambda ${parens2(e.bracket, e.args.map((n) => n.value))}`;
        if (isSimpleExp(e.body)) {
          return [preamble, `${expToString2(col, e.body, htmlOutput)})`].join(" ");
        } else {
          return [preamble, `${indent(col + 2, expToString2(col + 2, e.body, htmlOutput))}`].join("\n");
        }
      }
      case "if": {
        return parens2(e.bracket, [
          `if ${expToString2(col, e.e1, htmlOutput)}`,
          `${indent(col + 2, expToString2(col + 2, e.e2, htmlOutput))}`,
          `${indent(col + 2, expToString2(col + 2, e.e3, htmlOutput))}`
        ], "\n");
      }
      case "nil":
        return "null";
      case "pair":
        return isList(e) ? parens2(e.bracket, ["list"].concat(unsafeListToArray(e).map((arg) => expToString2(col, arg, htmlOutput)))) : parens2(e.bracket, ["cons", expToString2(col, e.e1, htmlOutput), expToString2(col, e.e2, htmlOutput)]);
      case "let": {
        const preamble = "let ";
        const firstBinding = `${indent(col + 2, `([${e.bindings[0][0].value} ${expToString2(col + 2 + e.bindings[0][0].value.length + 1, e.bindings[0][1], htmlOutput)}]`)}`;
        const bindings = e.bindings.length == 1 ? firstBinding + ")" : [firstBinding, ...e.bindings.slice(1).map((b) => `${indent(col + 2 + 1, `[${b[0].value} ${expToString2(col + 2 + 1 + b[0].value.length + 1, b[1], htmlOutput)}]`)}`)].join("\n") + ")";
        const body = `${indent(col + 2, `${expToString2(col + 2, e.body, htmlOutput)}`)}`;
        return parens2(e.bracket, [preamble, bindings, body], "\n");
      }
      case "cond": {
        const preamble = "cond ";
        const bindings = e.branches.map((b) => indent(col + 2, `[${expToString2(col + 2, b[0], htmlOutput)} ${expToString2(col + 2, b[1], htmlOutput)}]`));
        return parens2(e.bracket, [preamble, ...bindings], "\n");
      }
      case "and":
        return parens2(e.bracket, ["and", ...e.args.map((arg) => expToString2(col + 2, arg, htmlOutput))]);
      case "or":
        return parens2(e.bracket, ["or", ...e.args.map((arg) => expToString2(col + 2, arg, htmlOutput))]);
      case "struct":
        return parens2("(", [`struct ${e.kind}`, ...Object.keys(e.obj).map((k) => expToString2(col, e.obj[k], htmlOutput))]);
      case "obj":
        if (htmlOutput && e.kind === "Drawing") {
          return `<span class="drawing">${JSON.stringify(e.obj)}</span>`;
        } else if (htmlOutput && e.kind === "Composition") {
          return `<span class="composition">${JSON.stringify(e.obj)}</span>`;
        } else {
          return `[object ${e.kind}]`;
        }
      case "prim":
        return `[prim ${e.prim.name}]`;
    }
  }
  function stmtToString(col, stmt, outputBindings = false, htmlOutput = false) {
    switch (stmt.tag) {
      case "define": {
        const preamble = `(define ${stmt.name.value}`;
        return isSimpleExp(stmt.value) ? `${preamble} ${expToString2(col, stmt.value, htmlOutput)}` : `${preamble}
${indent(col + 2, expToString2(col + 2, stmt.value, htmlOutput))}`;
      }
      case "struct":
        return `(struct ${stmt.id.value} (${stmt.fields.map((f) => f.value).join(" ")}))`;
      case "exp":
        return expToString2(col, stmt.value, htmlOutput);
      case "import":
        return `(import ${stmt.source})`;
      case "error":
        return stmt.errors.map((err) => detailsToCompleteString(err)).join("\n");
      case "binding":
        return outputBindings ? `[[${stmt.name} bound]]` : "";
      case "value":
        return expToString2(col, stmt.value, htmlOutput);
      case "imported":
        return outputBindings ? `[[${stmt.source} imported]]` : "";
    }
  }
  function progToString(col, prog, outputBindings = false, htmlOutput = false) {
    return prog.statements.map((s) => stmtToString(col, s, outputBindings, htmlOutput)).filter((s) => s.length > 0).join("\n");
  }

  // dist/lib/prelude.js
  function asNumbers(args) {
    const result = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const e = args[i];
      if (e.tag === "lit") {
        if (e.value.tag === "num") {
          result[i] = e.value.value;
        } else {
          return runtimeError(msg("error-type-expected", "number?", e.value.tag), e);
        }
      } else {
        return runtimeError(msg("error-type-expected", "number?", e.tag));
      }
    }
    return ok(result);
  }
  var equalPrim = (_env, args, app) => checkArgsResult("equal?", ["any", "any"], void 0, args, app).andThen((_) => ok(nlebool(expEquals(args[0], args[1]))));
  var equivalencePrimitives = [
    ["equal?", equalPrim, equal]
  ];
  var numberPrim = (_env, args, app) => checkArgsResult("number?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isNumber(args[0]))));
  var realPrim = (_env, args, app) => checkArgsResult("real?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isReal(args[0]))));
  var integerPrim = (_env, args, app) => checkArgsResult("integer?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isInteger(args[0]))));
  var nanPrim = (_env, args, app) => checkArgsResult("nan?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(Number.isNaN(asNum_(args[0])))));
  function compareOp(symbol, op, args, app) {
    return checkArgsResult(symbol, ["number?", "number?"], void 0, args, app).andThen((_) => asNumbers(args).andThen((vs) => ok(nlebool(op(vs[0], vs[1])))));
  }
  var ltPrim = (_env, args, app) => compareOp("<", (x, y) => x < y, args, app);
  var leqPrim = (_env, args, app) => compareOp("<=", (x, y) => x <= y, args, app);
  var gtPrim = (_env, args, app) => compareOp(">", (x, y) => x > y, args, app);
  var geqPrim = (_env, args, app) => compareOp(">=", (x, y) => x >= y, args, app);
  var numeqPrim = (_env, args, app) => compareOp("=", (x, y) => x === y, args, app);
  var zeroPrim = (_env, args, app) => checkArgsResult("zero?", ["number?"], void 0, args, app).andThen((_) => ok(nlebool(asNum_(args[0]) === 0)));
  var positivePrim = (_env, args, app) => checkArgsResult("positive?", ["number?"], void 0, args, app).andThen((_) => ok(nlebool(asNum_(args[0]) > 0)));
  var negativePrim = (_env, args, app) => checkArgsResult("negative?", ["number?"], void 0, args, app).andThen((_) => ok(nlebool(asNum_(args[0]) < 0)));
  var oddPrim = (_env, args, app) => checkArgsResult("odd?", ["number?"], void 0, args, app).andThen((_) => ok(nlebool((asNum_(args[0]) & 1) === 1)));
  var evenPrim = (_env, args, app) => checkArgsResult("even?", ["number?"], void 0, args, app).andThen((_) => ok(nlebool((asNum_(args[0]) & 1) !== 1)));
  function numericUOp(symbol, op, args, app) {
    return checkArgsResult(symbol, ["number?"], void 0, args, app).andThen((_) => asNumbers(args).andThen((vs) => ok(nlenumber(op(vs[0])))));
  }
  function numericBOp(symbol, op, args, app) {
    return checkArgsResult(symbol, ["number?", "number?"], void 0, args, app).andThen((_) => asNumbers(args).andThen((vs) => ok(nlenumber(op(vs[0], vs[1])))));
  }
  function numericNOp(symbol, op, args, app) {
    return checkArgsResult(symbol, ["number?"], "number?", args, app).andThen((_) => asNumbers(args).andThen((vs) => ok(nlenumber(vs.reduce(op)))));
  }
  var maxPrim = (_env, args, app) => numericNOp("max", (x, y) => Math.max(x, y), args, app);
  var minPrim = (_env, args, app) => numericNOp("min", (x, y) => Math.min(x, y), args, app);
  var plusPrim = (_env, args, app) => numericNOp("+", (x, y) => x + y, args, app);
  var minusPrim = (_env, args, app) => numericNOp("-", (x, y) => x - y, args, app);
  var timesPrim = (_env, args, app) => numericNOp("*", (x, y) => x * y, args, app);
  var divPrim = (_env, args, app) => numericNOp("/", (x, y) => x / y, args, app);
  var absPrim = (_env, args, app) => numericUOp("abs", (x) => Math.abs(x), args, app);
  var quotientPrim = (_env, args, app) => numericBOp("quotient", (x, y) => Math.trunc(x / y), args, app);
  var remainderPrim = (_env, args, app) => numericBOp("remainder", (x, y) => x % y, args, app);
  var moduloPrim = (_env, args, app) => numericBOp("modulo", (x, y) => (x % y + y) % y, args, app);
  var floorPrim = (_env, args, app) => numericUOp("floor", (x) => Math.floor(x), args, app);
  var ceilingPrim = (_env, args, app) => numericUOp("ceiling", (x) => Math.ceil(x), args, app);
  var truncatePrim = (_env, args, app) => numericUOp("truncate", (x) => Math.trunc(x), args, app);
  var roundPrim = (_env, args, app) => numericUOp("round", (x) => Math.round(x), args, app);
  var squarePrim = (_env, args, app) => numericUOp("square", (x) => Math.pow(x, 2), args, app);
  var sqrtPrim = (_env, args, app) => numericUOp("sqrt", (x) => Math.sqrt(x), args, app);
  var exptPrim = (_env, args, app) => numericBOp("expt", (x, y) => Math.pow(x, y), args, app);
  var numberStringPrim = (_env, args, app) => {
    const argErr = checkArgsResult("number->string", ["number?"], void 0, args, app);
    const e = args[0];
    return ok(nlestr(asNum_(e).toString()));
  };
  var stringNumberPrim = (_env, args, app) => {
    const argErr = checkArgs("string->number", ["string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const s = asString_(args[0]);
    if (/^[+-]?\d+$/.test(s)) {
      return ok(nlenumber(parseInt(s)));
    } else if (/^[+-]?(\d+|(\d*\.\d+)|(\d+\.\d*))([eE][+-]?\d+)?$/.test(s)) {
      return ok(nlenumber(parseFloat(s)));
    } else {
      return runtimeError(msg("error-runtime-parsing", "string->number", expToString(args[0]), "number"), app);
    }
  };
  var expPrim = (_env, args, app) => numericUOp("exp", (x) => Math.exp(x), args, app);
  var logPrim = (_env, args, app) => numericUOp("log", (x) => Math.log(x), args, app);
  var sinPrim = (_env, args, app) => numericUOp("sin", (x) => Math.sin(x), args, app);
  var cosPrim = (_env, args, app) => numericUOp("cos", (x) => Math.cos(x), args, app);
  var tanPrim = (_env, args, app) => numericUOp("tan", (x) => Math.tan(x), args, app);
  var asinPrim = (_env, args, app) => numericUOp("asin", (x) => Math.asin(x), args, app);
  var acosPrim = (_env, args, app) => numericUOp("acos", (x) => Math.acos(x), args, app);
  var atanPrim = (_env, args, app) => numericUOp("atan", (x) => Math.atan(x), args, app);
  var numericPrimitives = [
    ["number?", numberPrim, number],
    ["real?", realPrim, real],
    ["integer?", integerPrim, integer],
    ["nan?", nanPrim, nanQ],
    ["<", ltPrim, lt],
    ["<=", leqPrim, leq],
    [">", gtPrim, gt],
    [">=", geqPrim, geq],
    ["=", numeqPrim, numeq],
    ["zero?", zeroPrim, zero],
    ["positive?", positivePrim, positive],
    ["negative?", negativePrim, negative],
    ["odd?", oddPrim, odd],
    ["even?", evenPrim, even],
    ["max", maxPrim, max],
    ["min", minPrim, min],
    ["+", plusPrim, plus],
    ["-", minusPrim, minus],
    ["*", timesPrim, times],
    ["/", divPrim, div],
    ["abs", absPrim, abs],
    ["quotient", quotientPrim, quotient],
    ["remainder", remainderPrim, remainder],
    ["modulo", moduloPrim, modulo],
    ["floor", floorPrim, floor],
    ["ceiling", ceilingPrim, ceiling],
    ["truncate", truncatePrim, truncate],
    ["round", roundPrim, round],
    ["square", squarePrim, square],
    ["sqrt", sqrtPrim, sqrt],
    ["expt", exptPrim, expt],
    ["number->string", numberStringPrim, numberString],
    ["string->number", stringNumberPrim, stringNumber],
    ["exp", expPrim, exp],
    ["log", logPrim, log],
    ["sin", sinPrim, sin],
    ["cos", cosPrim, cos],
    ["tan", tanPrim, tan],
    ["asin", asinPrim, asin],
    ["acos", acosPrim, acos],
    ["atan", atanPrim, atan]
  ];
  var notPrim = (_env, args, app) => checkArgsResult("not", ["boolean?"], "boolean?", args, app).andThen((_) => ok(nlebool(!asBool_(args[0]))));
  var booleanPrim = (_env, args, app) => checkArgsResult("boolean?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(isBoolean(args[0]))));
  var nandPrim = (env, args, app) => checkArgsResult("nand", [], "boolean?", args, app).andThen((_) => evaluateExp(env, nlecall(nlevar("not"), [nleand(args)])));
  var norPrim = (env, args, app) => checkArgsResult("nand", [], "boolean?", args, app).andThen((_) => evaluateExp(env, nlecall(nlevar("not"), [nleor(args)])));
  var impliesPrim = (env, args, app) => checkArgsResult("implies", ["boolean?", "boolean?"], void 0, args, app).andThen((_) => evaluateExp(env, nleif(args[0], args[1], nlebool(true))));
  var xorPrim = (env, args, app) => checkArgsResult("xor", ["boolean?", "boolean?"], void 0, args, app).andThen((_) => evaluateExp(env, nleor([
    nleand([args[0], nlecall(nlevar("not"), [args[1]])]),
    nleand([nlecall(nlevar("not"), [args[0]]), args[1]])
  ])));
  var booleanPrimitives = [
    ["not", notPrim, not],
    ["boolean?", booleanPrim, boolean],
    ["nand", nandPrim, nand],
    ["nor", norPrim, nor],
    ["implies", impliesPrim, implies],
    ["xor", xorPrim, xor]
  ];
  var pairQPrim = (_env, args, app) => checkArgsResult("pair?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(isPair(args[0]))));
  var consPrim = (_env, args, app) => checkArgsResult("cons", ["any", "any"], "pair?", args, app).andThen((_) => ok(epair(app.range, args[0], args[1])));
  var pairPrim = (_env, args, app) => checkArgsResult("pair", ["any", "any"], "pair?", args, app).andThen((_) => ok(epair(app.range, args[0], args[1])));
  var carPrim = (_env, args, app) => checkArgsResult("car", ["pair?"], "any", args, app).andThen((_) => ok(args[0].e1));
  var cdrPrim = (_env, args, app) => checkArgsResult("cdr", ["pair?"], "any", args, app).andThen((_) => ok(args[0].e2));
  var nullPrim = (_env, args, app) => checkArgsResult("null?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(args[0].tag === "nil")));
  var listQPrim = (_env, args, app) => checkArgsResult("list?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(isList(args[0]))));
  var pairListPrimitives = [
    ["pair?", pairQPrim, pairQ],
    ["cons", consPrim, cons],
    ["pair", pairPrim, pair],
    ["car", carPrim, car],
    ["cdr", cdrPrim, cdr],
    ["null?", nullPrim, nullQ],
    ["list?", listQPrim, listQ]
  ];
  var listPrim = function(_env, args, app) {
    return ok(arrayToList(args));
  };
  var makeListPrim = function(_env, args, app) {
    const argErr = checkArgs("make-list", ["number?", "any"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const n = asNum_(args[0]);
    const fill = args[1];
    let ret = nlenil();
    for (let i = 0; i < n; i++) {
      ret = nlepair(fill, ret);
    }
    return ok(ret);
  };
  var lengthPrim = function(_env, args, app) {
    const argErr = checkArgs("length", ["list?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    let length2 = 0;
    let e = args[0];
    while (e.tag !== "nil") {
      if (e.tag === "pair") {
        length2 += 1;
        e = e.e2;
      } else {
        throw new ICE("lengthPrim", `Processing a non-list that we thought was a list: ${expToString(app)}`);
      }
    }
    return ok(nlenumber(length2));
  };
  function appendOne_(l1, l2) {
    if (l1.tag === "nil") {
      return l2;
    } else if (l1.tag === "pair") {
      return nlepair(l1.e1, appendOne_(l1.e2, l2));
    } else {
      throw new ICE("appendOne", `Non-list passed: ${expToString(l1)}`);
    }
  }
  var appendPrim = function(_env, args, app) {
    const argErr = checkArgs("append", ["list?"], "list?", args, app);
    let ret = args[0];
    for (let i = 1; i < args.length; i++) {
      ret = appendOne_(ret, args[i]);
    }
    return ok(ret);
  };
  var reversePrim = function(_env, args, app) {
    const argErr = checkArgs("reverse", ["list?"], "list?", args, app);
    if (argErr) {
      return argErr;
    }
    const queue = [];
    let e = args[0];
    while (e.tag !== "nil") {
      queue.push(e);
      e = e.e2;
    }
    queue.reverse();
    let ret = nlenil();
    while (queue.length > 0) {
      const next = queue.pop();
      ret = nlepair(next.e1, ret);
    }
    return ok(ret);
  };
  var listPrimitives = [
    ["list", listPrim, list],
    ["make-list", makeListPrim, makeList],
    ["length", lengthPrim, length],
    ["append", appendPrim, append],
    ["reverse", reversePrim, reverse]
  ];
  var charQPrim = (_env, args, app) => checkArgsResult("char?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isChar(args[0]))));
  function pairwiseSatisfies(f, xs) {
    if (xs.length <= 1) {
      return true;
    } else {
      for (let i = 0; i < xs.length - 1; i++) {
        if (!f(xs[i], xs[i + 1])) {
          return false;
        }
      }
      return true;
    }
  }
  function mkCharComparePrim(name2, f) {
    return (_env, args, app) => {
      const err = checkArgs(name2, [], "char?", args, app);
      if (err) {
        return err;
      }
      return ok(nlebool(pairwiseSatisfies((a, b) => f(asChar_(a), asChar_(b)), args)));
    };
  }
  var charEqPrim = mkCharComparePrim("char=?", (a, b) => a === b);
  var charLtPrim = mkCharComparePrim("char<?", (a, b) => a.codePointAt(0) < b.codePointAt(0));
  var charGtPrim = mkCharComparePrim("char>?", (a, b) => a.codePointAt(0) > b.codePointAt(0));
  var charLeqPrim = mkCharComparePrim("char<=?", (a, b) => a.codePointAt(0) <= b.codePointAt(0));
  var charGeqPrim = mkCharComparePrim("char>=?", (a, b) => a.codePointAt(0) >= b.codePointAt(0));
  var charEqCiPrim = mkCharComparePrim("char-ci=?", (a, b) => a.toLowerCase() === b.toLowerCase());
  var charLtCiPrim = mkCharComparePrim("char-ci<?", (a, b) => a.toLowerCase().codePointAt(0) < b.toLowerCase().codePointAt(0));
  var charGtCiPrim = mkCharComparePrim("char-ci>?", (a, b) => a.toLowerCase().codePointAt(0) > b.toLowerCase().codePointAt(0));
  var charLeqCiPrim = mkCharComparePrim("char-ci<=?", (a, b) => a.toLowerCase().codePointAt(0) <= b.toLowerCase().codePointAt(0));
  var charGeqCiPrim = mkCharComparePrim("char-ci>=?", (a, b) => a.toLowerCase().codePointAt(0) >= b.toLowerCase().codePointAt(0));
  function mkCharPredicatePrim(name2, f) {
    return (_env, args, app) => {
      const err = checkArgs(name2, ["char?"], void 0, args, app);
      if (err) {
        return err;
      }
      return ok(nlebool(f(asChar_(args[0]))));
    };
  }
  var charAlphabeticPrim = mkCharPredicatePrim("char-alphabetic?", (a) => /\p{L}/gu.test(a));
  var charNumericPrim = mkCharPredicatePrim("char-numeric?", (a) => /\p{N}/gu.test(a));
  var charWhitespacePrim = mkCharPredicatePrim("char-whitespace?", (a) => /\p{Z}/gu.test(a));
  var charUpperCasePrim = mkCharPredicatePrim("char-upper-case?", (a) => /\p{Lu}/gu.test(a));
  var charLowerCasePrim = mkCharPredicatePrim("char-lower-case?", (a) => /\p{Ll}/gu.test(a));
  var digitValuePrim = (_env, args, app) => {
    const err = checkArgs("digit-value", ["char?"], void 0, args, app);
    if (err) {
      return err;
    }
    const char = asChar_(args[0]);
    const n = parseInt(char, 10);
    if (isNaN(n)) {
      return runtimeError(msg("error-precondition-not-met", "digit-value", "decimal digit", char), app);
    } else {
      return ok(nlenumber(n));
    }
  };
  var charIntegerPrim = (_env, args, app) => checkArgsResult("char->integer", ["char?"], void 0, args, app).andThen((_) => ok(nlenumber(asChar_(args[0]).codePointAt(0))));
  var integerCharPrim = (_env, args, app) => checkArgsResult("integer->char", ["integer?"], void 0, args, app).andThen((_) => ok(nlechar(String.fromCodePoint(asNum_(args[0])))));
  var charUpcasePrim = (_env, args, app) => checkArgsResult("char-upcase", ["char?"], void 0, args, app).andThen((_) => ok(nlechar(asChar_(args[0]).toUpperCase())));
  var charDowncasePrim = (_env, args, app) => checkArgsResult("char-downcase", ["char?"], void 0, args, app).andThen((_) => ok(nlechar(asChar_(args[0]).toLowerCase())));
  var charFoldcasePrim = (_env, args, app) => checkArgsResult("char-foldcase", ["char?"], "char?", args, app).andThen((_) => ok(nlechar(asChar_(args[0]).toLowerCase())));
  var stringQPrim = (_env, args, app) => checkArgsResult("string?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(isString(args[0]))));
  var makeStringPrim = (_env, args, app) => checkArgsResult("make-string", ["integer?", "char?"], "string?", args, app).andThen((_) => ok(nlestr(asChar_(args[1]).repeat(asNum_(args[0])))));
  var stringPrim = (_env, args, app) => checkArgsResult("string", ["char?"], "char?", args, app).andThen((_) => ok(nlestr(args.map((e) => asChar_(e)).join(""))));
  var stringLengthPrim = (_env, args, app) => checkArgsResult("string-length", ["string?"], void 0, args, app).andThen((_) => ok(nlenumber(asString_(args[0]).length)));
  var stringRefPrim = function(_env, args, app) {
    const argErr = checkArgs("string-ref", ["string?", "integer?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const str = asString_(args[0]);
    const i = asNum_(args[1]);
    if (i >= 0 && i < str.length) {
      return ok(nlechar(str[i]));
    } else {
      return runtimeError(msg("error-index-string", i, str), app);
    }
  };
  function mkStringComparePrim(name2, f) {
    return (_env, args, app) => checkArgsResult(name2, [], "string?", args, app).andThen((_) => ok(nlebool(pairwiseSatisfies((a, b) => f(asString_(a), asString_(b)), args))));
  }
  var stringEqPrim = mkStringComparePrim("string=?", (a, b) => a === b);
  var stringLtPrim = mkStringComparePrim("string<?", (a, b) => a < b);
  var stringGtPrim = mkStringComparePrim("string>?", (a, b) => a > b);
  var stringLeqPrim = mkStringComparePrim("string<=?", (a, b) => a <= b);
  var stringGeqPrim = mkStringComparePrim("string>=?", (a, b) => a >= b);
  var stringEqCiPrim = mkStringComparePrim("string-ci=?", (a, b) => a.toLowerCase() === b.toLowerCase());
  var stringLtCiPrim = mkStringComparePrim("string-ci<?", (a, b) => a.toLowerCase() < b.toLowerCase());
  var stringGtCiPrim = mkStringComparePrim("string-ci>?", (a, b) => a.toLowerCase() > b.toLowerCase());
  var stringLeqCiPrim = mkStringComparePrim("string-ci<=?", (a, b) => a.toLowerCase() <= b.toLowerCase());
  var stringGeqCiPrim = mkStringComparePrim("string-ci>=?", (a, b) => a.toLowerCase() >= b.toLowerCase());
  var stringUpcasePrim = (_env, args, app) => checkArgsResult("string-upcase", ["string?"], void 0, args, app).andThen((_) => ok(nlestr(asString_(args[0]).toUpperCase())));
  var stringDowncasePrim = (_env, args, app) => checkArgsResult("string-downcase", ["string?"], void 0, args, app).andThen((_) => ok(nlestr(asString_(args[0]).toLowerCase())));
  var stringFoldcasePrim = (_env, args, app) => checkArgsResult("string-foldcase", ["string?"], void 0, args, app).andThen((_) => ok(nlestr(asString_(args[0]).toLowerCase())));
  var substringPrim = (_env, args, app) => checkArgsResult("substring", ["string?", "integer?", "integer?"], void 0, args, app).andThen((_) => ok(nlestr(asString_(args[0]).substring(asNum_(args[1]), asNum_(args[2])))));
  var stringAppendPrim = (_env, args, app) => checkArgsResult("string-append", ["string?"], "string?", args, app).andThen((_) => ok(nlestr(args.map(asString_).join(""))));
  var stringListPrim = (_env, args, app) => {
    if (args.length !== 1 && args.length !== 3) {
      return runtimeError(msg("error-arity", "string->list", "1 or 3", args.length), app);
    }
    if (!isString(args[0])) {
      return runtimeError(msg("error-type-expected-fun", 1, "string->list", "string", args[0].tag), app);
    }
    const str = asString_(args[0]);
    let start, end;
    if (args.length === 1) {
      start = 0;
      end = str.length;
    } else {
      if (!isInteger(args[1])) {
        return runtimeError(msg("error-type-expected-fun", 2, "string->list", "integer", args[1].tag), app);
      }
      if (!isInteger(args[2])) {
        return runtimeError(msg("error-type-expected-fun", 3, "string->list", "integer", args[2].tag), app);
      }
      start = asNum_(args[1]);
      end = asNum_(args[2]);
    }
    return ok(arrayToList(str.substring(start, end).split("").map(nlechar)));
  };
  var listStringPrim = (_env, args, app) => checkArgsResult("list->string", ["list?"], void 0, args, app).andThen((_) => {
    const lst = asList_(args[0]);
    for (const e of lst) {
      if (!isChar(e)) {
        return runtimeError(msg("error-type-expected-fun", "list->string", 1, "list of chars", e), app);
      }
    }
    return ok(nlestr(asList_(args[0]).map(asChar_).join("")));
  });
  var stringSplitPrim = (_env, args, app) => checkArgsResult("string-split", ["string?", "string?"], void 0, args, app).andThen((_) => ok(arrayToList(asString_(args[0]).split(asString_(args[1])).map(nlestr))));
  var stringPrimitives = [
    ["char?", charQPrim, charQ],
    ["char=?", charEqPrim, charEq],
    ["char<?", charLtPrim, charLt],
    ["char>?", charGtPrim, charGt],
    ["char<=?", charLeqPrim, charLeq],
    ["char>=?", charGeqPrim, charGeq],
    ["char-ci=?", charEqCiPrim, charEqCi],
    ["char-ci<?", charLtCiPrim, charLtCi],
    ["char-ci>?", charGtCiPrim, charGtCi],
    ["char-ci<=?", charLeqCiPrim, charLeqCi],
    ["char-ci>=?", charGeqCiPrim, charGeqCi],
    ["char-alphabetic?", charAlphabeticPrim, charAlphabetic],
    ["char-numeric?", charNumericPrim, charNumeric],
    ["char-whitespace?", charWhitespacePrim, charWhitespace],
    ["char-upper-case?", charUpperCasePrim, charUpperCase],
    ["char-lower-case?", charLowerCasePrim, charLowerCase],
    ["digit-value", digitValuePrim, digitValue],
    ["char->integer", charIntegerPrim, charToInteger],
    ["integer->char", integerCharPrim, integerToChar],
    ["char-upcase", charUpcasePrim, charUpcase],
    ["char-downcase", charDowncasePrim, charDowncase],
    ["char-foldcase", charFoldcasePrim, charFoldcase],
    ["string?", stringQPrim, stringQ],
    ["make-string", makeStringPrim, makeString],
    ["string", stringPrim, string],
    ["string-length", stringLengthPrim, stringLength],
    ["string-ref", stringRefPrim, stringRef],
    ["string=?", stringEqPrim, stringEq],
    ["string<?", stringLtPrim, stringLt],
    ["string>?", stringGtPrim, stringGt],
    ["string<=?", stringLeqPrim, stringLeq],
    ["string>=?", stringGeqPrim, stringGeq],
    ["string-ci=?", stringEqCiPrim, stringEqCi],
    ["string-ci<?", stringLtCiPrim, stringLtCi],
    ["string-ci>?", stringGtCiPrim, stringGtCi],
    ["string-ci<=?", stringLeqCiPrim, stringLeqCi],
    ["string-ci>=?", stringGeqCiPrim, stringGeqCi],
    ["string-upcase", stringUpcasePrim, stringUpcase],
    ["string-downcase", stringDowncasePrim, stringDowncase],
    ["string-foldcase", stringFoldcasePrim, stringFoldcase],
    ["substring", substringPrim, substring],
    ["string->list", stringListPrim, stringList],
    ["list->string", listStringPrim, listString],
    ["string-split", stringSplitPrim, stringSplit],
    ["string-append", stringAppendPrim, stringAppend]
  ];
  var procedurePrim = (_env, args, app) => checkArgsResult("procedure?", ["any"], "boolean?", args, app).andThen((_) => ok(nlebool(isProcedure(args[0]))));
  var applyPrim = (env, args, app) => checkArgsResult("apply", ["procedure?"], "any", args, app).andThen((_) => evaluateExp(env, nlecall(args[0], [...args.slice(1)])));
  var stringMapPrim = (env, args, app) => checkArgsResult("string-map", ["procedure?", "string?"], "string?", args, app).andThen((_) => join(asString_(args[1]).split("").map((c) => evaluateExp(env, nlecall(args[0], [nlechar(c)])))).andThen((vs) => {
    for (const v of vs) {
      if (!isChar(v)) {
        return runtimeError(msg("error-precondition-not-met", "string-map", 1, "produces a character", expToString2(0, v)), app);
      }
    }
    return ok(nlestr(vs.map((v) => asChar_(v)).join("")));
  }));
  var mapPrim = (env, args, app) => checkArgsResult("map", ["procedure?", "list?"], "any", args, app).andThen((_) => evaluateExp(env, arrayToList(unsafeListToArray(args[1]).map((e) => nlecall(args[0], [e])))));
  var filterPrim = (env, args, app) => checkArgsResult("filter", ["procedure?", "list?"], void 0, args, app).andThen((_) => {
    const fn = args[0];
    const list2 = asList_(args[1]);
    const result = [];
    for (let i = 0; i < list2.length; i++) {
      const e = list2[i];
      const res = evaluateExp(env, nlecall(fn, [e]));
      if (res.tag === "error") {
        return res;
      } else if (!isBoolean(res.value)) {
        return runtimeError(msg("error-type-filter-bool", res.value.tag), args[0]);
      } else if (asBool_(res.value)) {
        result.push(e);
      }
    }
    return ok(arrayToList(result));
  });
  var foldPrim = (env, args, app) => checkArgsResult("fold", ["procedure?", "any", "list?"], void 0, args, app).andThen((_) => {
    const fn = args[0];
    let result = args[1];
    const list2 = asList_(args[2]);
    for (let i = 0; i < list2.length; i++) {
      const e = list2[i];
      const res = evaluateExp(env, nlecall(fn, [result, e]));
      if (res.tag === "error") {
        return res;
      } else {
        result = res.value;
      }
    }
    return ok(result);
  });
  var reducePrim = (env, args, app) => checkArgsResult("reduce", ["procedure?", "list?"], void 0, args, app).andThen((_) => {
    const fn = args[0];
    const list2 = asList_(args[1]);
    if (list2.length === 0) {
      return runtimeError(msg("error-precondition-not-met", "reduce", "2", "list is non-empty", expToString(args[1])), app);
    } else {
      return evaluateExp(env, nlecall(nlevar("fold"), [args[0], list2[0], arrayToList(list2.slice(1))]));
    }
  });
  var errorPrim = (_env, args, app) => checkArgsResult("error", ["string?"], void 0, args, app).andThen((_) => runtimeError(msg("error-runtime", asString_(args[0])), app));
  var qqPrim = (_env, args, app) => checkArgsResult("??", [], void 0, args, app).andThen((_) => runtimeError(msg("error-hole", "??"), app));
  var controlPrimitives = [
    ["procedure?", procedurePrim, procedure],
    ["apply", applyPrim, apply],
    ["string-map", stringMapPrim, stringMap],
    ["map", mapPrim, map],
    ["filter", filterPrim, filter],
    ["fold", foldPrim, fold],
    ["reduce", reducePrim, reduce],
    ["error", errorPrim, error2],
    ["??", qqPrim, qq]
  ];
  var preludeEnv = new Env([
    ...equivalencePrimitives,
    ...numericPrimitives,
    ...booleanPrimitives,
    ...pairListPrimitives,
    ...listPrimitives,
    ...stringPrimitives,
    ...controlPrimitives
  ].map((v) => [v[0], entry(nleprim(v[1]), "prelude", void 0, v[2])]));

  // dist/lib/image.js
  var colorPrim = (_env, args, app) => checkArgsResult("color", ["number?", "number?", "number?", "number?"], void 0, args, app).andThen((_) => {
    const r = asNum_(args[0]);
    const g = asNum_(args[1]);
    const b = asNum_(args[2]);
    const a = asNum_(args[3]);
    const isValid = (n) => n >= 0 && n <= 255;
    if (!isValid(r)) {
      return runtimeError(msg("error-precondition-not-met", "color", 1, "a number in the range 0--255", r), app);
    } else if (!isValid(g)) {
      return runtimeError(msg("error-precondition-not-met", "color", 2, "a number in the range 0--255", g), app);
    } else if (!isValid(b)) {
      return runtimeError(msg("error-precondition-not-met", "color", 3, "a number in the range 0--255", b), app);
    } else if (!(a >= 0 && a <= 1)) {
      return runtimeError(msg("error-precondition-not-met", "color", 4, "a number in the range 0--1", a), app);
    } else {
      return ok(nlestr(`rgba(${asNum_(args[0])}, ${asNum_(args[1])}, ${asNum_(args[2])}, ${asNum_(args[3])})`));
    }
  });
  var imagePrim = (_env, args, app) => checkArgsResult("image?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isObjKind_(args[0], "Drawing"))));
  var ellipse2 = (width, height, mode, color2) => ({
    tag: "ellipse",
    width,
    height,
    mode,
    color: color2
  });
  var ellipsePrim = (_env, args, app) => {
    const argErr = checkArgs("ellipse", ["number?", "number?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const width = asNum_(args[0]);
    const height = asNum_(args[1]);
    const mode = asString_(args[2]);
    const color2 = asString_(args[3]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "circle", "3", '"solid" or "outline"', mode), app);
    } else {
      return ok(nleobj("Drawing", ellipse2(width, height, mode, color2)));
    }
  };
  var circlePrim = (_env, args, app) => {
    const argErr = checkArgs("circle", ["number?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const radius = asNum_(args[0]);
    const mode = asString_(args[1]);
    const color2 = asString_(args[2]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "circle", "2", '"solid" or "outline"', mode), app);
    } else {
      return ok(nleobj("Drawing", ellipse2(radius * 2, radius * 2, mode, color2)));
    }
  };
  var rectangle2 = (width, height, mode, color2) => ({ tag: "rectangle", width, height, mode, color: color2 });
  var rectanglePrim = (_env, args, app) => {
    const argErr = checkArgs("rectangle", ["number?", "number?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const width = asNum_(args[0]);
    const height = asNum_(args[1]);
    const mode = asString_(args[2]);
    const color2 = asString_(args[3]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "rectangle", "3", '"solid" or "outline"', mode), app);
    } else {
      return ok(nleobj("Drawing", rectangle2(width, height, mode, color2)));
    }
  };
  var squarePrim2 = (_env, args, app) => {
    const argErr = checkArgs("square", ["number?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const width = asNum_(args[0]);
    const mode = asString_(args[1]);
    const color2 = asString_(args[2]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "square", "2", '"solid" or "outline"', mode), app);
    } else {
      return ok(nleobj("Drawing", rectangle2(width, width, mode, color2)));
    }
  };
  var triangle2 = (length2, mode, color2) => ({
    tag: "triangle",
    width: length2,
    height: length2 * Math.sqrt(3) / 2,
    length: length2,
    mode,
    color: color2
  });
  var trianglePrim = (_env, args, app) => {
    const argErr = checkArgs("triangle", ["number?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const length2 = asNum_(args[0]);
    const mode = asString_(args[1]);
    const color2 = asString_(args[2]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "triangle", "2", '"solid" or "outline"', mode), app);
    } else {
      return ok(nleobj("Drawing", triangle2(length2, mode, color2)));
    }
  };
  var path2 = (width, height, points, mode, color2) => ({ tag: "path", width, height, points, mode, color: color2 });
  var pathPrim = (_env, args, app) => {
    const argErr = checkArgs("path", ["number?", "number?", "list?", "string?", "string?"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const width = asNum_(args[0]);
    const height = asNum_(args[1]);
    const mode = asString_(args[3]);
    const color2 = asString_(args[4]);
    if (mode !== "solid" && mode !== "outline") {
      return runtimeError(msg("error-precondition-not-met", "path", "2", '"solid" or "outline"', mode), app);
    } else {
      const result = join(asList_(args[2]).map((e) => {
        if (isPair(e)) {
          const p = asPair_(e);
          if (!isNumber(p[0]) || !isNumber(p[1])) {
            return runtimeError(msg("error-type-expected-fun", 3, "path", "list of pairs of numbers", e.tag), e);
          }
          return ok([asNum_(p[0]), asNum_(p[1])]);
        } else {
          return runtimeError(msg("error-type-expected-fun", 3, "path", "list of pairs of numbers", e.tag), e);
        }
      }));
      return result.andThen((points) => ok(nleobj("Drawing", path2(width, height, points, mode, color2))));
    }
  };
  var beside2 = (align, drawings) => ({
    tag: "beside",
    align,
    width: drawings.reduce((acc, d) => acc + d.width, 0),
    height: Math.max(...drawings.map((d) => d.height)),
    drawings
  });
  var besidePrim = (_env, args, app) => {
    const argErr = checkArgs("beside", [], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    return ok(nleobj("Drawing", beside2("center", args.map((e) => e.obj))));
  };
  var besideAlignPrim = (_env, args, app) => {
    const argErr = checkArgs("beside-align", ["string?"], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    const align = asString_(args[0]);
    if (align !== "top" && align !== "center" && align !== "bottom") {
      return runtimeError(msg("error-precondition-not-met", "beside-align", "1", '"top", "center", or "bottom"', align), app);
    } else {
      return ok(nleobj("Drawing", beside2(align, args.slice(1).map((e) => e.obj))));
    }
  };
  var above2 = (align, drawings) => ({
    tag: "above",
    align,
    width: Math.max(...drawings.map((d) => d.width)),
    height: drawings.reduce((acc, d) => acc + d.height, 0),
    drawings
  });
  var abovePrim = (_env, args, app) => {
    const argErr = checkArgs("above", [], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    return ok(nleobj("Drawing", above2("middle", args.map((e) => e.obj))));
  };
  var aboveAlignPrim = (_env, args, app) => {
    const argErr = checkArgs("above-align", ["string?"], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    const align = asString_(args[0]);
    if (align !== "left" && align !== "middle" && align !== "right") {
      return runtimeError(msg("error-precondition-not-met", "above-align", "1", '"left", "middle", or "right"', align), app);
    } else {
      return ok(nleobj("Drawing", above2(align, args.slice(1).map((e) => e.obj))));
    }
  };
  var overlay2 = (xAlign, yAlign, drawings) => ({
    tag: "overlay",
    xAlign,
    yAlign,
    width: Math.max(...drawings.map((d) => d.width)),
    height: Math.max(...drawings.map((d) => d.height)),
    drawings
  });
  var overlayPrim = (_env, args, app) => {
    const argErr = checkArgs("overlay", [], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    return ok(nleobj("Drawing", overlay2("middle", "center", args.map((e) => e.obj))));
  };
  var overlayAlignPrim = (_env, args, app) => {
    const argErr = checkArgs("overlay-align", ["string?", "string?"], "Drawing", args, app);
    if (argErr) {
      return argErr;
    }
    const xAlign = asString_(args[0]);
    const yAlign = asString_(args[1]);
    if (xAlign !== "left" && xAlign !== "middle" && xAlign !== "right") {
      return runtimeError(msg("error-precondition-not-met", "overlay-align", "1", '"left", "middle", or "right"', xAlign), app);
    } else if (yAlign !== "top" && yAlign !== "center" && yAlign !== "bottom") {
      return runtimeError(msg("error-precondition-not-met", "overlay-align", "2", '"top", "center", or "bottom"', yAlign), app);
    } else {
      return ok(nleobj("Drawing", overlay2(xAlign, yAlign, args.slice(2).map((e) => e.obj))));
    }
  };
  var overlayOffset2 = (dx, dy, d1, d2) => {
    let width;
    if (d1.width >= d2.width) {
      width = dx >= 0 ? Math.max(d1.width, d2.width + Math.abs(dx)) : Math.abs(dx) + d1.width;
    } else {
      width = dx <= 0 ? Math.max(d2.width, d1.width + Math.abs(dx)) : Math.abs(dx) + d2.width;
    }
    let height;
    if (d1.height >= d2.height) {
      height = dy >= 0 ? Math.max(d1.height, d2.height + Math.abs(dy)) : Math.abs(dy) + d1.height;
    } else {
      height = dy <= 0 ? Math.max(d2.height, d1.height + Math.abs(dy)) : Math.abs(dy) + d2.height;
    }
    return {
      tag: "overlayOffset",
      dx,
      dy,
      width,
      height,
      d1,
      d2
    };
  };
  var overlayOffsetPrim = (_env, args, app) => {
    const argErr = checkArgs("overlay-offset", ["Drawing", "number?", "number?", "Drawing"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const dx = asNum_(args[1]);
    const dy = asNum_(args[2]);
    return ok(nleobj("Drawing", overlayOffset2(dx, dy, args[0].obj, args[3].obj)));
  };
  function calculateRotatedBox(width, height, degrees) {
    const angle = degrees * Math.PI / 180;
    const origPoints = [
      [-width / 2, -height / 2],
      [width / 2, -height / 2],
      [-width / 2, height / 2],
      [width / 2, height / 2]
    ];
    const rotatedPoints = origPoints.map(([x, y]) => [
      x * Math.cos(angle) - y * Math.sin(angle),
      x * Math.sin(angle) + y * Math.cos(angle)
    ]);
    const xMin = Math.min(...rotatedPoints.map(([x, _]) => x));
    const xMax = Math.max(...rotatedPoints.map(([x, _]) => x));
    const yMin = Math.min(...rotatedPoints.map(([_, y]) => y));
    const yMax = Math.max(...rotatedPoints.map(([_, y]) => y));
    return {
      width: xMax - xMin,
      height: yMax - yMin
    };
  }
  var rotate2 = (angle, drawing) => {
    const dims = calculateRotatedBox(drawing.width, drawing.height, angle);
    return {
      tag: "rotate",
      width: dims.width,
      height: dims.height,
      angle,
      drawing
    };
  };
  var rotatePrim = (_env, args, app) => {
    const argErr = checkArgs("rotate", ["number?", "Drawing"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const angle = asNum_(args[0]);
    return ok(nleobj("Drawing", rotate2(angle, args[1].obj)));
  };
  var withDash = (dashSpec, drawing) => ({
    tag: "withDash",
    dashSpec,
    drawing,
    width: drawing.width,
    height: drawing.height
  });
  var withDashPrim = (_env, args, app) => {
    const argErr = checkArgs("with-dash", ["list?", "Drawing"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const es = asList_(args[0]);
    for (const e of es) {
      if (!isNumber(e)) {
        runtimeError(msg("error-precondition-not-met", "with-dash", "1", "list of numbers", es), app);
      }
    }
    const dashes = es.map((e) => asNum_(e));
    return ok(nleobj("Drawing", withDash(dashes, args[1].obj)));
  };
  var imageEntry = (prim, docs) => entry(nleprim(prim), "image", void 0, docs);
  var imageLib = new Env([
    ["image?", imageEntry(imagePrim, image)],
    ["color", imageEntry(colorPrim, color)],
    ["ellipse", imageEntry(ellipsePrim, ellipse)],
    ["circle", imageEntry(circlePrim, circle)],
    ["rectangle", imageEntry(rectanglePrim, rectangle)],
    ["square", imageEntry(squarePrim2, drawingSquare)],
    ["triangle", imageEntry(trianglePrim, triangle)],
    ["path", imageEntry(pathPrim, path)],
    ["beside", imageEntry(besidePrim, beside)],
    ["beside/align", imageEntry(besideAlignPrim, besideAlign)],
    ["above", imageEntry(abovePrim, above)],
    ["above/align", imageEntry(aboveAlignPrim, aboveAlign)],
    ["overlay", imageEntry(overlayPrim, overlay)],
    ["overlay/align", imageEntry(overlayAlignPrim, overlayAlign)],
    ["overlay/offset", imageEntry(overlayOffsetPrim, overlayOffset)],
    ["rotate", imageEntry(rotatePrim, rotate)],
    ["with-dashes", imageEntry(withDashPrim, withDashes)]
  ]);
  function isObjKind_(arg0, arg1) {
    throw new Error("Function not implemented.");
  }

  // dist/lib/music.js
  var isPitchClass = (s) => /^[A-Ga-g][#b]{0,2}$/.test(s);
  var isOctave = (n) => n >= 0 && n <= 10;
  var note2 = (pitch2, octave2, duration) => ({
    tag: "note",
    pitch: pitch2,
    octave: octave2,
    duration
  });
  var rest2 = (duration) => ({ tag: "rest", duration });
  var par2 = (notes) => ({ tag: "par", notes });
  var seq2 = (notes) => ({ tag: "seq", notes });
  var pitchBend = (amount) => ({ tag: "pitchBend", amount });
  var pitchBendPrim = (_env, args, app) => checkArgsResult("bend", ["number?"], void 0, args, app).andThen((_) => {
    const amount = asNum_(args[0]);
    if (amount < -1 || amount > 1) {
      return runtimeError(msg("error-precondition-not-met", "bend", 1, "-1 <= amount <= 1", expToString2(0, args[0])), app);
    } else {
      return ok(nleobj("Mod", pitchBend(amount)));
    }
  });
  var tempo2 = (beat, bpm) => ({ tag: "tempo", beat, bpm });
  var tempoPrim = (_env, args, app) => checkArgsResult("tempo", ["Duration", "number?"], void 0, args, app).andThen((_) => {
    const beat = fromObj_(args[0]);
    const value = asNum_(args[1]);
    return value < 0 ? runtimeError(msg("error-precondition-not-met", "tempo", 1, "tempo >= 0", expToString2(0, args[1])), app) : ok(nleobj("Mod", tempo2(beat, value)));
  });
  var mod2 = (mod3, note3) => ({ tag: "mod", note: note3, mod: mod3 });
  var modPrim = (_env, args, app) => checkArgsResult("mod", ["Mod", "Composition"], void 0, args, app).andThen((_) => ok(nleobj("Composition", mod2(fromObj_(args[0]), fromObj_(args[1])))));
  var pitchPrim = (_env, args, app) => checkArgsResult("pitch?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isString(args[0]) && isPitchClass(asString_(args[0])))));
  var octavePrim = (_env, args, app) => checkArgsResult("octave?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(isInteger(args[0]) && isOctave(asNum_(args[0])))));
  var durQPrim = (_env, args, app) => checkArgsResult("dur?", ["any"], void 0, args, app).andThen((_) => ok(nlebool(args[0].tag == "obj" && args[0].kind == "dur")));
  var durPrim = (_env, args, app) => checkArgsResult("dur", ["number?", "number?"], void 0, args, app).andThen((_) => ok(nleobj("Duration", {
    num: asNum_(args[0]),
    den: asNum_(args[1])
  })));
  var notePrim = (_env, args, app) => {
    const argErr = checkArgs("note", ["string?", "integer?", "Duration"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const pitch2 = asString_(args[0]);
    const octave2 = asNum_(args[1]);
    const dur2 = fromObj_(args[2]);
    if (!isPitchClass(pitch2)) {
      return runtimeError(msg("error-type-expected-fun", 1, "note", "pitch", args[0].tag), app);
    } else if (!isOctave(octave2)) {
      return runtimeError(msg("error-type-expected-fun", 1, "note", "octave", args[1].tag), app);
    } else {
      return ok(nleobj("Composition", note2(pitch2, octave2, dur2)));
    }
  };
  var restPrim = (_env, args, app) => {
    const argErr = checkArgs("rest", ["Duration"], void 0, args, app);
    if (argErr) {
      return argErr;
    }
    const dur2 = fromObj_(args[0]);
    return ok(nleobj("Composition", rest2(dur2)));
  };
  var parPrim = (_env, args, app) => checkArgsResult("par", [], "Composition", args, app).andThen((_) => ok(nleobj("Composition", par2(args.map((e) => fromObj_(e))))));
  var seqPrim = (_env, args, app) => checkArgsResult("seq", [], "Composition", args, app).andThen((_) => ok(nleobj("Composition", seq2(args.map((e) => fromObj_(e))))));
  var musicEntry = (prim, docs) => entry(nleprim(prim), "music", void 0, docs);
  var musicLib = new Env([
    ["pitch?", musicEntry(pitchPrim, pitch)],
    ["octave?", musicEntry(octavePrim, octave)],
    ["dur?", musicEntry(durQPrim, durQ)],
    ["dur", musicEntry(durPrim, dur)],
    ["note", musicEntry(notePrim, note)],
    ["rest", musicEntry(restPrim, rest)],
    ["par", musicEntry(parPrim, par)],
    ["seq", musicEntry(seqPrim, seq)],
    ["mod", musicEntry(modPrim, mod)],
    ["bend", musicEntry(pitchBendPrim, bend)],
    ["tempo", musicEntry(tempoPrim, tempo)]
  ]);

  // dist/runtime.js
  function runtimeError(message, s, hint) {
    return s ? error(msg("phase-runtime"), message, s.range, expToString(s), hint) : error(msg("phase-runtime"), message, void 0, void 0, hint);
  }
  function namesInclude(names, x) {
    return names.some((n) => n.value === x);
  }
  function substitute(e1, x, e2) {
    switch (e2.tag) {
      case "var":
        return e2.value === x ? e1 : e2;
      case "lit":
        return e2;
      case "call":
        return ecall(e2.range, substitute(e1, x, e2.head), e2.args.map((e) => substitute(e1, x, e)));
      case "lam":
        return namesInclude(e2.args, x) ? e2 : elam(e2.range, e2.args, substitute(e1, x, e2.body));
      case "if":
        return eif(e2.range, substitute(e1, x, e2.e1), substitute(e1, x, e2.e2), substitute(e1, x, e2.e3));
      case "nil":
        return e2;
      case "pair":
        return epair(e2.range, substitute(e1, x, e2.e1), substitute(e1, x, e2.e2));
      case "let":
        return elet(e2.range, substituteTelescope(e1, x, e2.bindings), inBindings(x, e2.bindings) ? e2.body : substitute(e1, x, e2.body));
      case "cond":
        return econd(e2.range, e2.branches.map((b) => [substitute(e1, x, b[0]), substitute(e1, x, b[1])]));
      case "and":
        return eand(e2.range, e2.args.map((e) => substitute(e1, x, e)));
      case "or":
        return eor(e2.range, e2.args.map((e) => substitute(e1, x, e)));
      case "struct":
        return e2;
      case "obj":
        return e2;
      case "prim":
        return e2;
    }
  }
  function inBindings(x, bindings) {
    for (let i = 0; i < bindings.length; i++) {
      if (bindings[i][0].value === x) {
        return true;
      }
    }
    return false;
  }
  function substituteTelescope(e1, x, bindings) {
    const result = new Array(bindings.length);
    let seenVar = false;
    for (let i = 0; i < bindings.length; i++) {
      if (seenVar) {
        result[i] = bindings[i];
      } else if (bindings[i][0].value === x) {
        result[i] = bindings[i];
        seenVar = true;
      } else {
        result[i] = [bindings[i][0], substitute(e1, x, bindings[i][1])];
      }
    }
    return result;
  }
  function substituteAll(es, xs, e) {
    for (let i = 0; i < es.length; i++) {
      e = substitute(es[i], xs[i].value, e);
    }
    return e;
  }
  function substituteIfFreeVar(env, e) {
    switch (e.tag) {
      case "var":
        if (env.has(e.value)) {
          const result = env.get(e.value).value;
          if (result.tag === "var") {
            return substituteIfFreeVar(env, result);
          } else {
            return ok(result);
          }
        } else {
          return runtimeError(msg("error-var-undef", e.value), e);
        }
      default:
        return ok(e);
    }
  }
  function stepExp(env, e) {
    switch (e.tag) {
      case "var":
        return ok(e);
      case "lit":
        return ok(e);
      case "call":
        if (!isValue(e.head)) {
          return stepExp(env, e.head).andThen((headp) => stepExp(env, ecall(e.range, headp, e.args)));
        } else {
          for (let i = 0; i < e.args.length; i++) {
            if (!isValue(e.args[i])) {
              const argsp = [...e.args];
              return stepExp(env, argsp[i]).andThen((eip) => {
                argsp[i] = eip;
                return ok(ecall(e.range, e.head, argsp));
              });
            }
          }
          return substituteIfFreeVar(env, e.head).andThen((head) => join(e.args.map((x) => substituteIfFreeVar(env, x))).andThen((args) => {
            switch (head.tag) {
              case "lam":
                if (args.length === head.args.length) {
                  return ok(substituteAll(args, head.args, head.body));
                } else {
                  return runtimeError(msg("error-arity", "lambda", head.args.length, args.length), e);
                }
              case "prim":
                return head.prim(env, args, e);
              default:
                return runtimeError(msg("error-type-expected-call", e.head.tag), e);
            }
          }));
        }
      case "lam":
        return ok(e);
      case "if":
        if (!isValue(e.e1)) {
          return stepExp(env, e.e1).andThen((e1p) => ok(eif(e.range, e1p, e.e2, e.e3)));
        } else {
          switch (e.e1.tag) {
            case "lit":
              if (e.e1.value.tag === "bool") {
                return e.e1.value.value ? ok(e.e2) : ok(e.e3);
              } else {
                return runtimeError(msg("error-type-expected-cond", e.e1.value.tag), e);
              }
            default:
              return runtimeError(msg("error-type-expected-cond", e.e1.tag), e);
          }
        }
      case "nil":
        return ok(e);
      case "pair":
        if (!isValue(e.e1)) {
          return stepExp(env, e.e1).andThen((e1p) => ok(epair(e.range, e1p, e.e2)));
        } else if (!isValue(e.e2)) {
          return stepExp(env, e.e2).andThen((e2p) => ok(epair(e.range, e.e1, e2p)));
        } else {
          return ok(e);
        }
      case "let":
        if (e.bindings.length > 0) {
          const x = e.bindings[0][0];
          const e1 = e.bindings[0][1];
          if (!isValue(e1)) {
            return stepExp(env, e1).andThen((e1p) => {
              const bindings = [...e.bindings];
              bindings[0] = [x, e1p];
              return ok(elet(e.range, bindings, e.body));
            });
          } else {
            return e.bindings.length === 1 ? ok(substitute(e1, x.value, e.body)) : ok(elet(
              e.range,
              substituteTelescope(e1, x.value, e.bindings.slice(1)),
              e.bindings.slice(1).map((b) => b[0].value).includes(x.value) ? e.body : substitute(e1, x.value, e.body)
            ));
          }
        } else {
          return ok(e.body);
        }
      case "cond":
        if (e.branches.length === 0) {
          return runtimeError(msg("error-cond-no-branch-applies"), e);
        } else {
          const guard = e.branches[0][0];
          const body = e.branches[0][1];
          if (isValue(e.branches[0][0])) {
            if (guard.tag === "lit" && guard.value.tag === "bool" && guard.value.value === true) {
              return ok(body);
            } else if (guard.tag === "lit" && guard.value.tag === "bool" && guard.value.value === false) {
              return ok(nlecond([...e.branches.slice(1)]));
            } else {
              return runtimeError(msg("error-type-expected-cond", guard.tag), e);
            }
          } else {
            return stepExp(env, guard).andThen((guardp) => ok(nlecond([[guardp, body], ...e.branches.slice(1)])));
          }
        }
      case "and":
        if (e.args.length === 0) {
          return ok(nlebool(true));
        } else {
          const head = e.args[0];
          if (isValue(head)) {
            if (head.tag === "lit" && head.value.tag === "bool") {
              return head.value.value ? ok(nleand([...e.args.slice(1)])) : ok(nlebool(false));
            } else {
              return runtimeError(msg("error-type-expected", "bool", head.tag), e);
            }
          } else {
            return stepExp(env, head).andThen((headp) => ok(nleand([headp, ...e.args.slice(1)])));
          }
        }
      case "or":
        if (e.args.length === 0) {
          return ok(nlebool(false));
        } else {
          const head = e.args[0];
          if (isValue(head)) {
            if (head.tag === "lit" && head.value.tag === "bool") {
              return !head.value.value ? ok(nleor([...e.args.slice(1)])) : ok(nlebool(true));
            } else {
              return runtimeError(msg("error-type-expected", "bool", head.tag), e);
            }
          } else {
            return stepExp(env, head).andThen((headp) => ok(nleor([headp, ...e.args.slice(1)])));
          }
        }
      case "struct":
        return ok(e);
      case "obj":
        return ok(e);
      case "prim":
        return ok(e);
    }
  }
  function evaluateExp(env, e) {
    while (!isValue(e)) {
      const result = stepExp(env, e);
      switch (result.tag) {
        case "error":
          return rethrow(result);
        case "ok":
          e = result.value;
      }
    }
    return ok(e);
  }
  function resultToStmt(result) {
    switch (result.tag) {
      case "error":
        return serror(result.details);
      case "ok":
        return result.value;
    }
  }
  function stepStmt(env, s) {
    switch (s.tag) {
      case "error":
        return [env, s];
      case "binding":
        return [env, s];
      case "value":
        return [env, s];
      case "imported":
        return [env, s];
      case "define":
        if (isValue(s.value)) {
          return [
            env.append(s.name.value, entry(s.value, "binding", s.name.range)),
            sbinding(s.name.value)
          ];
        } else {
          return [
            env,
            resultToStmt(stepExp(env, s.value).andThen((e) => ok(sdefine(s.name, e))))
          ];
        }
      case "struct": {
        const name2 = s.id.value;
        const predName = `${name2}?`;
        const predPrim = (env2, args, app) => args.length !== 1 ? runtimeError(msg("error-arity", predName, 1, args.length), app) : ok(nlebool(isStructKind(args[0], name2)));
        const fieldPrims = s.fields.map((f) => {
          const fieldName = `${name2}-${f.value}`;
          return [fieldName, entry(nleprim((env2, args, app) => args.length !== 1 ? runtimeError(msg("error-arity", fieldName, 1, args.length), app) : !isStructKind(args[0], name2) ? runtimeError(msg("error-type-expected-fun", 1, fieldName, `struct ${name2}`, args[0].tag)) : ok(asStruct_(args[0])[f.value])), `struct ${name2}`, f.range)];
        });
        const ctorPrim = (env2, args, app) => {
          if (args.length !== s.fields.length) {
            return runtimeError(msg("error-arity", name2, s.fields.length, args.length), app);
          } else {
            const obj = {};
            s.fields.forEach((f, i) => obj[f.value] = args[i]);
            return ok(nlestruct(name2, obj));
          }
        };
        return [
          env.concat(new Env([
            [name2, entry(nleprim(ctorPrim), "struct ${name}", s.id.range)],
            [predName, entry(nleprim(predPrim), "struct ${name}", s.id.range)],
            ...fieldPrims
          ])),
          sbinding(`struct ${name2}`)
        ];
      }
      case "exp": {
        const result = isValue(s.value) ? resultToStmt(substituteIfFreeVar(env, s.value).andThen((vp) => ok(svalue(vp)))) : resultToStmt(stepExp(env, s.value).andThen((v) => isValue(v) ? substituteIfFreeVar(env, v).andThen((vp) => ok(svalue(vp))) : ok(sexp(v))));
        return [env, result];
      }
      case "import":
        if (internalLibs.has(s.source)) {
          return [
            new Env([...env.items(), ...internalLibs.get(s.source).items()]),
            simported(s.source)
          ];
        } else {
          return [
            env,
            serror([errorDetails(msg("phase-runtime"), msg("error-import-not-found", s.source, s.range))])
          ];
        }
    }
  }
  var internalLibs = /* @__PURE__ */ new Map([
    ["image", imageLib],
    ["music", musicLib]
  ]);

  // dist/scope.js
  function undefinedVariableError(x, range) {
    return errorDetails(msg("phase-scope"), msg("error-var-undef", x), range, x);
  }
  function checkExp(bvars, e) {
    switch (e.tag) {
      case "var":
        return bvars.includes(e.value) ? [] : [undefinedVariableError(e.value, e.range)];
      case "lit":
        return [];
      case "call":
        return checkExp(bvars, e.head).concat(e.args.flatMap((v) => checkExp(bvars, v)));
      case "lam":
        return checkExp(bvars.concat(e.args.map((n) => n.value)), e.body);
      case "if":
        return checkExp(bvars, e.e1).concat(checkExp(bvars, e.e2).concat(checkExp(bvars, e.e3)));
      case "nil":
        return [];
      case "pair":
        return checkExp(bvars, e.e1).concat(checkExp(bvars, e.e2));
      case "let": {
        let errors2 = [];
        e.bindings.forEach((binding) => {
          bvars = bvars.concat(binding[0].value);
          errors2 = errors2.concat(checkExp(bvars, binding[1]));
        });
        return errors2.concat(checkExp(bvars, e.body));
      }
      case "cond":
        return e.branches.flatMap((b) => checkExp(bvars, b[0]).concat(checkExp(bvars, b[1])));
      case "and":
        return e.args.flatMap((v) => checkExp(bvars, v));
      case "or":
        return e.args.flatMap((v) => checkExp(bvars, v));
      case "struct":
        return [];
      case "obj":
        return [];
      case "prim":
        return [];
    }
  }
  function checkProgram(bvars, prog) {
    let errors2 = [];
    prog.statements.forEach((s) => {
      switch (s.tag) {
        case "define":
          bvars = bvars.concat([s.name.value]);
          errors2 = errors2.concat(checkExp(bvars, s.value));
          return;
        case "struct": {
          let structBvars = [
            name(s.id.value, s.id.range),
            name(`${s.id.value}?`, s.id.range),
            ...s.fields.map((f) => name(`${s.id.value}-${f.value}`, f.range))
          ];
          bvars = bvars.concat(structBvars.map((n) => n.value));
          return;
        }
        case "exp":
          errors2 = errors2.concat(checkExp(bvars, s.value));
          return;
        case "import":
          if (internalLibs.has(s.source)) {
            bvars = bvars.concat(Array.from(internalLibs.get(s.source).names()));
          }
      }
    });
    return errors2;
  }
  function mkInitialBVars(env) {
    return Array.from(env.names());
  }
  function scopeCheckProgram(prog, env = preludeEnv) {
    return checkProgram(mkInitialBVars(env), prog);
  }

  // dist/program.js
  var ProgramState = class {
    env;
    prog;
    constructor(prog, env) {
      this.env = env || preludeEnv;
      this.prog = prog;
    }
    isFullyEvaluated() {
      return this.prog.statements.every(isStmtDone);
    }
    step() {
      for (let i = 0; i < this.prog.statements.length; i++) {
        const s = this.prog.statements[i];
        if (!isStmtDone(s)) {
          const result = stepStmt(this.env, s);
          const prog = {
            statements: [...this.prog.statements]
          };
          prog.statements[i] = result[1];
          return new ProgramState(prog, result[0]);
        }
      }
      return this;
    }
    evaluate() {
      let st = this;
      while (!st.isFullyEvaluated()) {
        st = st.step();
      }
      return st;
    }
    stepExp(e) {
      return stepExp(this.env, e);
    }
    evaluateExp(e) {
      return evaluateExp(this.env, e);
    }
    toString(outputBindings) {
      return progToString(0, this.prog, outputBindings);
    }
  };
  var ProgramTrace = class {
    states;
    pos;
    constructor(initial) {
      this.states = [initial];
      this.pos = 0;
    }
    getCurrentState() {
      return this.states[this.pos];
    }
    stepForward() {
      const lastI = this.states.length - 1;
      if (this.pos === lastI && !this.states[lastI].isFullyEvaluated()) {
        this.states.push(this.states[lastI].step());
        this.pos += 1;
      } else if (this.pos < lastI) {
        this.pos += 1;
      }
    }
    stepBackward() {
      if (this.pos > 0) {
        this.pos--;
      }
    }
    evalNextStmt() {
      if (this.getCurrentState().isFullyEvaluated()) {
        return;
      }
      const i = indexOfCurrentStmt(this.getCurrentState().prog);
      while (indexOfCurrentStmt(this.getCurrentState().prog) === i) {
        this.stepForward();
      }
    }
    revertPrevStmt() {
      const i = indexOfCurrentStmt(this.getCurrentState().prog);
      while (indexOfCurrentStmt(this.getCurrentState().prog) === i && this.pos > 0) {
        this.stepBackward();
      }
    }
    evaluateProg() {
      while (!this.states[this.pos].isFullyEvaluated()) {
        this.stepForward();
      }
    }
    resetProg() {
      this.pos = 0;
    }
    currentStep() {
      return this.pos + 1;
    }
    currentState() {
      return this.states[this.pos];
    }
    addStmt(src) {
      this.evaluateProg();
      const result = parseProgram(src).andThen((prog) => detailsToResult(scopeCheckProgram(prog, this.states[this.states.length - 1].env)).andThen((_) => {
        this.states.forEach((st) => {
          st.prog.statements = st.prog.statements.concat(prog.statements);
        });
        return ok(null);
      }));
      switch (result.tag) {
        case "ok":
          return;
        case "error":
          this.states.forEach((st) => {
            st.prog.statements.push(serror(result.details));
          });
      }
    }
  };

  // dist/index.js
  function compileProgram(src) {
    return parseProgram(src).andThen((prog) => detailsToResult(scopeCheckProgram(prog)).andThen((_) => ok(prog)));
  }

  // dist/web/index.js
  var JZZ2 = __toESM(require_jzz_combined(), 1);
  var global2 = window;
  var SYNTH = JZZ2.synth.Tiny();
  function forEachByClass(elt, cls, fn) {
    Array.from(elt.getElementsByClassName(cls)).forEach((e) => fn(e));
  }
  function renderRichWidgets(root) {
    forEachByClass(document, "drawing", emitDrawingWidget);
    forEachByClass(document, "composition", (e) => emitCompositionWidget(SYNTH, e));
  }
  function sanitize(s) {
    return s.replace("<?", "&lt;?");
  }
  function replaceOutputWidgets() {
    for (const element of document.getElementsByClassName("scamper-output")) {
      const classes = element.className.split(" ");
      const outputProg = classes.includes("output-prog");
      const src = element.textContent;
      const result = compileProgram(src).andThen((prog) => ok({
        statements: prog.statements,
        outputs: new ProgramState(prog).evaluate().prog.statements
      }));
      if (result.tag === "error") {
        element.innerHTML = errorToString(result);
      } else {
        element.innerHTML = "";
        for (var i = 0; i < result.value.statements.length; i++) {
          if (outputProg) {
            element.innerHTML += [
              `&gt; ${sanitize(stmtToString(0, result.value.statements[i], false, true))}`,
              sanitize(stmtToString(0, result.value.outputs[i], true, true)),
              "",
              ""
            ].join("\n");
          } else {
            const line = sanitize(stmtToString(0, result.value.outputs[i], false, true));
            if (line.trim().length > 0) {
              element.innerHTML += `${line}
`;
            }
          }
        }
        renderRichWidgets(element);
      }
    }
  }
  function replaceExplorationWidgets() {
    for (const element of document.getElementsByClassName("scamper-exploration")) {
      const progElements = element.getElementsByClassName("program");
      if (progElements.length !== 1) {
        element.innerHTML = "Error: there must be exactly one program element in this widget";
        return;
      }
      const programElement = progElements[0];
      const src = programElement.textContent;
      const result = compileProgram(src);
      if (result.tag === "error") {
        element.innerHTML = errorToString(result);
        return;
      } else {
        const trace = new ProgramTrace(new ProgramState(result.value));
        const update = () => {
          forEachByClass(element, "step-counter", (e) => {
            e.innerHTML = `Step ${trace.currentStep()}`;
          });
          programElement.innerHTML = sanitize(progToString(0, trace.currentState().prog, true, true));
          renderRichWidgets(programElement);
        };
        forEachByClass(element, "step-forward", (e) => {
          e.onclick = () => {
            trace.stepForward();
            update();
          };
        });
        forEachByClass(element, "step-backward", (e) => {
          e.onclick = () => {
            trace.stepBackward();
            update();
          };
        });
        forEachByClass(element, "stmt-forward", (e) => {
          e.onclick = () => {
            trace.evalNextStmt();
            update();
          };
        });
        forEachByClass(element, "stmt-backward", (e) => {
          e.onclick = () => {
            trace.revertPrevStmt();
            update();
          };
        });
        forEachByClass(element, "eval", (e) => {
          e.onclick = () => {
            trace.evaluateProg();
            update();
          };
        });
        forEachByClass(element, "reset", (e) => {
          e.onclick = () => {
            trace.resetProg();
            update();
          };
        });
        forEachByClass(element, "add-statement", (e) => {
          e.onclick = () => {
            const inputs = document.getElementsByClassName("add-statement-input");
            if (inputs.length > 0) {
              const input = inputs[0];
              if (input.value.length > 0) {
                trace.addStmt(input.value);
                trace.evaluateProg();
                input.value = "";
                update();
              }
            }
          };
        });
        update();
      }
    }
  }
  global2.replaceCodeWidgets = function() {
    replaceOutputWidgets();
    replaceExplorationWidgets();
  };
})();
  </script>
  <script>
    function runFromClipboard() {
      navigator.clipboard.readText().then(
        (clipText) => {
          document.getElementById("output").innerHTML = clipText.replace("<?", "&lt;?")
          replaceCodeWidgets()
        })
    }
  </script>
</html>
